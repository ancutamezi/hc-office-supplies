const cds = require('../../../cds')
const LOG = cds.log('odata')
const { BASE_TENANT, channelName } = require('../../../common/utils/extensibilityUtils')

const { SYSTEM_SERVICES, createOdataService, createNewService, getModelHash } = require('./utils/dispatcherUtils')

const { normalizeError } = require('../../../common/error/frontend')

class Dispatcher {
  /**
   * Constructs an Dispatcher for cds service.
   * New OData services will be created.
   *
   * @param service
   */
  constructor(service) {
    this._serviceName = service.definition.name
    this._options = service.options

    this._extMap = new Map()
    this._extMap.set(getModelHash(BASE_TENANT, []), createOdataService(service))

    if (cds.requires.extensibility && !SYSTEM_SERVICES.includes(this._serviceName)) {
      cds.services['mtx-messaging'].on(channelName(), async msg => {
        const tenant = msg.data.tenant
        const hash = getModelHash(tenant, [])
        for (const entry of this._extMap.entries()) {
          if (entry[0].startsWith(hash)) {
            this._extMap.delete(entry[0])
          }
        }
      })
    }

    if (cds._mtxEnabled) {
      cds.mtx.eventEmitter.on(cds.mtx.events.TENANT_UPDATED, async hash => {
        this._extMap.delete(hash)
      })
    }
  }

  async _getService4Tenant(req) {
    // here, req is express' req -> req.tenant not available
    const tenant = req.user && req.user.tenant
    const isExtended = await cds.mtx.isExtended(tenant) // REVISIT: avoid await
    if (!isExtended) return false

    const csn = await cds.mtx.getCsn(tenant)
    const model = cds.compile.for.nodejs(csn)
    const service = await createNewService(this._serviceName, model, this._options)
    service._cdsService._isExtended = true
    return service
  }

  async _getService4(tenant, features) {
    const csn = await this._mps.getCsn(tenant, features || [], 'nodejs')
    const model = cds.compile.for.nodejs(csn)
    return createNewService(this._serviceName, model, this._options)
  }

  async _getService(tenant, features, hash, req) {
    if (cds._mtxEnabled) {
      const service = await this._getService4Tenant(req)

      if (service) return service

      return this._extMap.get(getModelHash(BASE_TENANT, []))
    }

    if (!this._mps) this._mps = await cds.connect.to('cds_r.ModelProviderService')
    const hashBase = getModelHash(BASE_TENANT, features)
    if (tenant && tenant !== BASE_TENANT && hash !== hashBase) {
      const isExtended = cds.requires.extensibility && (await this._mps.isExtended(tenant))
      if (isExtended) {
        return this._getService4(tenant, features)
      } else {
        if (!this._extMap.has(hashBase)) {
          this._extMap.set(hashBase, this._getService4(BASE_TENANT, features))
        }
        return this._extMap.get(hashBase)
      }
    } else {
      return this._getService4(BASE_TENANT, features)
    }
  }

  async _handleError(err, hash, req, res) {
    if (LOG._error) {
      err.message = 'Unable to get service from service map due to error: ' + err.message
      LOG.error(err)
    }
    // clear map entry
    this._extMap.delete(hash)
    // return 503 to client
    const { error } = normalizeError(Object.assign(err, { statusCode: 503 }), req)

    return res.status(503).send({ error })
  }

  /**
   * Dispatch request in case of extensibility to other odata adapters.
   *
   * @param req
   * @param res
   * @private
   * @returns {Promise}
   */
  async dispatch(req, res) {
    // here, req is express' req -> req.tenant not available
    const tenant = req.user && req.user.tenant

    if (SYSTEM_SERVICES.includes(this._serviceName) || (!tenant && !cds._mpsEnabled)) {
      const service = this._extMap.get(getModelHash(BASE_TENANT, []))
      return service.process(req, res)
    }

    // ensure features is an array (some stakeholders set req.features themselves)
    const features = req.features
      ? Array.isArray(req.features)
        ? req.features
        : Object.keys(req.features)
            .filter(k => req.features[k])
            .sort()
      : []
    const hash = getModelHash(tenant, features)

    // set promise into the map to avoid conflicts
    if (!this._extMap.has(hash)) {
      this._extMap.set(hash, this._getService(tenant, features, hash, req))
    }

    let service
    try {
      service = await this._extMap.get(hash)
    } catch (err) {
      return this._handleError(err, hash, req, res)
    }

    service.process(req, res)
  }

  /**
   * Return service middleware, which can be used by node server, express, connect, ...
   *
   * @returns {Function}
   */
  getService() {
    return (req, res) => {
      this.dispatch(req, res)
    }
  }
}

module.exports = Dispatcher
