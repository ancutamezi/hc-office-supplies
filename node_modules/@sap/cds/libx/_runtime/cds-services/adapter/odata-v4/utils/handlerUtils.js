const cds = require('../../../../cds')
const { SELECT } = cds.ql
const { isCustomOperation } = require('./request')
const expandToCQN = require('../odata-to-cqn/expandToCQN')
const QueryOptions = require('../okra/odata-server').QueryOptions
const { COMPLEX_PROPERTY, PRIMITIVE_PROPERTY } = require('../okra/odata-server').uri.UriResource.ResourceKind
const { mergeJson } = require('../../../services/utils/compareJson')
const { getColumns } = require('../../../services/utils/columns')

const _selectForFunction = (selectColumns, result, opReturnType) => {
  if (!Array.isArray(result)) result = [result]

  const keys = opReturnType.keys

  for (const row of result) {
    for (const entry in row) {
      if (keys[entry] || entry.match(/^\*/)) continue

      if (!selectColumns.includes(entry)) {
        delete row[entry]
      }
    }
  }
}

const { ensureDraftsSuffix, isDraftActivateAction } = require('../../../../fiori/utils/handler')

const _expand = (model, uriInfo, options) => {
  const expand = uriInfo.getQueryOption(QueryOptions.EXPAND)

  if (!expand || expand.length === 0) {
    return []
  }

  return expandToCQN(model, expand, uriInfo.getFinalEdmType(), options)
}

const _compareKeys = (first, second) => key => {
  const val1 = first[key]
  const val2 = second[key]
  if (Array.isArray(val1) || Buffer.isBuffer(val1)) return val1.every((_, i) => _compareKeys(val1, val2)(i))
  if (val1 && typeof val1 === 'object') return Object.keys(val1).every(_compareKeys(val1, val2))
  return val1 === val2
}

const _expandForFunction = async (uriInfo, result, req, srv, opReturnType) => {
  const results = Array.isArray(result) ? result : [result]
  const isDraft = opReturnType._isDraftEnabled
  const isDraftActivate = isDraftActivateAction(req)

  // REVISIT: what happens here exactly?
  const selectQuery = SELECT.from(
    isDraft && !isDraftActivate ? ensureDraftsSuffix(opReturnType.name) : opReturnType.name
  )
  const keys = getColumns(opReturnType, {
    onlyNames: true,
    removeIgnore: true,
    filterDraft: !isDraft || isDraftActivate,
    filterVirtual: true,
    keysOnly: true
  })
  const expandCqn = _expand(srv.model, uriInfo, { rewriteAsterisks: true })
  selectQuery.columns(expandCqn)
  selectQuery.columns(keys)
  for (const row of results) {
    const where = ['(']
    for (const key of keys) {
      where.push({ ref: [key] }, '=', { val: row[key] }, 'and')
    }
    where.pop() // last 'and'
    where.push(')')
    if (!selectQuery.SELECT.where) selectQuery.where(where)
    else selectQuery.or(where)
  }
  const expandedResults = await cds.tx(req).run(selectQuery)

  for (let i = 0; i < results.length; i++) {
    const result = results[i]
    const res = expandedResults.find(r => keys.every(_compareKeys(result, r)))
    if (res) results[i] = mergeJson(res, result, opReturnType)
  }
  return Array.isArray(result) ? results : results[0]
}

const _cleanupResult = (result, opReturnType) => {
  if (!Array.isArray(result)) result = [result]

  for (const row of result) {
    for (const element in opReturnType.elements) {
      if (opReturnType.elements[element].is2many) {
        delete row[element]
      }
    }
  }
}

const getActionOrFunctionReturnType = (pathSegments, definitions) => {
  if (!isCustomOperation(pathSegments, true)) return

  const actionOrFunction =
    pathSegments[pathSegments.length - 1].getFunction() || pathSegments[pathSegments.length - 1].getAction()

  if (actionOrFunction) {
    const returnType = actionOrFunction.getReturnType()
    if (returnType) {
      return definitions[returnType.getType().getFullQualifiedName().toString()]
    }
  }
}

const actionAndFunctionQueries = async (req, odataReq, result, srv, opReturnType) => {
  _cleanupResult(result, opReturnType)

  // REVISIT consider $expand columns as inline content for $select
  if (odataReq.getQueryOptions().$select) {
    _selectForFunction(odataReq.getQueryOptions().$select.split(','), result, opReturnType)
  }

  // REVISIT: we need to read directly from db for this, which might not be there!
  if (odataReq.getQueryOptions().$expand && cds.db) {
    result = await _expandForFunction(odataReq.getUriInfo(), result, req, srv, opReturnType)
  }
  return result
}

const resolveStructuredName = (pathSegments, index, nameArr = []) => {
  if (pathSegments[index].getKind() === COMPLEX_PROPERTY) {
    const prop = pathSegments[index].getProperty()
    nameArr.unshift(prop.getName())
    return resolveStructuredName(pathSegments, --index, nameArr)
  } else if (
    pathSegments[index].getKind() === PRIMITIVE_PROPERTY &&
    pathSegments[index - 1].getKind() === COMPLEX_PROPERTY
  ) {
    return resolveStructuredName(pathSegments, --index, nameArr)
  }

  return nameArr
}

const isReturnMinimal = req => {
  if (!req.headers.prefer || !req.headers.prefer.includes('return=')) {
    return cds.env.odata.prefer && cds.env.odata.prefer.return === 'minimal'
  }

  return req.headers.prefer.includes('return=minimal')
}

module.exports = {
  _expand,
  resolveStructuredName,
  actionAndFunctionQueries,
  getActionOrFunctionReturnType,
  isReturnMinimal
}
