const cds = require('../cds')
const LOG = cds.log()

const _require = require('../common/utils/require')
const { UNAUTHORIZED, isRestricted } = require('./utils')

let passport, logged

// strategy initializers for lazy loading of dependencies
const _initializers = {
  // REVISIT: support basic authentication?
  basic: ({ credentials }) => {
    const BasicStrategy = require('./strategies/basic')
    passport.use(new BasicStrategy(credentials))
  },
  dummy: () => {
    const DummyStrategy = require('./strategies/dummy')
    passport.use(new DummyStrategy())
  },
  dwc: () => {
    const DwcStrategy = require('./strategies/dwc')
    passport.use(new DwcStrategy())
  },
  jwt: ({ credentials, uaa }) => {
    const JWTStrategy = require('./strategies/JWT')
    if (credentials) {
      passport.use(new JWTStrategy(credentials))
    } else if (uaa) {
      // REVISIT: compat, remove with cds^6
      passport.use(new JWTStrategy(uaa.credentials))
    } else {
      throw Object.assign(new Error('No or malformed credentials for auth kind "jwt-auth"'), { credentials })
    }
  },
  mock: ({ users }, srvName) => {
    const MockStrategy = require('./strategies/mock')
    passport.use(new MockStrategy(users, `mock_${srvName}`))
  },
  xsuaa: ({ credentials, uaa }) => {
    const XSUAAStrategy = require('./strategies/xsuaa')
    if (credentials) {
      passport.use(new XSUAAStrategy(credentials))
    } else if (uaa) {
      // REVISIT: compat, remove with cds^6
      passport.use(new XSUAAStrategy(uaa.credentials))
    } else {
      throw Object.assign(
        new Error('No or malformed credentials for auth kind "xsuaa". Make sure to bind the app to an "xsuaa" service'),
        { credentials }
      )
    }
  }
}

// map for initialized authenticators
const _authenticators = {}

const _log = (req, challenges) => {
  if (!LOG._debug) return
  const challengesLog = challenges ? ['User challenges:', challenges] : []
  LOG.debug(`User "${req.user.id}" request URL`, req.url, '\n', ...challengesLog)
}

const _authCallback = (req, res, next, internalError, user, challenges) => {
  // An internal error occurs during the authentication process
  if (internalError) {
    // REVISIT: What to do? Security log?
    return res.status(401).json(UNAUTHORIZED) // no details to client
  }

  let infoChallenges

  if (challenges) {
    if (Array.isArray(challenges)) {
      infoChallenges = challenges.filter(ele => ele)
      infoChallenges = infoChallenges.length ? infoChallenges : undefined
    } else {
      req.authInfo = challenges
    }
  }

  req.user = user || Object.defineProperty(new cds.User(), '_challenges', { enumerable: false, value: infoChallenges })
  Object.defineProperty(req.user, '_req', { enumerable: false, value: req })
  _log(req, infoChallenges)
  next()
}

const _mountMockAuth = (srv, app, strategy, config) => {
  const impl =
    strategy === 'dummy'
      ? new (require('./strategies/dummy'))()
      : new (require('./strategies/mock'))(config.users, `mock_${srv.name}`)

  app.use(srv.path, (req, res, next) => {
    let user, challenge
    impl.success = arg => (user = arg)
    impl.fail = arg => (challenge = arg)
    impl.authenticate(req)
    _authCallback(req, res, next, undefined, user, [challenge])
  })
}

const _mountPassportAuth = (srv, app, strategy, config) => {
  passport = passport || _require('passport')

  // initialize strategy
  if (!_authenticators[strategy] || strategy === 'mock' || process.env.NODE_ENV === 'test') {
    _initializers[strategy](config, srv.name)
    _authenticators[strategy] = true
  }

  // authenticate
  app.use(srv.path, passport.initialize())
  app.use(srv.path, (req, res, next) => {
    const options = { session: false, failWithError: true }
    const callback = _authCallback.bind(undefined, req, res, next)
    passport.authenticate(strategy === 'jwt' ? 'JWT' : strategy, options, callback)(req, res, next)
  })
}

/*
 * export authentication middleware
 */
// eslint-disable-next-line complexity
module.exports = (srv, app, options) => {
  // NOTE: options.auth is not an official API
  let config = 'auth' in options ? options.auth : cds.env.requires.auth

  // cds.env.requires.auth = { kind: 'xsuaa-auth' } was briefly documented on capire -> also support
  if (config && config.kind === 'xsuaa-auth' && !config.credentials) config = cds.env.requires.xsuaa

  // mount custom authentication middleware
  if (config && config.impl) {
    app.use(srv.path, _require(cds.resolve(config.impl)))
    return
  }

  const restricted = isRestricted(srv)
  if (restricted && !config) {
    // REVISIT: why exitCode needed?
    process.exitCode = 1
    throw new Error('Authentication required for authorization checks')
  }

  const isMultiTenant = cds.env.requires.db && cds.env.requires.db.multiTenant
  if (isMultiTenant && !config) {
    // REVISIT: why exitCode needed?
    process.exitCode = 1
    throw new Error('Authentication required for multitenancy')
  }

  if (!config) {
    if (!logged) {
      const msg = 'No authentication configured'
      if (process.env.NODE_ENV !== 'production') LOG._debug && LOG.debug(msg)
      else LOG._info && LOG.info(`${msg}. This is not recommended in production.`)
    }

    // no auth wanted > return
    return
  }

  // strategy from kind
  let strategy
  // compat for auth.strategy
  if (config.strategy) {
    strategy = config.strategy.toLowerCase()
  }
  strategy = strategy || config.kind.replace('-auth', '').toLowerCase()
  if (strategy === 'mocked') strategy = 'mock'

  if (!_initializers[strategy]) {
    // REVISIT: why exitCode needed?
    process.exitCode = 1
    throw new Error(`Authentication kind "${config.kind}" is not supported`)
  }

  if (!logged) LOG._debug && LOG.debug(`Using authentication kind "${config.kind}"`)

  if (strategy in { dummy: 1, mock: 1 }) {
    // > dummy or mock authentication (for development/testing)
    _mountMockAuth(srv, app, strategy, config)
  } else {
    // if no restriction and no binding, don't mount passport middleware
    if (!restricted && !config.credentials) {
      if (!logged) {
        const msg = `Service ${srv.name} is unrestricted`
        if (process.env.NODE_ENV !== 'production') LOG._debug && LOG.debug(msg)
        else LOG._info && LOG.info(`${msg}. This is not recommended in production.`)
      }

      // no auth wanted > return
      return
    }

    // > passport authentication
    _mountPassportAuth(srv, app, strategy, config)
  }

  // so we don't log the same stuff multiple times
  logged = true
}
