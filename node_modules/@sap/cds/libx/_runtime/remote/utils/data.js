const { big } = require('@sap/cds-foss')

// Code adopted from @sap/cds-odata-v2-adapter-proxy
// https://www.w3.org/TR/xmlschema11-2/#nt-duDTFrag
const DurationRegex = /^P(?:(\d)Y)?(?:(\d{1,2})M)?(?:(\d{1,2})D)?T(?:(\d{1,2})H)?(?:(\d{2})M)?(?:(\d{2}(?:\.\d+)?)S)?$/i
const DataTypeOData = {
  Binary: 'cds.Binary',
  Boolean: 'cds.Boolean',
  Byte: 'cds.Binary',
  DateTime: 'cds.DateTime',
  DateTimeOffset: 'cds.Timestamp',
  Decimal: 'cds.Decimal',
  Double: 'cds.Double',
  Single: 'cds.Double',
  Guid: 'cds.UUID',
  Int16: 'cds.Integer',
  Int32: 'cds.Integer',
  Int64: 'cds.Integer64',
  SByte: 'cds.Integer',
  String: 'cds.String',
  Date: 'cds.Date',
  Time: 'cds.TimeOfDay'
}

const _convertData = (data, target, convertValueFn) => {
  const _convertRecordFn = _getConvertRecordFn(target, convertValueFn)
  if (Array.isArray(data)) {
    return data.map(_convertRecordFn)
  }

  return _convertRecordFn(data)
}

const _getConvertRecordFn = (target, convertValueFn) => record => {
  for (const key in record) {
    if (key === '__metadata') continue

    const element = target.elements[key]
    if (!element) continue

    const recordValue = record[key]
    const value =
      (recordValue && typeof recordValue === 'object' && 'results' in recordValue && recordValue.results) || recordValue

    if (value && (element.isAssociation || Array.isArray(value))) {
      record[key] = _convertData(value, element._target, convertValueFn)
    } else {
      record[key] = convertValueFn(value, element)
    }
  }

  return record
}

// eslint-disable-next-line complexity
const _convertValue = (ieee754Compatible, exponentialDecimals) => (value, element) => {
  if (value == null) {
    return value
  }

  const type = _elementType(element)

  if (type === 'cds.Boolean') {
    if (value === 'true') {
      value = true
    } else if (value === 'false') {
      value = false
    }
  } else if (type === 'cds.Integer') {
    value = parseInt(value, 10)
  } else if (type === 'cds.Decimal' || type === 'cds.DecimalFloat' || type === 'cds.Integer64') {
    const bigValue = big(value)
    if (ieee754Compatible) {
      // TODO test with arrayed => element.items.scale?
      value = exponentialDecimals ? bigValue.toExponential(element.scale) : bigValue.toFixed(element.scale)
    } else {
      // OData V2 does not even mention ieee754Compatible, but V4 requires JSON number if ieee754Compatible=false
      value = bigValue.toNumber()
    }
  } else if (type === 'cds.Double') {
    value = parseFloat(value)
  } else if (type === 'cds.Time') {
    const match = value.match(DurationRegex)

    if (match) {
      value = `${match[4] || '00'}:${match[5] || '00'}:${match[6] || '00'}`
    }
  } else if (type === 'cds.Timestamp' || type === 'cds.DateTime' || type === 'cds.Date') {
    const match = value.match(/\/Date\((.*)\)\//)
    const ticksAndOffset = match && match.pop()

    if (ticksAndOffset) {
      value = new Date(_calculateTicksOffsetSum(ticksAndOffset)).toISOString() // always UTC
    }

    if (type === 'cds.DateTime') {
      value = value.slice(0, 19) + 'Z' // Cut millis
    } else if (type === 'cds.Date') {
      value = value.slice(0, 10) // Cut time
    }
  }

  return value
}

const _convertPayloadValue = (value, element) => {
  const type = _elementType(element)

  // see https://www.odata.org/documentation/odata-version-2-0/json-format/
  if (value == null) return value
  switch (type) {
    case 'cds.Date':
    case 'cds.DateTime':
      return `/Date(${new Date(value).getTime()})/`
    case 'cds.Binary':
    case 'cds.LargeBinary':
      return Buffer.isBuffer(value) ? value.toString('base64') : value
    case 'cds.Timestamp':
      // According to OData V2 spec, and as cds.DateTime => (V2) Edm.DateTimeOffset => cds.Timestamp,
      // cds.Timestamp should be converted into Edm.DateTimeOffset literal form `datetimeoffset'${new Date(value).toISOString()}'`
      // However, odata-v2-proxy forwards it literaly as `datetimeoffset'...'` which is rejected by okra.
      // Note that OData V2 spec example also does not contain 'datetimeoffset' predicate.
      return new Date(value).toISOString()
    default:
      return value
  }
}

const _calculateTicksOffsetSum = text => {
  return (text.replace(/\s/g, '').match(/[+-]?([0-9]+)/g) || []).reduce((sum, value, index) => {
    return sum + parseFloat(value) * (index === 0 ? 1 : 60 * 1000) // ticks are milliseconds (0), offset are minutes (1)
  }, 0)
}

const _elementType = element => {
  let type

  if (element) {
    type = element._type

    if (element['@odata.Type']) {
      const odataType = element['@odata.Type'].match(/\w+$/)
      type = (odataType && DataTypeOData[odataType[0]]) || type
    }

    if (!type && element.items && element.items._type) {
      type = element.items._type
    }
  }

  return type
}

const convertV2ResponseData = (data, target, ieee754Compatible, exponentialDecimals) => {
  if (!target || !target.elements) return data
  return _convertData(data, target, _convertValue(ieee754Compatible, exponentialDecimals))
}

const convertV2PayloadData = (data, target) => {
  if (!target || !target.elements) return data
  return _convertData(data, target, _convertPayloadValue)
}

const deepSanitize = arg => {
  if (Array.isArray(arg)) return arg.map(deepSanitize)
  if (typeof arg === 'object' && arg !== null)
    return Object.keys(arg).reduce((acc, cur) => {
      acc[cur] = deepSanitize(arg[cur])
      return acc
    }, {})
  return '***'
}

module.exports = {
  convertV2ResponseData,
  convertV2PayloadData,
  deepSanitize
}
