/*
 * OData spec:
 *   This object MUST contain name/value pairs with the names code and message,
 *   and it MAY contain name/value pairs with the names target, details and innererror.
 *   [...]
 *   Error responses MAY contain annotations in any of its JSON objects.
 */

let _i18n
const i18n = (...args) => {
  if (!_i18n) _i18n = require('../i18n')
  return _i18n(...args)
}

const {
  ALLOWED_PROPERTIES_MAP,
  ADDITIONAL_MSG_PROPERTIES_MAP,
  DEFAULT_SEVERITY,
  MIN_SEVERITY,
  MAX_SEVERITY
} = require('./constants')
const ADDITIONAL_MSG_PROPERTIES = Object.keys(ADDITIONAL_MSG_PROPERTIES_MAP)

const SKIP_SANITIZATION = '@cds.skip_sanitization'

const _getFiltered = err => {
  const error = {}

  Object.keys(err)
    .concat(['message'])
    .forEach(k => {
      // REVISIT: do not remove innererror with cds^6
      if (k === 'innererror' && process.env.NODE_ENV === 'production' && !err[SKIP_SANITIZATION]) return
      if (k in ALLOWED_PROPERTIES_MAP || k.startsWith('@')) {
        error[k] = err[k]
      } else if (k === 'numericSeverity') {
        error['@Common.numericSeverity'] = err[k]
      }
    })

  return error
}

const _rewrite = error => {
  // REVISIT: db stuff probably shouldn't be here
  if (error.code === 'SQLITE_ERROR') {
    error.code = '500'
  } else if (
    (error.code.startsWith('SQLITE_CONSTRAINT') && error.message.match(/COMMIT/)) ||
    (error.code.startsWith('SQLITE_CONSTRAINT') && error.message.match(/FOREIGN KEY/)) ||
    (error.code === '155' && error.message.match(/fk constraint violation/))
  ) {
    // > foreign key constaint violation no sqlite/ hana
    error.code = '400'
    error.message = i18n('FK_CONSTRAINT_VIOLATION')
  } else if (error.code.startsWith('ASSERT_')) {
    error.code = '400'
  }
}

const _normalize = (err, locale, inner = false) => {
  // message (i18n)
  err.message = i18n(err.message || err.code, locale, err.args) || err.message || `${err.code}`

  // only allowed properties
  const error = _getFiltered(err)

  // ensure code is set and a string
  error.code = String(error.code || 'null')

  // details
  if (!inner && err.details) {
    error.details = err.details.map(ele => _normalize(ele, locale, true))
  }

  // REVISIT: code and message rewriting
  _rewrite(error)

  return error
}

const _isAllowedError = errorCode => {
  return errorCode >= 300 && errorCode < 505
}

const localeFrom = require('../../../../lib/req/locale')

// - for one unique value, we use it
// - if at least one 5xx exists, we use 500
// - else if at least one 4xx exists, we use 400
// - else we use 500
const _statusCodeFromDetails = details => {
  const uniqueStatusCodes = new Set(
    details.map(d => d.status || d.statusCode || d.code).map(c => (!isNaN(c) && Number(c)) || c)
  )
  if (uniqueStatusCodes.size === 1) return uniqueStatusCodes.values().next().value
  if ([...uniqueStatusCodes].some(s => s >= 500)) return 500
  if ([...uniqueStatusCodes].some(s => s >= 400)) return 400
  return 500
}

const normalizeError = (err, req) => {
  const locale = req.locale || (req.locale = localeFrom(req))
  const error = _normalize(err, locale)

  // derive status code from err status OR root code OR matching detail codes
  let statusCode = err.status || err.statusCode || (_isAllowedError(error.code) && error.code)
  if (!statusCode && error.details) {
    const detailsCode = _statusCodeFromDetails(error.details)
    if (_isAllowedError(detailsCode)) statusCode = detailsCode
  }

  // make sure it's a number
  statusCode = statusCode ? Number(statusCode) : 500

  // REVISIT: make === 500 in cds^6
  // error[SKIP_SANITIZATION] is not an official API!!!
  if (statusCode >= 500 && process.env.NODE_ENV === 'production' && !error[SKIP_SANITIZATION]) {
    // > return sanitized error to client
    return { error: { code: `${statusCode}`, message: i18n(statusCode, locale) }, statusCode }
  }
  delete error[SKIP_SANITIZATION]

  // no top level null codes
  if (error.code === 'null') {
    error.code = String(statusCode)
  }

  return { error, statusCode }
}

const _ensureSeverity = arg => {
  if (typeof arg === 'number' && arg >= MIN_SEVERITY && arg <= MAX_SEVERITY) {
    return arg
  }

  return DEFAULT_SEVERITY
}

const _normalizeMessage = (message, locale) => {
  const normalized = _normalize(message, locale)

  // numericSeverity without @Common
  normalized.numericSeverity = _ensureSeverity(message.numericSeverity)
  delete normalized['@Common.numericSeverity']

  ADDITIONAL_MSG_PROPERTIES.forEach(k => {
    if (message[k] && typeof message[k] === 'string') {
      normalized[k] = message[k]
    }
  })

  return normalized
}

const getSapMessages = (messages, req) => {
  const locale = req.locale || (req.locale = localeFrom(req))
  const s = JSON.stringify(messages.map(message => _normalizeMessage(message, locale)))
  // convert non ascii to unicode
  return s.replace(/[\u007F-\uFFFF]/g, chr => {
    return '\\u' + ('0000' + chr.charCodeAt(0).toString(16)).substr(-4)
  })
}

const isClientError = e => {
  // e.code may be undefined, string, number, ... -> NaN -> not a client error
  const numericCode = e.statusCode || Number(e.code)
  return numericCode >= 400 && numericCode < 500
}

module.exports = {
  normalizeError,
  getSapMessages,
  isClientError
}
