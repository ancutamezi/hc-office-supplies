const _flattenProps = (subElement, structName, structProperties, structElement, asRef, withKey) => {
  if (subElement.elements) {
    return _resolveStructured(
      {
        structName: `${structName}_${subElement.name}`,
        structProperties: structProperties.slice(1)
      },
      subElement.elements,
      asRef,
      withKey
    )
  } else if (subElement.isAssociation) {
    if (structProperties.length && subElement.is2one && !subElement.on) {
      const flattenedName = `${structName}_${structProperties.join('_')}`
      if (withKey) {
        return [{ key: structElement, resolved: [flattenedName] }]
      }

      return asRef ? [{ ref: [flattenedName] }] : [flattenedName]
    }

    return []
  }
  const flattenedName = `${structName}_${structElement}`
  if (withKey) {
    return [{ key: structElement, resolved: [flattenedName] }]
  }

  return asRef ? [{ ref: [flattenedName] }] : [flattenedName]
}

const _resolveStructured = ({ structName, structProperties }, subElements, asRef = true, withKey = false) => {
  if (!subElements) {
    return []
  }

  // only add from structProperties
  if (structProperties.length) {
    return _flattenProps(
      subElements[structProperties[0]],
      structName,
      structProperties,
      structProperties[0],
      asRef,
      withKey
    )
  }

  const flattenedElements = []
  for (const structElement in subElements) {
    flattenedElements.push(
      ..._flattenProps(subElements[structElement], structName, structProperties, structElement, asRef, withKey)
    )
  }
  return flattenedElements
}

module.exports = _resolveStructured
