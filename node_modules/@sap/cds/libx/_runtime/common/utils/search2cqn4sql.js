const { computeColumnsToBeSearched } = require('../../../../libx/_runtime/cds-services/services/utils/columns')
const searchToLike = require('./searchToLike')
const { ensureNoDraftsSuffix } = require('./draft')
const { getEntityNameFromCQN } = require('./entityFromCqn')

const _targetFrom = (cqn, options) => {
  if (options && options.entityName) return options
  return getEntityNameFromCQN(cqn)
}

const _search2cqn4sql = (query, model, options = {}) => {
  const cqnSearchPhrase = query.SELECT.search
  if (!cqnSearchPhrase) return
  const { search2cqn4sql } = options
  const { entityName, alias } = _targetFrom(query.SELECT.from, options)
  const entity = model.definitions[ensureNoDraftsSuffix(entityName)]
  const columns = computeColumnsToBeSearched(query, entity, alias)

  // Call custom (optimized search to cqn for sql implementation) that tries
  // to optimize the search behavior for a specific database service.
  // REVISIT: $search query option combined with $count is not currently optimized
  if (typeof search2cqn4sql === 'function' && !query.SELECT.count) {
    const search2cqnOptions = { columns, locale: options.locale }
    return search2cqn4sql(query, entity, search2cqnOptions)
  }

  const expression = searchToLike(cqnSearchPhrase, columns)

  // REVISIT: find out here if where or having must be used
  query._aggregated || /* if new parser */ query.SELECT.groupBy ? query.having(expression) : query.where(expression)
}

const search2cqn4sql = (query, model, options) => {
  if (query.SELECT.from.SET) {
    return query.SELECT.from.SET.args.forEach(arg => _search2cqn4sql(arg, model, options))
  }

  return _search2cqn4sql(query, model, options)
}

// convert $search system query option to WHERE/HAVING clause using
// the operator LIKE or CONTAINS
module.exports = search2cqn4sql
