const DELIMITER = require('./templateDelimiter')

const _formatRowContext = (tKey, keyNames, row) => {
  const keyValuePairs = keyNames.map(key => `${key}=${row[key]}`)
  const keyValuePairsSerialized = keyValuePairs.join(',')
  return `${tKey}(${keyValuePairsSerialized})`
}

const _processElement = (processFn, row, key, target, picked = {}, isRoot, path) => {
  const element = (target.elements || target.params)[key]
  const { plain } = picked

  if (!plain) return
  /**
   * @type import('../../types/api').templateProcessorProcessFnArgs
   */
  const elementInfo = { row, key, element, target, plain, isRoot, path }
  if (!element && target._flat2struct && target._flat2struct[key]) {
    elementInfo.path = path.slice(0)
    elementInfo.path.push(...target._flat2struct[key].map(key => ({ key })))
  }
  processFn(elementInfo)
}

const _processRow = (processFn, row, template, tKey, tValue, isRoot, pathOptions) => {
  const { template: subTemplate, picked } = tValue
  const key = tKey.split(DELIMITER).pop()

  _processElement(processFn, row, key, template.target, picked, isRoot, pathOptions.path)

  // process deep
  if (subTemplate && typeof row === 'object' && row) {
    _processComplex(processFn, row, subTemplate, key, pathOptions)
  }
}

const _processComplex = (processFn, row, template, key, pathOptions) => {
  const value = row && row[key]
  const _is2many = Array.isArray(value)
  const rows = _is2many ? value : [value]
  if (rows.length === 0) return
  const keyNames = (template.target.keys && Object.keys(template.target.keys)) || []

  for (let idx = 0; idx < rows.length; idx++) {
    const row = rows[idx]
    if (row == null) continue
    const args = { processFn, row, template, isRoot: false, pathOptions }

    let url
    if (pathOptions.includeKeyValues) {
      if (pathOptions.rowKeysGenerator) pathOptions.rowKeysGenerator(keyNames, row, template)
      url = _formatRowContext(key, keyNames, Object.assign({}, row, pathOptions.extraKeys))
    }

    if (pathOptions.path) pathOptions.path.push({ key, idx: _is2many && idx, url })

    templateProcessor(args)

    if (pathOptions.path) pathOptions.path.pop()
  }
}

/**
 * @param {import("../../types/api").TemplateProcessor} args
 */
const templateProcessor = ({ processFn, row, template, isRoot = true, pathOptions = {} }) => {
  for (const [tKey, tValue] of template.elements) {
    _processRow(processFn, row, template, tKey, tValue, isRoot, pathOptions)
  }
}

module.exports = templateProcessor
