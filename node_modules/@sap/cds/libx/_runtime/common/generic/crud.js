const cds = require('../../cds')
const { SELECT } = cds.ql

const getTemplate = require('../utils/template')
const templateProcessor = require('../utils/templateProcessor')
const replaceManagedData = require('../utils/dollar')
const { deepCopyArray } = require('../utils/copy')

const onlyKeysRemain = require('../utils/onlyKeysRemain')
const { getColumns } = require('../../cds-services/services/utils/columns')

const _targetEntityDoesNotExist = async req => {
  const { query } = req
  const cqn = SELECT.from(query.UPDATE.entity, [1])

  if (query.UPDATE.entity.as) {
    cqn.SELECT.from.as = query.UPDATE.entity.as
  }

  // REVISIT: compat mode for service functions .update
  if (query.UPDATE && query.UPDATE.where) {
    cqn.where(query.UPDATE.where)
  }

  const exists = await cds.tx(req).run(cqn)
  return exists.length === 0
}

const _processorFn = req => {
  const { event, user, timestamp } = req
  const ts = new Date(timestamp).toISOString()

  return ({ row, key, plain, isRoot }) => {
    for (const category of plain.categories) {
      if (event === 'CREATE' && category === '@cds.on.insert') {
        replaceManagedData(row, key, user, ts)
      } else if (category === '@cds.on.update') {
        if (isRoot) replaceManagedData(row, key, user, ts)
        else if (row[key] === '$user' || row[key] === '$now') delete row[key]
      }
    }
  }
}

// params: element, target, parent, templateElements
const _pick = element => {
  // collect actions to apply
  const categories = []

  if (element['@cds.on.insert']) categories.push('@cds.on.insert')
  if (element['@cds.on.update']) categories.push('@cds.on.update')

  if (categories.length) return { categories }
}

const _updateReqData = (req, that) => {
  const template = getTemplate('app-output', that, req.target, { pick: _pick })

  if (template.elements.size > 0) {
    const arrayData = Array.isArray(req.data) ? req.data : [req.data]
    for (const row of arrayData) {
      const args = {
        processFn: _processorFn(req),
        row,
        template
      }
      templateProcessor(args)
    }
  }
}

module.exports = cds.service.impl(function () {
  // eslint-disable-next-line complexity
  this.on(['CREATE', 'READ', 'UPDATE', 'DELETE'], '*', async function (req) {
    if (typeof req.query !== 'string' && req.target && req.target._hasPersistenceSkip) {
      req.reject(501, 'PERSISTENCE_SKIP_NO_GENERIC_CRUD', [req.target.name])
    }

    // REVISIT: error message
    if (!cds.db) req.reject(501, 'NO_DATABASE_CONNECTION')

    let result

    // validate that all elements in path exist on db, if necessary
    // - INSERT has no where clause to do this in one roundtrip
    // - SELECT returns [] -> really empty collection or invalid path?
    let pathExistsQuery
    const { ref } = (req.query.INSERT && req.query.INSERT.into) || (req.query.SELECT && req.query.SELECT.from) || {}
    // REVISIT: why is copy necessary?
    if (ref && ref.length > 1) pathExistsQuery = SELECT(1).from({ ref: deepCopyArray(ref.slice(0, -1)) })

    if (req.event === 'CREATE' && pathExistsQuery) {
      const res = await pathExistsQuery
      if (res.length === 0) req.reject(404)
    }

    // REVISIT: remove block with cds^6 (i.e., update_managed_properties is always true)
    // no changes, no op (otherwise, @cds.on.update gets new values), but we need to check existence
    if (cds.env.features.update_managed_properties === false && req.event === 'UPDATE' && onlyKeysRemain(req)) {
      if (await _targetEntityDoesNotExist(req)) req.reject(404)
      result = req.data
    }

    if (req.event in { DELETE: 1, UPDATE: 1 } && req.target && req.target._isSingleton) {
      if (req.event === 'DELETE' && !req.target['@odata.singleton.nullable']) req.reject(400, 'SINGLETON_NOT_NULLABLE')
      const keyColumns = getColumns(req.target, { onlyNames: true, keysOnly: true })
      const selectSingleton = SELECT.one(req.target).columns(keyColumns)
      const singleton = await cds.tx(req).run(selectSingleton)
      if (!singleton) req.reject(404)
      req.query.where(singleton)
    }

    if (!result) {
      result = await cds.tx(req).run(req.query, req.data)
    }

    if (req.event === 'READ') {
      if ((result == null || result.length === 0) && pathExistsQuery) {
        const res = await pathExistsQuery
        if (res.length === 0) req.reject(404)
      }
      return result
    }

    if (req.event === 'DELETE') {
      if (result === 0) req.reject(404)
      return result
    }

    // case: no authorization check and payload more than just keys but no changes
    // -> affected rows === 0 -> no change or not exists?
    if (req.event === 'UPDATE' && result === 0 && !req._authChecked) {
      if (await _targetEntityDoesNotExist(req)) req.reject(404)
    }

    // flag to trigger read after write in protocol adapter
    req._.readAfterWrite = true

    // update req.data
    _updateReqData(req, this)

    return req.data
  })
})
