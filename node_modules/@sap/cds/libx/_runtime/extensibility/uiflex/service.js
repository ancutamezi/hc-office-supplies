const fs = require('fs')
const path = require('path')
const cds = require('../../cds')
const { ensureDraftsSuffix } = require('../../common/utils/draft')
const { BASE_TENANT, channelName } = require('../../common/utils/extensibilityUtils')
const { EXT_BACK_PACK } = require('./utils')
const TMP_DIR = fs.realpathSync(require('os').tmpdir())

const _getDraftTable = view => {
  return cds.model.definitions[view]._isDraftEnabled ? ensureDraftsSuffix(view) : undefined
}

const _addAnnotation = extension => {
  Object.values(extension.elements).forEach(el => {
    el['@cds.extension'] = true
  })
}

const _isProjection = target => target && target.query && target.query._target

const _resolveViews = (target, views_ = []) => {
  if (_isProjection(target)) {
    views_.push(target)
    return _resolveViews(target.query._target, views_)
  }

  return target
}

const _getCsn = req => {
  const csn = {
    extensions: req.data.extensions.map(ext => JSON.parse(ext))
  }

  return csn
}

const _addViews = csn => {
  csn.extensions.forEach(extension => {
    const target = cds.model.definitions[extension.extend]
    const views_ = []
    const view = _resolveViews(target, views_)
    extension.extend = view && view.name
    _addAnnotation(extension)

    // All projection views leading to the db entity are extended with back pack in case view columns are explicitly listed.
    // The views using projections with '*' obtain the back pack automatically.
    views_.forEach(view => {
      if (!view.projection || (view.projection.columns && !view.projection.columns.some(col => col === '*'))) {
        csn.extensions.push({
          extend: view.name,
          columns: Object.keys(extension.elements).map(key => {
            return { ref: [key] }
          })
        })
      }
    })
  })
}

const _needsQuotations = t => t instanceof cds.builtin.classes.string || t instanceof cds.builtin.classes.date

const _handleDefaults = async (extension, dbEntity, draftEntity) => {
  const ext = Object.keys(extension.elements)
    .filter(key => extension.elements[key].default)
    .map(key => {
      const element = extension.elements[key]
      // .type as ui flex extensions are not linked
      const t = cds.model.definitions[element.type] || cds.builtin.types[element.type]
      const value = t && _needsQuotations(t) ? `"${element.default.val}"` : element.default.val
      return `"${key}":${value}`
    })

  if (ext.length !== 0) {
    const extStr = ext.join(',')
    const changed = `'{${extStr},' || substr(${EXT_BACK_PACK}, 2, length(${EXT_BACK_PACK})-1)`
    const assign = `${EXT_BACK_PACK} = CASE WHEN ${EXT_BACK_PACK} IS NULL THEN '{${extStr}}' ELSE ${changed} END`
    await UPDATE(dbEntity).with(assign)
    if (draftEntity) await UPDATE(draftEntity).with(assign)
  }
}

const _validateCsn = (csn, req) => {
  if (!csn) req.reject(400, 'Missing extension')
  if (!csn.extensions) return

  csn.extensions.forEach(extension => {
    if (!extension.extend || !cds.model.definitions[extension.extend]) {
      req.reject(400, 'Invalid extension. Parameter "extend" missing or malformed')
    }

    if (!extension.elements) {
      req.reject(400, 'Invalid extension. Missing parameter "elements"')
    }
  })
}

const _validateExtensionFields = (csn, req) => {
  if (!csn.extensions) return

  csn.extensions.forEach(extension => {
    if (extension.elements) {
      Object.keys(extension.elements).forEach(name => {
        if (!/^[A-Za-z]\w*$/.test(name)) {
          req.reject(400, `Invalid extension. Bad element name "${name}"`)
        }

        if (Object.keys(cds.model.definitions[extension.extend].elements).includes(name)) {
          req.reject(400, `Invalid extension. Element "${name}" already exists`)
        }
      })
    }
  })
}

const _getCompilerError = messages => {
  const defaultMsg = 'Error while compiling extension'
  if (!messages) return defaultMsg

  for (const msg of messages) {
    if (msg.severity === 'Error') return msg.message
  }

  return defaultMsg
}

const _validateExtension = async (ext, req) => {
  try {
    const { 'cds_r.ModelProviderService': mps } = cds.services
    const csn = await mps.getCsn(req.tenant, ['*'])
    const extCsn = cds.compile.to.json(ext)
    await cds.compile.to.csn({ 'base.csn': JSON.stringify(csn), 'ext.csn': extCsn })
  } catch (err) {
    console.trace(err) // eslint-disable-line no-console
    req.reject(400, _getCompilerError(err.messages))
  }
}

const _addExtension = async function (req) {
  // validate extension
  const csn = _getCsn(req)
  _validateCsn(csn, req)
  await _validateExtensionFields(csn, req)
  _addViews(csn, cds)
  await _validateExtension(csn, req)

  // save extension
  const ID = cds.utils.uuid()
  await INSERT.into('cds_r.Extensions').entries([{ ID, csn: JSON.stringify(csn), activated: false }])

  // defaults
  for (const ext of req.data.extensions) {
    const extension = JSON.parse(ext)
    const draft = _getDraftTable(extension.extend)
    const target = cds.model.definitions[extension.extend]
    const dbEntity = _resolveViews(target).name
    await _handleDefaults(extension, dbEntity, draft)
  }

  // update event
  await this.redis.emit(channelName(), { tenant: req.tenant || BASE_TENANT })
}

const _activate = async function (req) {
  // get extensions
  const rs = await cds.tx({ tenant: req.tenant }, tx => tx.run(SELECT.from('cds_r.Extensions')))
  rs.forEach(row => {
    row.csn = row.csn.replace(/,"@cds.extension":true/g, '')
    row.activated = true
  })

  // activate
  const { MultitenancyService: mts } = cds.services
  await mts.activateExtensions(req.data.tenant)

  // restore extensions
  await INSERT.into('cds_r.Extensions').entries(rs)

  // update event
  await this.redis.emit(channelName(), { tenant: req.tenant || BASE_TENANT })
}

const _exists = async fileOrDir => {
  try {
    return await fs.promises.stat(fileOrDir)
  } catch (_) {
    return false
  }
}

const _compileProject = async function (extension, req) {
  let csn, root
  try {
    root = await fs.promises.mkdtemp(`${TMP_DIR}${path.sep}extension-`)
    const files = []
    for (const ext of extension) {
      if (ext.filename.indexOf('/') > -1) {
        await fs.promises.mkdir(path.join(root, path.dirname(ext.filename)), { recursive: true })
      }
      const file = path.join(root, ext.filename)
      await fs.promises.writeFile(file, ext.model)
      files.push(file)
    }
    csn = await cds.compile(files, { flavor: 'parsed' })
    if (csn.requires) delete csn.requires
  } catch (err) {
    // req.reject(400, _getCompilerError(err.messages))
    if (err.messages) req.reject(400, _getCompilerError(err.messages))
    else {
      // eslint-disable-next-line no-console
      console.error(err)
      throw err
    }
  } finally {
    if (await _exists(root)) {
      await (fs.promises.rm || fs.promises.rmdir)(root, { recursive: true, force: true })
    }
  }

  return csn
}

const _activateProject = async function (req) {
  if (req.data.extension.length === 0) return

  const csn = await _compileProject(req.data.extension, req)
  await _validateExtension(csn, req)

  // keep only extension to be activated
  const ID = cds.utils.uuid()
  let activated, notActivated
  await cds.tx({ tenant: req.tenant }, async tx => {
    activated = await tx.run(SELECT.from('cds_r.Extensions').where({ activated: true }))
    notActivated = await tx.run(SELECT.from('cds_r.Extensions').where({ activated: false }))
    await tx.run(DELETE.from('cds_r.Extensions').where({ activated: false }))
    await tx.run(INSERT.into('cds_r.Extensions').entries([{ ID, csn: JSON.stringify(csn), activated: false }]))
  })

  // activate
  const { MultitenancyService: mts } = cds.services
  await mts.activateExtensions(req.data.tenant)

  // restore extensions
  await cds.tx({ tenant: req.tenant }, async tx => {
    const inserted = await tx.run(SELECT.from('cds_r.Extensions').where({ ID }))
    if (!inserted.length) {
      if (activated.length !== 0) await tx.run(INSERT.into('cds_r.Extensions').entries(activated))
      await tx.run(INSERT.into('cds_r.Extensions').entries([{ ID, csn: JSON.stringify(csn), activated: true }]))
    }
    if (notActivated.length !== 0) await tx.run(INSERT.into('cds_r.Extensions').entries(notActivated))
  })

  // default values for not activated extensions
  for (const na of notActivated) {
    for (const extension of JSON.parse(na.csn).extensions) {
      const target = cds.model.definitions[extension.extend]
      const dbEntity = _resolveViews(target).name

      // only db entities
      if (target.name !== dbEntity) continue

      const draft = _getDraftTable(extension.extend)
      await _handleDefaults(extension, dbEntity, draft)
    }
  }

  // update event
  await this.redis.emit(channelName(), { tenant: req.tenant || BASE_TENANT })
}

module.exports = async function () {
  this.redis = await cds.connect.to('mtx-messaging')
  this.on('addExtension', _addExtension)
  this.on('activate', _activate)
  this.on('activateProject', _activateProject)
}
