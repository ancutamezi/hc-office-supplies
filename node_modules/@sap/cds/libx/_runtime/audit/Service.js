const cds = require('../cds')
const OutboxService = require('../messaging/Outbox')

const v2utils = require('./utils/v2')

const ANONYMOUS = 'anonymous'

const _getTenantAndUser = () => ({
  user: (cds.context && cds.context.user && cds.context.user.id) || ANONYMOUS,
  tenant: (cds.context && cds.context.tenant) || ANONYMOUS
})

module.exports = class AuditLogService extends OutboxService {
  async init() {
    // call OutboxService's init, which handles outboxing
    await super.init()

    // connect to audit log service
    this.alc = await v2utils.connect(this.options.credentials)

    // register handlers, if connected
    if (this.alc) {
      this.on('dataAccessLog', this._dataAccessLog)
      this.on('dataModificationLog', this._dataModificationLog)
      this.on('securityLog', this._securityLog)
      this.on('configChangeLog', this._configChangeLog)
    }
  }

  async emit(first, second) {
    const { event, data } = typeof first === 'object' ? first : { event: first, data: second }
    if (!this.options.outbox) return this.send(event, data)

    if (this[event]) {
      try {
        // this will open a new tx -> preserve user
        await super.send(new cds.Request({ method: event, data, user: cds.context.user }))
      } catch (e) {
        if (e.code === 'ERR_ASSERTION') {
          e.unrecoverable = true
        }
        throw e
      }
    }
  }

  async send(event, data) {
    if (this[event]) return super.send(event, data)
  }

  /*
   * api (await AuditLogService.<event>(data))
   */

  async dataAccessLog(data) {
    return super.send('dataAccessLog', data)
  }

  async dataModificationLog(data) {
    return super.send('dataModificationLog', data)
  }

  async securityLog(data) {
    return super.send('securityLog', data)
  }

  async configChangeLog(data) {
    return super.send('configChangeLog', data)
  }

  /*
   * impl
   */

  async _dataAccessLog({ data: { accesses } }) {
    const { tenant, user } = _getTenantAndUser()

    // build the logs
    const { entries, errors } = v2utils.buildDataAccessLogs(this.alc, accesses, tenant, user)
    if (errors.length) {
      throw errors.length === 1 ? errors[0] : Object.assign(new Error('MULTIPLE_ERRORS'), { details: errors })
    }

    // write the logs
    await Promise.all(
      entries.map(entry => {
        v2utils.sendDataAccessLog(entry).catch(err => errors.push(err))
      })
    )
    if (errors.length) {
      throw errors.length === 1 ? errors[0] : Object.assign(new Error('MULTIPLE_ERRORS'), { details: errors })
    }
  }

  // REVISIT: modification.action not used in auditlog v2
  async _dataModificationLog({ data: { modifications } }) {
    const { tenant, user } = _getTenantAndUser()

    // build the logs
    const { entries, errors } = v2utils.buildDataModificationLogs(this.alc, modifications, tenant, user)
    if (errors.length) {
      throw errors.length === 1 ? errors[0] : Object.assign(new Error('MULTIPLE_ERRORS'), { details: errors })
    }

    // write the logs
    await Promise.all(
      entries.map(entry => {
        v2utils.sendDataModificationLog(entry).catch(err => errors.push(err))
      })
    )
    if (errors.length) {
      throw errors.length === 1 ? errors[0] : Object.assign(new Error('MULTIPLE_ERRORS'), { details: errors })
    }
  }

  async _securityLog({ data: { action, data } }) {
    let { tenant, user } = _getTenantAndUser()

    // cds.context may not be proper on auth-related errors -> try to extract from data
    if (tenant === ANONYMOUS && user === ANONYMOUS) {
      try {
        const parsed = JSON.parse(data)
        if (parsed.tenant) {
          tenant = parsed.tenant
          delete parsed.tenant
        }
        if (parsed.user && typeof parsed.user === 'string') {
          user = parsed.user
          delete parsed.user
        }
        data = JSON.stringify(parsed)
      } catch (e) {}
    }

    // build the log
    const entry = v2utils.buildSecurityLog(this.alc, action, data, tenant, user)

    // write the log
    await v2utils.sendSecurityLog(entry)
  }

  // REVISIT: action and success not used in auditlog v2
  async _configChangeLog({ data: { action, success, configurations } }) {
    const { tenant, user } = _getTenantAndUser()

    // build the logs
    const { entries, errors } = v2utils.buildConfigChangeLogs(this.alc, configurations, tenant, user)
    if (errors.length) {
      throw errors.length === 1 ? errors[0] : Object.assign(new Error('MULTIPLE_ERRORS'), { details: errors })
    }

    // write the logs
    await Promise.all(
      entries.map(entry => {
        v2utils.sendConfigChangeLog(entry).catch(err => errors.push(err))
      })
    )
    if (errors.length) {
      throw errors.length === 1 ? errors[0] : Object.assign(new Error('MULTIPLE_ERRORS'), { details: errors })
    }
  }
}
