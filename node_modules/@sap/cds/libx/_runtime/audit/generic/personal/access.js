const cds = require('../../../cds')

const getTemplate = require('../../../common/utils/template')
const templateProcessor = require('../../../common/utils/templateProcessor')

const {
  getRootEntity,
  getPick,
  createLogEntry,
  addObjectID,
  addDataSubject,
  addDataSubjectForDetailsEntity,
  resolveDataSubjectPromises
} = require('./utils')

let auditLogService

const _processorFnAccess = (accessLogs, model, req) => {
  return ({ row, key, element, plain }) => {
    if (row.IsActiveEntity === false) return

    const entity = getRootEntity(element)

    // create or augment log entry
    const accessLog = createLogEntry(accessLogs, entity, row)

    // process categories
    for (const category of plain.categories) {
      if (category === 'ObjectID') {
        addObjectID(accessLog, row, key)
      } else if (category === 'DataSubjectID') {
        addDataSubject(accessLog, row, key, entity)
      } else if (category === 'IsPotentiallySensitive' && key in row) {
        // add attribute
        if (!accessLog.attributes.find(ele => ele.name === key)) accessLog.attributes.push({ name: key })
        // REVISIT: attribute vs. attachment?
      }
    }

    // add promise to determine data subject if a DataSubjectDetails entity
    if (
      (entity['@PersonalData.EntitySemantics'] === 'DataSubjectDetails' ||
        entity['@PersonalData.EntitySemantics'] === 'Other') &&
      accessLog.dataSubject.id.length === 0 // > id still an array -> promise not yet set
    ) {
      addDataSubjectForDetailsEntity(row, accessLog, req, entity, model)
    }
  }
}

const _getDataAccessLogs = (data, req, tx) => {
  const template = getTemplate(
    'personal_read',
    Object.assign({ name: req.target._service.name, model: tx.model }),
    req.target,
    { pick: getPick('READ') }
  )

  const accessLogs = {}

  if (typeof data === 'object' && data !== null) {
    const processFn = _processorFnAccess(accessLogs, tx.model, req)
    const data_ = Array.isArray(data) ? data : [data]
    data_.forEach(row => {
      templateProcessor({ processFn, row, template })
    })
  }

  return accessLogs
}

const auditAccessHandler = async function (data, req) {
  auditLogService = auditLogService || (await cds.connect.to('audit-log'))

  const accessLogs = _getDataAccessLogs(data, req, this)
  // REVISIT: a function called resolveDataSubjectPromises should not also convert an object to an array
  let accesses = await resolveDataSubjectPromises(accessLogs)
  accesses = accesses.filter(ele => ele.attributes.length)

  if (accesses.length) await auditLogService.emit('dataAccessLog', { accesses })
}

module.exports = {
  auditAccessHandler
}
