const cds = require('../../cds')
const waitingTime = require('../common-utils/waitingTime')
const OutboxRunner = require('./OutboxRunner')
const { isStandardError } = require('../../common/error/standardError')
const LOG = cds.log('persistent-outbox')
const _safeJSONParse = string => {
  try {
    return string && JSON.parse(string)
  } catch (e) {}
}

const outboxRunner = new OutboxRunner()
const cdsUser = 'cds.internal.user'
const messageProcessorRegistered = Symbol('message processor registered')

const _getMessagesEntity = () => {
  const messagesDbName = 'cds.outbox.Messages'
  const messagesEntity = cds.model.definitions[messagesDbName]
  if (!messagesEntity)
    throw new Error(`The entity '${messagesDbName}' is missing but needed for the persistent outbox.`)
  return messagesEntity
}

// REVISIT: Is this always a reliable way to identify the provider tenant?
//          Are there scenarios where the credentials have a different format?
const _isProviderTenant = tenant =>
  cds.requires.auth && cds.requires.auth.credentials && cds.requires.auth.credentials.identityzoneid === tenant

const hasPersistentOutbox = (srv, tenant) => {
  if (!cds.requires.outbox || cds.requires.outbox.kind !== 'persistent-outbox') return false
  if (srv.options && srv.options.outbox && srv.options.outbox.kind && srv.options.outbox.kind !== 'persistent-outbox')
    return false
  if (cds._mtxEnabled && tenant && _isProviderTenant(tenant)) return false // no persistence for provider account
  return true
}

const isUnrecoverable = (service, error) => {
  let unrecoverable = service.isUnrecoverableError && service.isUnrecoverableError(error)
  if (unrecoverable === undefined) unrecoverable = error.unrecoverable
  return unrecoverable || isStandardError(error)
}

const _processSingleMessage = async (service, message, succeededMessages) => {
  const msg = _safeJSONParse(message.msg)
  const userId = msg[cdsUser]
  delete msg[cdsUser]
  if (!msg) return message.ID
  // Promise resolve is necessary because we want to set `cds.context` only
  // inside this call
  return Promise.resolve().then(async () => {
    if (userId) cds.context.user = new cds.User.Privileged(userId)
    try {
      service._emitImmediate && (await service._emitImmediate(msg))
      succeededMessages.push(message.ID)
    } catch (e) {
      const failedMessage = {
        event: msg.event,
        ID: message.ID,
        attempts: message.attempts,
        error: e,
        unrecoverable: isUnrecoverable(service, e)
      }
      throw Object.assign(new Error('processing failed'), { failedMessage })
    }
  })
}

// Note: This function can also run for each tenant on startup
const processMessages = async (service, tenant, _opts = {}) => {
  const opts = Object.assign({ attempt: 0 }, _opts)
  const name = service.name
  const messagesEntity = _getMessagesEntity()

  outboxRunner.run({ name, tenant }, () => {
    let letAppCrash = false
    const config = tenant ? { tenant, user: new cds.User.Privileged() } : { user: new cds.User.Privileged() }
    const spawn = cds.spawn(async () => {
      let messages
      try {
        const messagesQuery = SELECT.from(messagesEntity)
          .where({ target: name })
          .orderBy('timestamp')
          .limit(opts.chunkSize)
          .forUpdate()
        if (opts.maxAttempts) messagesQuery.where({ attempts: { '<': opts.maxAttempts } })
        messages = await messagesQuery
      } catch (e) {
        // could potentially be a timeout
        const _waitingTime = waitingTime(opts.attempt)
        LOG.error(
          'Outbox SELECT FOR UPDATE failed',
          opts.attempt > 0
            ? ''
            : {
                cause: e
              },
          `Retrying in ${Math.round(_waitingTime / 1000)} s`
        )
        outboxRunner.schedule(
          {
            name,
            tenant,
            waitingTime: _waitingTime
          },
          () => processMessages(service, tenant, { ...opts, attempt: opts.attempt + 1 })
        )
        return
      }
      const messagesToBeDeleted = []
      let error
      for (const m of messages) {
        try {
          await _processSingleMessage(service, m, messagesToBeDeleted)
        } catch (e) {
          error = e
          break
        }
      }
      if (error && error.failedMessage.unrecoverable) {
        // opts.crashOnError is not official!!!
        if (opts.crashOnError !== false) letAppCrash = true
        messagesToBeDeleted.push(error.failedMessage.ID)
      }
      if (messagesToBeDeleted.length) await DELETE.from(messagesEntity).where('ID in', messagesToBeDeleted)
      if (error) {
        if (!error.failedMessage.unrecoverable) {
          const _waitingTime = waitingTime(error.failedMessage.attempts)
          const info = { service: name, event: error.failedMessage.event }
          if (error.failedMessage.attempts > 0) info.cause = error.failedMessage.error
          LOG.error('Emit failed', info, `Retrying in ${Math.round(_waitingTime / 1000)} s`)
          await UPDATE(messagesEntity)
            .where({ ID: error.failedMessage.ID })
            .set({ attempts: { '+=': 1 } })
          outboxRunner.schedule(
            {
              name,
              tenant,
              waitingTime: _waitingTime
            },
            () => processMessages(service, tenant, opts)
          )
        } else {
          LOG.error(
            'Emit failed',
            { service: name, event: error.failedMessage.event, cause: error.failedMessage.error },
            'Unrecoverable, outbox entry deleted'
          )
        }
      } else {
        outboxRunner.success({ name, tenant })
        if (messages.length === opts.chunkSize) {
          processMessages(service, tenant, opts) // We only processed max. opts.chunkSize, so there might be more
        } else {
          LOG._trace && LOG.trace(`All persistent-outbox messages processed for service '${service.name}'`)
        }
      }
    }, config)
    spawn.on('done', () => {
      if (letAppCrash) process.exit(1)
      outboxRunner.end({ name, tenant }, () => processMessages(service, tenant, opts))
    })
  })
}

const registerMessageProcessor = (name, context) => {
  const registry = context[messageProcessorRegistered] || (context[messageProcessorRegistered] = new Set())
  if (!registry.has(name)) {
    registry.add(name)
    return true
  }
  return false
}

const _createMessage = (name, msg, context) => {
  const _msg = { ...msg, [cdsUser]: context.user.id }
  const outboxMsg = {
    ID: cds.utils.uuid(),
    target: name,
    timestamp: new Date().toISOString(), // needs to be different for each emit
    msg: JSON.stringify(_msg)
  }
  return outboxMsg
}

const writeInOutbox = async (name, msg, context) => {
  const outboxMsg = _createMessage(name, msg, context)
  const messagesEntity = _getMessagesEntity()
  return INSERT.into(messagesEntity).entries(outboxMsg)
}

module.exports = { processMessages, registerMessageProcessor, writeInOutbox, hasPersistentOutbox, isUnrecoverable }
