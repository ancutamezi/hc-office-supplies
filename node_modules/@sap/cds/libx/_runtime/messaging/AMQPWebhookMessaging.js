const cds = require('../cds')
const MessagingService = require('./service.js')
const { queueName } = require('./common-utils/naming-conventions')
const optionsApp = require('../common/utils/vcap.js')
const normalizeIncomingMessage = require('./common-utils/normalizeIncomingMessage')

class AMQPWebhookMessaging extends MessagingService {
  async init() {
    this.optionsApp = optionsApp
    if (this.options.queue) {
      const queueConfig = { ...this.options.queue }
      delete queueConfig.name
      if (Object.keys(queueConfig).length) this.queueConfig = queueConfig
    }
    this.queueName = queueName(this.options, this.optionsApp)

    cds.once('listening', () => {
      this.startListening()
    })

    return super.init()
  }

  async emit(msg) {
    const _msg = this.message4(msg)
    const client = this.getClient()
    await this.queued(() => {})()
    return client.emit(_msg)
  }

  startListening(opt = {}) {
    if (this.subscribedTopics.size) {
      const management = this.getManagement()
      if (!opt.doNotDeploy) this.queued(management.createQueueAndSubscriptions.bind(management))()
      this.queued(this.listenToClient.bind(this))(async (_topic, _payload, _other, { done, failed }) => {
        const msg = Object.assign(normalizeIncomingMessage(_payload), _other || {})
        msg.event = _topic

        if (!msg._) msg._ = {}
        msg._.topic = _topic
        try {
          await super.emit(msg)
          done()
        } catch (e) {
          // In case of AMQP and Solace, the `failed` callback must be called
          // with an error, otherwise there are problems with the redelivery count.
          failed(new Error('processing failed'))
          this.LOG.error('ERROR occured in asynchronous event processing:', e)
        }
      })
    }
  }

  listenToClient(cb) {
    return this.getClient().listen(cb)
  }
}

module.exports = AMQPWebhookMessaging
