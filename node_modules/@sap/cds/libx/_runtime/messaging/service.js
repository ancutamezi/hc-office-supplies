const cds = require('../cds')
const queued = require('./common-utils/queued')
const OutboxService = require('./Outbox')

const _topic = declared => declared['@topic'] || declared.name

let usedTopicOnce = false
const _warnAndStripTopicPrefix = (event, LOG) => {
  if (event.startsWith('topic:')) {
    // backwards compatibility
    event = event.replace(/topic:/, '')
    if (!usedTopicOnce) {
      LOG._warn && LOG.warn('The topic prefix `topic:` is deprecated and has no effect. Please remove it.')
    }
    usedTopicOnce = true
  }
  return event
}

// There's currently no mechanism to detect mocked services, this is the best we can do.
class MessagingService extends OutboxService {
  init() {
    // enables queued async operations (without awaiting)
    this.queued = queued()
    this.subscribedTopics = new Map()
    this.LOG = cds.log(this.kind ? `${this.kind}|messaging` : 'messaging')
    // Only for one central `messaging` service, otherwise all technical services would register themselves
    if (this.name === 'messaging') {
      this._registeredServices = new Map()
      // listen for all subscriptions to declared events of remote, i.e. connected services
      cds.on('subscribe', (srv, event) => {
        const declared = srv.events[event]
        if (declared && srv.name in cds.requires && !srv.mocked) {
          // we register self-handlers for declared events, which are supposed
          // to be calles by subclasses calling this.dispatch on incoming events
          let registeredEvents = this._registeredServices.get(srv.name)
          if (!registeredEvents) {
            registeredEvents = new Set()
            this._registeredServices.set(srv.name, registeredEvents)
          }
          if (registeredEvents.has(event)) return
          registeredEvents.add(event)
          const topic = _topic(declared)
          this.on(topic, msg => {
            const { data, headers } = msg
            return srv.tx(msg).emit({ event, data, headers, __proto__: msg })
          })
        }
      })

      // forward all emits for all declared events of local, i.e. served services
      cds.on('serving', srv => {
        for (const declared of srv.events) {
          const event = declared.name.slice(srv.name.length + 1)
          // calls to srv.emit are forwarded to this.emit, which is expected to
          // be overwritten by subclasses to write events to message channel
          const topic = _topic(declared)
          srv.on(event, msg => {
            const { data, headers } = msg
            return this.tx(msg).emit({ event: topic, data, headers })
          })
        }
      })
    }

    const { on } = this
    this.on = function (...args) {
      if (Array.isArray(args[0])) {
        const [topics, ...rest] = args
        return topics.map(t => on.call(this, t, ...rest))
      }
      return on.call(this, ...args)
    }
    return super.init()
  }

  emit(event, data, headers) {
    const _msg = typeof event === 'object' ? event : { event, data, headers }
    const msg = _msg instanceof cds.Event ? _msg : new cds.Event(this.message4(_msg))
    return super.emit(msg)
  }

  on(event, cb) {
    const _event = _warnAndStripTopicPrefix(event, this.LOG)
    // save all subscribed topics (not needed for local-messaging)
    this.subscribedTopics.set(this.prepareTopic(_event, true), _event)
    return super.on(_event, cb)
  }

  prepareTopic(topic, _inbound) {
    // In local messaging there's a 'short curcuit' so we must not modify the topic
    if (this.options.local) return topic
    let res = topic
    if (!_inbound && this.options.publishPrefix) res = this.options.publishPrefix + res
    if (_inbound && this.options.subscribePrefix) res = this.options.subscribePrefix + res
    return res
  }

  prepareHeaders(headers, event) {
    if (this.options.format === 'cloudevents') {
      if (!('id' in headers)) headers.id = cds.utils.uuid()
      if (!('type' in headers)) headers.type = event
      if (!('source' in headers)) headers.source = `/default/sap.cap/${process.pid}`
      if (!('time' in headers)) headers.time = new Date().toISOString()
      if (!('datacontenttype' in headers)) headers.datacontenttype = 'application/json'
      if (!('specversion' in headers)) headers.specversion = '1.0'
    }
  }

  message4(msg) {
    const _msg = { ...msg }
    if (msg.inbound && !cds.context) {
      // REVISIT: why are all inbound messages executed with privileged user?
      cds.context = { tenant: msg.tenant, user: new cds.User.Privileged() }
    }
    _msg.event = _warnAndStripTopicPrefix(_msg.event, this.LOG)
    if (!_msg.headers) _msg.headers = {}
    if (!_msg.inbound) {
      _msg.headers = { ..._msg.headers } // don't change the original object
      this.prepareHeaders(_msg.headers, _msg.event)
      _msg.event = this.prepareTopic(_msg.event, false)
    } else if (this.subscribedTopics) {
      const subscribedEvent =
        this.subscribedTopics.get(_msg.event) ||
        (this.wildcarded && this.subscribedTopics.get(this.wildcarded(_msg.event)))
      if (!subscribedEvent) throw new Error(`No handler for incoming message with topic '${_msg.event}' found.`)
      _msg.event = subscribedEvent
    }
    return _msg
  }
}

module.exports = MessagingService
