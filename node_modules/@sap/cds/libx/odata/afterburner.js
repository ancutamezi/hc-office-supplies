const cds = require('../_runtime/cds')

const { where2obj } = require('../_runtime/common/utils/cqn')
const { findCsnTargetFor } = require('../_runtime/common/utils/csn')

const _addKeysDeep = (keys, keysCollector, ignoreManagedBacklinks) => {
  for (const keyName in keys) {
    const key = keys[keyName]
    const foreignKey = key._foreignKey4
    if (key.isAssociation || foreignKey === 'up_' || key['@cds.api.ignore'] === true) continue

    if (ignoreManagedBacklinks && foreignKey) {
      const navigationElement = keys[foreignKey]
      if (!navigationElement.on && navigationElement._isBacklink) {
        // skip navigation elements that are backlinks
        continue
      }
    }

    if ('elements' in key) {
      _addKeysDeep(key.elements, keysCollector)
      continue
    }
    keysCollector.push(keyName)
  }
}

function _keysOf(entity, ignoreManagedBacklinks) {
  if (!entity || !entity.keys) return
  const keysCollector = []
  _addKeysDeep(entity.keys, keysCollector, ignoreManagedBacklinks)
  return keysCollector
}

function _getDefinition(definition, name, namespace) {
  return (
    (definition.definitions && definition.definitions[name]) ||
    (definition.elements && definition.elements[name]) ||
    (definition.actions && (definition.actions[name] || definition.actions[name.replace(namespace + '.', '')])) ||
    definition[name]
  )
}

function _resolveAliasInParams(params, entity) {
  if (!entity._alias2ref) return
  const paramKeys = Object.keys(params)
  for (const paramKey of paramKeys) {
    if (entity._alias2ref[paramKey]) {
      params[entity._alias2ref[paramKey].join('_')] = params[paramKey]
      params[paramKey] = undefined
    }
  }
}

function _resolveAliasInWhere(where, entity) {
  if (!entity._alias2ref) return
  for (const w of where) {
    if (!w.ref || w.ref.length > 1 || entity.keys[w.ref[0]]) continue
    w.ref = entity._alias2ref[w.ref[0]] || w.ref
  }
}

function _addDefaultParams(ref, view) {
  const params = view.params
  const defaults = params && Object.values(params).filter(p => p.default)
  if (defaults && defaults.length > 0) {
    if (!ref.where) ref.where = []
    for (const def of defaults) {
      if (ref.where.find(e => e.ref && e.ref[0] === def.name)) {
        continue
      }
      if (ref.where.length > 0) ref.where.push('and')
      ref.where.push({ ref: [def.name] }, '=', { val: def.default.val })
    }
  }
}

// case: single key without name, e.g., Foo(1)
function addRefToWhereIfNecessary(where, entity) {
  if (!where || where.length !== 1) return 0

  const isView = !!entity.params

  const keys = isView ? Object.keys(entity.params) : _keysOf(entity)
  if (keys.length !== 1) return 0
  where.unshift(...[{ ref: [keys[0]] }, '='])
  return 1
}

function _processSegments(cqn, model, namespace) {
  const from = _resolveFrom(cqn.SELECT.from)
  const ref = from.ref

  let current = model
  let path
  let keys = null
  let keyCount = 0
  let incompleteKeys
  let one
  for (let i = 0; i < ref.length; i++) {
    const seg = ref[i].id || ref[i]
    let params = ref[i].where && where2obj(ref[i].where)

    if (incompleteKeys) {
      // > key
      keys = keys || _keysOf(current, !cds.env.features.rest_new_adapter && !cds.env.features.rest_new_parser) // if odata skip backlinks as key as they are used from structure
      let key = keys[keyCount++]
      one = true
      const element = current.elements[key]
      let base = ref[i - keyCount]
      if (!base.id) base = { id: base, where: [] }
      if (base.where.length) base.where.push('and')

      if (ref[i].id) {
        // > fix case key value parsed to collection with filter
        const val = `${ref[i].id}(${Object.keys(params)
          .map(k => `${k}='${params[k]}'`)
          .join(',')})`
        base.where.push({ ref: [key] }, '=', { val })
      } else {
        base.where.push({ ref: [key] }, '=', { val: element._type === 'cds.Integer' ? Number(seg) : seg })
      }
      ref[i] = null
      ref[i - keyCount] = base
      incompleteKeys = keyCount < keys.length
    } else {
      // > entity or property (incl. nested) or navigation or action or function
      keys = null
      keyCount = 0
      one = false

      path = path ? path + `${path.match(/:/) ? '.' : ':'}${seg}` : seg
      // REVISIT: replace use case: <namespace>.<entity>_history is at <namespace>.<entity>.history
      current = _getDefinition(current, seg, namespace) || _getDefinition(current, seg.replace(/_/g, '.'), namespace)
      // REVISIT: 404 or 400?
      if (!current) cds.error(`Invalid resource path "${path}"`, { code: 404 })

      if (current.params && current.kind === 'entity') {
        // > View with params
        if (ref[i].where) {
          keyCount += addRefToWhereIfNecessary(ref[i].where, current)
          _resolveAliasInWhere(ref[i].where, current)
          _resolveAliasInParams(params, current)
        }

        _addDefaultParams(ref[i], current)
        if ((!params || !Object.keys(params).length) && ref[i].where) params = where2obj(ref[i].where)

        _checkAllKeysProvided(params, current)

        ref[i].args = {}
        for (let j = 0; j < ref[i].where.length; j++) {
          const w = ref[i].where[j]
          if (w === 'and' || !w.ref) continue
          ref[i].args[w.ref[0]] = ref[i].where[j + 2]
          j += 2
        }
        ref[i].where = undefined
        if (ref[i + 1] !== 'Set') {
          // /Set is missing
          throw new Error(`Incorrect call to a view with parameter "${current.name}"`)
        }
        ref[++i] = null
      } else if (current.kind === 'entity') {
        // > entity
        one = !!(ref[i].where || current._isSingleton)
        incompleteKeys = ref[i].where ? false : i === ref.length - 1 || one ? false : true
        if (ref[i].where) {
          keyCount += addRefToWhereIfNecessary(ref[i].where, current)
          _resolveAliasInWhere(ref[i].where, current)
          _resolveAliasInParams(params, current)
          // in case of Foo(1), params will be {} (before addRefToWhereIfNecessary was called)
          if (!Object.keys(params).length) params = where2obj(ref[i].where)
          _checkAllKeysProvided(params, current)
        }
      } else if ({ action: 1, function: 1 }[current.kind]) {
        // > action or function
        if (i !== ref.length - 1) {
          const msg = `${i ? 'Unbound' : 'Bound'} ${current.kind} are only supported as the last path segment.`
          throw Object.assign(new Error(msg), { statusCode: 501 })
        }
        ref[i] = { operation: current.name }
        if (params) ref[i].args = params
        if (current.returns && current.returns._type) one = true
      } else if (current.isAssociation) {
        // > navigation
        one = !!(current.is2one || ref[i].where)
        incompleteKeys = one || i === ref.length - 1 ? false : true
        current = model.definitions[current.target]
        if (ref[i].where) {
          keyCount += addRefToWhereIfNecessary(ref[i].where, current)
          _resolveAliasInWhere(ref[i].where, current)
        }
      } else if (current._isStructured) {
        // > nested property
        one = true
        current = current.elements
      } else {
        // > property
        one = true
      }
    }
  }

  if (incompleteKeys) {
    // > last segment not fully qualified
    throw Object.assign(
      new Error(
        `Entity "${current.name}" has ${_keysOf(current).length} keys. Only ${keyCount} ${
          keyCount === 1 ? 'was' : 'were'
        } provided.`
      ),
      { status: 400 }
    )
  }

  // remove all nulled refs
  from.ref = ref.filter(r => r)

  // one?
  if (one) cqn.SELECT.one = true

  // REVISIT: better
  // set target (csn definition) for later retrieval
  cqn.__target = current
}

const _resolveFrom = from => (from.SELECT ? _resolveFrom(from.SELECT.from) : from)

const _checkAllKeysProvided = (params, entity) => {
  let keysOfEntity
  const isView = !!entity.params
  if (isView) {
    // view with params
    if (params === undefined) {
      throw new Error(`Incorrect call to a view with parameter "${entity.name}"`)
    } else if (Object.keys(params).length === 0) {
      throw new Error('KEY_EXPECTED')
    }

    keysOfEntity = Object.keys(entity.params)
  } else {
    keysOfEntity = _keysOf(entity)
  }

  if (!keysOfEntity) return
  for (const keyOfEntity of keysOfEntity) {
    if (!(keyOfEntity in params)) {
      if (isView && entity.params[keyOfEntity].default) {
        // will be added later?
        continue
      }

      throw Object.assign(
        new Error(
          `${isView ? 'Parameter' : 'Key'} "${keyOfEntity}" is missing for ${isView ? 'view' : 'entity'} "${
            entity.name
          }"`
        ),
        { status: 400 }
      )
    }
  }
}

function _4service(service) {
  const { namespace, model } = service

  return cqn => {
    const { ref } = _resolveFrom(cqn.SELECT.from)

    // REVISIT: shouldn't be necessary
    /*
     * make first path segment fully qualified
     */
    const root = findCsnTargetFor(ref[0].id || ref[0], model, namespace)
    // REVISIT: 404 or 400?
    if (!root) cds.error(`Invalid resource path "${namespace}.${ref[0].id || ref[0]}"`, { code: 404 })
    if (ref[0].id) ref[0].id = root.name
    else ref[0] = root.name

    /*
     * key vs. path segments (/Books/1/author/books/2/...) and more
     */
    _processSegments(cqn, model, namespace)

    return cqn
  }
}

const cache = new WeakMap()

module.exports = {
  for: service => {
    if (!cache.has(service)) cache.set(service, _4service(service))
    return cache.get(service)
  },
  addRefToWhereIfNecessary
}
