/** ------------------------------------------
 * This is a peg.js adaptation of the https://github.com/oasis-tcs/odata-abnf/blob/master/abnf/odata-abnf-construction-rules.txt
 * which directly constructs CQN out of parsed sources.
 *
 * NOTE:
 * In contrast to the OData ABNF source, which uses very detailed semantic rules,
 * this adaptation uses rather generic syntactic rules only, e.g. NOT distinguishing
 * between Collection Navigation or NOT knowing individual function names.
 * This is to be open to future enhancements of the OData standard, as well as
 * to improve error messages. For example a typo in a function name could be
 * reported specifically instead of throwing a generic parser error.
 *
 * See also: https://docs.microsoft.com/en-us/odata/concepts/queryoptions-overview
 * Future test cases http://docs.oasis-open.org/odata/odata/v4.0/errata03/os/complete/abnf/odata-abnf-testcases.xml
 *
 * Limitations: Type, Geo functions are NOT supported,
 * maxdatetime, mindatetime, fractionalseconds,
 * totaloffsetminutes, date, totalseconds,
 * floor, ceiling also are NOT supported by CAP
 *
 * Examples:
 * Books
 * Books/201
 * Books?$select=ID,title&$expand=author($select=name)&$filter=stock gt 1&$orderby=title
 */

//
// ---------- JavaScript Helpers -------------
  {
    const $ = Object.assign
    const { strict, minimal } = options
    const stack = []
    let SELECT, count
    const TECHNICAL_OPTS = ['$value'] // odata parts to be handled somewhere else

    // we keep that here to allow for usage in https://pegjs.org/online
    const safeNumber = options.safeNumber || function (str) {
      const n = Number(str)
      return Number.isSafeInteger(n) ? n : str
    }
    const standardBase64 = options.standardBase64 || function (str) {
      // convert url-safe to standard base64 (with padding, if necessary)
      str = str.replace(/_/g, '/').replace(/-/g, '+')
      return str.padEnd(str.length + str.length % 4, '=')
    }

    const _compareRefs = col => exp => col === exp ||
      (col.as && exp.as && col.as === exp.as) ||
      (exp.as && col.ref && exp.as === col.ref[col.ref.length - 1]) ||
      (col.ref && exp.ref && col.ref.join('') === exp.ref.join(''))
    const _remapFunc = columns => c => {
      if (Array.isArray(c)) return c.map(_remapFunc(columns))
      const fnObj = c.ref && columns.find(col => col.as && col.func && col.as === c.ref[0])
      if (fnObj) return fnObj
      return c
    }
    const _replaceNullRef = groupBy => c => {
      if (Array.isArray(c)) return c.map(_replaceNullRef(groupBy))
      if (c.ref && !groupBy.find(_compareRefs(c))) return { val: null }
      return c
    }
    const _expand = (columns, col) => {
      if (col.ref.length === 1) {
        if (!columns.find(_compareRefs(col))) columns.push(col)
      } else {
        const assoc = col.ref.shift()
        const exp = columns.find(c => c.ref && c.ref[0] === assoc)
        if (exp) {
          _expand(exp.expand, col)
        } else {
          const exp = {
            ref: [assoc],
            expand: []
          }
          _expand(exp.expand, col)
          columns.push(exp)
        }
      }
    }
    const _handleApply = (cqn, apply, onlyColumnsFromExpand = false) => {
      if (!apply) return
      if (cqn.apply) delete cqn.apply
      if (apply.apply || (apply.where && cqn.where) || (apply.search && cqn.search)) {
        cqn.from = { SELECT: { from: cqn.from } }
      }
      if (apply.where) {
        if (cqn.where) cqn.from.SELECT.where = apply.where
        else cqn.where = apply.where
      }
      if (apply.search) {
        if (cqn.search) cqn.from.SELECT.search = apply.search
        else cqn.search = apply.search
      }
      if (apply.groupBy) {
        cqn.groupBy = []
        for (const col of apply.groupBy) {
          if (!cqn.groupBy.find(_compareRefs(col))) cqn.groupBy.push(col)
        }
      }
      const aggregatedColumns = [...(cqn.groupBy || []), ...(apply.aggregate || [])]
      if (aggregatedColumns.length) {
        cqn.columns = cqn.columns && !onlyColumnsFromExpand
          // using .reduce instead of .filter since columns order might be important
          ? cqn.columns.reduce((columns, col) => {
            const aggregatedColumn = aggregatedColumns.find(_compareRefs(col))
            if (aggregatedColumn) columns.push(aggregatedColumn)
            return columns
          }, [])
          : aggregatedColumns
        if (cqn.where) {
          cqn.where = cqn.where.map(_remapFunc(cqn.columns))
          if (cqn.groupBy) {
            cqn.having = cqn.where.map(_replaceNullRef(cqn.groupBy))
            delete cqn.where
          }
        }
        // expand navigation refs in aggregated columns
        cqn.columns = cqn.columns.reduce((columns, col) => {
          if (col.ref && col.ref.length > 1 && aggregatedColumns.find(_compareRefs(col))) {
            _expand(columns, { ref: [...col.ref] })
          } else columns.push(col)
          return columns
        }, [])
      }
      if (apply.apply) _handleApply(cqn.from.SELECT, apply.apply)
    }
    const _setLimitOffset = val => {
      if (SELECT.limit && SELECT.limit.offset && SELECT.limit.offset.val) {
        val += SELECT.limit.offset.val
      }
      (SELECT.limit || (SELECT.limit={})).offset = {val}
    }

    const _removeLambdaPrefix = (prefix, elements) => {
      for (const e of elements) {
        // remove the prefix identifier
        if (e.ref && e.ref[0] === prefix) e.ref.shift()
        if (e.func) _removeLambdaPrefix(prefix, e.args)
      }

      return elements
    }
  }

// ---------- Entity Paths ---------------

  ODataRelativeURI // Note: case-sensitive!
    = '/'? (p:path { SELECT = p })
    ( o"?"o QueryOption ( o'&'o QueryOption )* )? o {
      if (count) {
        // columns set because of $count: ignore $select, $expand, $top, $skip, $orderby
        // REVISIT: don't ignore query options but throw bad request (as okra did)?
        SELECT.columns = [{ args: [{ val: 1 }], as: '$count', func: 'count' }]
        delete SELECT.expand
        delete SELECT.limit
        delete SELECT.orderBy
        if (SELECT.apply) {
          SELECT.apply = { apply: SELECT.apply }
          _handleApply(SELECT, SELECT.apply)
        }
        return { SELECT }
      }
      let onlyColumnsFromExpand
      if (SELECT.expand) {
        // Books?$expand=author w/o $select=author
        if (!SELECT.columns) {
          SELECT.columns = ['*']
          onlyColumnsFromExpand = true
        }
        for (const exp of SELECT.expand) {
          const idx = SELECT.columns.findIndex(_compareRefs(exp))
          if (idx > -1) SELECT.columns.splice(idx, 1)
          SELECT.columns.push(exp)
        }
        delete SELECT.expand
      }
      if (SELECT.count && SELECT.apply) SELECT.__countAggregated = true
      _handleApply(SELECT, SELECT.apply, onlyColumnsFromExpand)
      return { SELECT }
    }

  path
    = "$count" {count = true}
    / rv:$("$ref"/"$value") {return !TECHNICAL_OPTS.includes(rv) && {from: {ref: [rv]}}}
    / head:(
      (identifier filter:(OPEN CLOSE/OPEN args CLOSE)? !segment) / val:segment{return [val]}
    )? tail:((s:"/" {return s;}) path?)? {
      tail = tail && tail[1]
      if (!head && !tail) {
        return {from: {ref: ['']}}
      } else if (!head && tail && tail.from) {
        tail.from.ref.unshift('')
        return tail
      } 

      const [id, filter] = head
      // minimal: val also as path segment
      const ref = []
      if (filter) {
        if (filter.length > 2) {
          ref.push({ id, where: filter[1].map(f => f.val && f.val.match && f.val.match(/^"(.*)"$/) ? { val: f.val.match(/^"(.*)"$/)[1] } : f) })
        } else {
          ref.push({ id, where: [] })
        }
      } else {
        if (minimal) {
          ref.push(`${typeof id === 'object' && 'val' in id ? id.val : id}`)
        } else {
          // REVISIT: keep 123 as number?
          if (typeof id === 'object' && typeof id.val === 'string' && id.val.match(/^[1-9]\d*$|^0$/)) {
            ref.push({ val: safeNumber(id.val) })
          } else {
            ref.push(id)
          }
        }
      }
      if (tail && tail.from) {
        const more = tail.from.ref
        if (Object.prototype.hasOwnProperty.call(more[0], 'val')) ref[ref.length-1] = { id:ref[ref.length-1], where:[more.shift()] }
        ref.push (...more)
      }
      const res = {from: {ref}}
      if (tail && tail.columns) res.columns = tail.columns
      return res
    }

  args
    = val:val {return [val]}
    / ref:ref o"="o val:val more:( COMMA args )? {
      const args = [ ref, '=', val ]
      if (more) args.push ('and', ...more[1])
      return args
    }

//
// ---------- Query Options ------------

  QueryOption = ExpandOption /
    "$skiptoken="   o skiptoken /
    "$apply="       (o{
      SELECT.apply = {}
    }) apply /
    custom
  // @OData spec for $expand:
  // "Allowed system query options are $filter, $select, $orderby, $skip, $top, $count, $search, and $expand."
  ExpandOption =
    "$select="      o select ( COMMA select )* /
    "$expand="      o expand ( COMMA expand )* /
    "$filter="      o f:filter{SELECT.where = f} /
    "$orderby="     o orderby ( COMMA orderby )* /
    "$top="         o top /
    "$skip="        o skip /
    "$search="      o s:search {if (s) SELECT.search = s} /
    "$count="       o count


  select
    = col:('*'/ref) {
      SELECT.columns = Array.isArray(SELECT.columns) ? SELECT.columns : []
      if (!SELECT.columns.find(_compareRefs(col))) SELECT.columns.push(col)
      return col
    }

  expand =
    (
      c:('*'/ref) {
        const col = c === '*' ? {} : c
        col.expand = '*'
        if (!Array.isArray(SELECT.expand)) SELECT.expand = []
        if (!SELECT.expand.find(_compareRefs(col))) SELECT.expand.push(col)
        return col
      }
    )
    ( // --- nested query options, if any
      (OPEN {
        stack.push (SELECT)
        SELECT = SELECT.expand[SELECT.expand.length-1]
        SELECT.expand = '*' // by default expand everything
      })(
      expandOptions:( o ";"? o ExpandOption)*
      {
        if (SELECT.columns) {
          if (SELECT.expand === '*') SELECT.expand = []
          for (const col of SELECT.columns) {
            if (!SELECT.expand.find(_compareRefs(col))) SELECT.expand.push(col)
          }
          delete SELECT.columns
        } else {
          if (Array.isArray(SELECT.expand) && SELECT.expand.indexOf('*') === -1) SELECT.expand.unshift('*')
        }
      }
      )(CLOSE {
        SELECT = stack.pop()
      })
    )? // --- end of nested query options
    ( COMMA expand )?
    ("/$count" {
      const err = new Error("EXPAND_COUNT_UNSUPPORTED");
      err.statusCode=501;
      throw err;
    })?

  top
    = val:integer {
      (SELECT.limit || (SELECT.limit={})).rows = {val}
    }

  skiptoken
    = val:integer? skiptoken:skiptokenChars? {
      // REVISIT ignore non-numeric $skiptoken as not supported by CQN
      if (skiptoken) return
      _setLimitOffset(val)
    }

  skip
    = val:integer {
      _setLimitOffset(val)
    }

  search
    = p:search_clause {return p}
      / o // Do not add search property for space only

  search_clause
    = p:( n:NOT? {return n?[n]:[]} )(
      OPEN xpr:search_clause CLOSE {p.push({xpr})}
      / (
          val:doubleQuotedString {p.push({val})} /
          val:string {p.push({val})} /
          val:word {p.push({val})}
        )
    )( ao:(AND/OR/AND_SPACE) more:search_clause {p.push(ao,...more)} )*
    {return p}

  filter
    = p:where_clause { return p }

  where_clause = p:( n:NOT? {return n?[n]:[]} )(
      OPEN xpr:where_clause CLOSE {p.push({xpr})}
      / comp:comparison {p.push(...comp)}
      / lambda:lambda {
        if (p[p.length - 1] === 'not' && lambda[0] === 'not') {
          p.push('(', ...lambda, ')')
        } else {
          p.push(...lambda)
        }
      }
      / func:boolish {p.push(func)}
      / val:bool {p.push({val})}
    )( ao:(AND/OR) more:where_clause {p.push(ao,...more)} )*
    {return p}

  lambda =
    nav:( n:identifier {return[n]} ) '/' ( n:identifier '/' {nav.push(n)} )*
    xpr:(
      any:any {
        let id = nav.pop()
        if (!any) return ['exists', { ref: [...nav, { id }] }]
        let xpr = []
        for (let i=0, k=0; i<any.length; ++i) {
          let each = any[i]
          if (each.ref && each.ref.length === 0 && any[i+1] === '=') {
            xpr[k++] = { func:'contains', args:[{ref:id}, any[i+=2]] }
          } else {
            xpr[k++] = each
          }
        }

        if (xpr.length < any.length) {
          id = nav.pop()
          return ['exists', { ref: [...nav, { id, where: xpr }] }]
        } else {
          return ['exists', { ref: [...nav, { id, where: any }] }]
        }
      }
      / all:all {
        let id = nav.pop()
        return ['not', 'exists', { ref: [...nav, { id, where: ['not', { xpr: [...all] }] }] }]
      }
    )
    { return xpr }

  inner_lambda =
    p:( n:NOT? { return n ? [n] : [] } )(
      OPEN xpr:inner_lambda CLOSE { p.push('(', ...xpr, ')') }
      / comp:comparison { p.push(...comp) }
      / func:function { p.push(func) }
      / lambda:lambda { p.push(...lambda)}
    )
    ( ao:(AND/OR) more:inner_lambda { p.push(ao, ...more) } )*
    { return p }

  lambda_clause = prefix:identifier ":" inner:inner_lambda {
    return _removeLambdaPrefix(prefix, inner)
  }

  any = "any" OPEN p:lambda_clause? CLOSE { return p }

  all = "all" OPEN p:lambda_clause CLOSE { return p }

  orderby
    = ref:(lambda{const err = new Error("ORDERBY_LAMBDA_UNSUPPORTED");err.statusCode=501;throw err;}/function/ref) sort:( _ s:$("asc"/"desc") {return s})? {
        // TODO: Lambda support
        const appendObj = $(ref, sort && {sort});
        SELECT.orderBy = SELECT.orderBy ?
          [...SELECT.orderBy, appendObj] :
          [appendObj]
    }

  count
    = val:bool { if(val) SELECT.count = true }

  apply
    = applyTrafo ("/" applyTrafo)*

  custom = [a-zA-Z] [a-zA-Z0-9-]* "=" [^&]*

//
// ---------- Expressions ------------


  comparison "a comparison"
    = a:operand _ o:$("eq"/"ne"/"lt"/"gt"/"le"/"ge") _ b:operand {
      const op = { eq:'=', ne:'!=', lt:'<', gt:'>', le:'<=', ge:'>=' }[o]||o
      return [ a, op, b ]
    }

  mathCalc
    = operand (_ ("add" / "sub" / "mul" / "div" / "mod") _ operand)*

  operand "an operand"
    = navigationCount / function / val / ref / jsonObject / jsonArray / list

  navigationCount "navigation with $count"
  = navigationPath:(head:identifier key:(OPEN keyArgs:args CLOSE {return keyArgs;})? '/' {
    if (key) {
      // we have key in xpr
      return {id: head, where: key}
    }
    return head;
  })+ count: '$count'
    { return {func: 'count', as: '$count', args: [{ref: navigationPath}]} }

  ref "a reference"
    = head:identifier tail:( '/' n:identifier {return n})*
    {
      if (head === "null") {
        return { val: null }
      }

      return { ref:[ head, ...tail ] }
    }

  val
    = val:(bool / date) {return {val}}
    / val:guid {return {val}}
    / val:number {return typeof val === 'number' ? {val} : { val, literal:'number' }}
    / val:string {return {val}}
    / val:binary {return {val}}

  jsonObject = val:$("{" (jsonObject / [^}])* "}") {return {val}}

  jsonArray = val:$("[" o "]" / "[" o "{" (jsonArray / [^\]])* "]") {return {val}}

  list
    = "[" any:$([^\]])* "]" // > needs improvment
    { return { list: any.replace(/"/g,'').split(',').map(ele => ({ val: ele })) } }

  function "a function call"
    = func:$[a-zA-Z]+ OPEN a:operand more:( COMMA o:operand {return o} )* CLOSE {
      if (strict && !(func.toLowerCase() in strict.functions)) {
        throw Object.assign(new Error(`"${func}" is an unknown function in OData URL spec (strict mode)`), { statusCode: 400 })
      }
      return { func: func.toLowerCase(), args:[a,...more] }
    }

  boolish "a boolean function"
    = func:("contains"i/"endswith"i/"startswith"i) OPEN a:operand COMMA b:operand CLOSE
    { return { func: func.toLowerCase(), args:[a,b] }}

  NOT = o "NOT"i _ {return 'not'}
  AND = _ "AND"i _ {return 'and'}
  AND_SPACE =   _ {return 'and'}
  OR  = _  "OR"i _ {return 'or'}


//
// ---------- Transformations ------------

  applyTrafo
    = (
      "aggregate" aggregateTrafo /
      "groupby" groupbyTrafo /
      "filter" filterTrafo /

      // REVISIT: All transformations below need improvment
      // and should supported by CAP
      "expand" expandTrafo /
      "search" searchTrafo /
      "concat" concatTrafo /
      "compute" computeTrafo /
      func:("topcount"i/"bottomcount"i/"topsum"i/"bottomsum"i/"toppercent"i/"bottompercent"i) args:commonFuncTrafo {
        const SUPPORTED_APPLY_TRANSFORMATIONS = {
          "topcount": true,
          "bottomcount": true,
          "topsum": false,
          "bottomsum": false,
          "toppercent": false,
          "bottompercent": false
        }
        func = func.toLowerCase()
        if (!SUPPORTED_APPLY_TRANSFORMATIONS[func]) {
          throw Object.assign(new Error(`Transformation "${func}" in $apply is not supported yet.`), { statusCode: 501 })
        }
        (SELECT.apply.aggregate || (SELECT.apply.aggregate = [])).push({ func, args })
      } /
      identityTrafo
      // customFunction
    )

  aggregateTrafo
    = OPEN o head:aggregateItem tail:(o COMMA o p:aggregateItem {return p})* o CLOSE {
      let _apply = SELECT.apply
      if (_apply.aggregate) {
        SELECT.apply = { apply: _apply }
        if (_apply.groupBy) SELECT.apply.groupBy = _apply.groupBy
        _apply = SELECT.apply
      }
      _apply.aggregate = [head, ...tail]
    }
  aggregateItem
    = res:("$count" as:asAlias { return { func: 'count', args: [{ val: 1 }], as } }
           / aggregateExpr
          ) { return res }
  aggregateExpr
    = path:(
        ref
     // / mathCalc - needs CAP support
      )
      func:aggregateWith aggregateFrom? as:asAlias
        { return { func, args: [ path ], as } }
      / identifier OPEN aggregateExpr CLOSE // needs CAP support
   // / customAggregate // needs CAP support
  aggregateWith
    = _ "with" _ func:$[a-zA-Z]+ { return func.toLowerCase(); }
  aggregateFrom
    = _ "from" _ ref aggregateWith aggregateFrom? // needs CAP support
  asAlias
    = _ "as" _ alias:identifier { return alias; }

  groupbyTrafo
    = OPEN OPEN head:groupByElem tail:(COMMA p:groupByElem {return p})* (CLOSE {
      let _apply = SELECT.apply
      if (_apply.groupBy || _apply.where || _apply.search) {
        SELECT.apply = { apply: _apply }
        _apply = SELECT.apply
      }
      _apply.groupBy = [head, ...tail]
    }) (COMMA apply)? CLOSE
  groupByElem
    = c:(rollupSpec / ref) { return c }
  rollupSpec // TODO fix this + add CAP support
    = rollup:("rollup" OPEN o ('$all' / ref) (o COMMA ref)+ o CLOSE) {const err = new Error("Rollup in groupby is not supported yet.");err.statusCode=501;throw err;}

  filterTrafo = OPEN o (where:filter{
    let _apply = SELECT.apply
    if (_apply.where) {
      SELECT.apply = { apply: _apply }
      _apply = SELECT.apply
    }
    _apply.where = where
  }) o CLOSE


  // All transformations below need improvment
  // and should supported by CAP
  expandTrafo
    = OPEN o ref o COMMA o
      ( expandTrafo (o COMMA expandTrafo)*
      / filterTrafo (o COMMA expandTrafo)*
      ) o CLOSE

  searchTrafo = OPEN o (search:search{
    if (!search) return
    let _apply = SELECT.apply
    if (_apply.search) {
      SELECT.apply = { apply: _apply }
      _apply = SELECT.apply
    }
    _apply.search = search
  }) o CLOSE

  concatTrafo = OPEN o apply (o COMMA o apply)+ o CLOSE

  computeTrafo = OPEN o computeExpr (o COMMA o computeExpr)* o CLOSE

  computeExpr = where_clause asAlias

  commonFuncTrafo = OPEN o first:operand o COMMA o second:operand o CLOSE { return [first, second] }

  identityTrafo = "identity"


//
// ---------- Literals -----------

  bool = b:("true" / "false") { return b === 'true'}

  string "Edm.String"
    = "'" s:$("''"/[^'])* "'"
    {return s.replace(/''/g,"'")}

  doubleQuotedString
    = '"' s:$('\\"'/[^"])* '"'
    {return s.replace(/\\\\/g,"\\").replace(/\\"/g,'"')}

  word
    = $([^ \t\n()"&;]+)

  date
    = s:$( [0-9]+"-"[0-9][0-9]"-"[0-9][0-9] // date
      ( "T"[0-9][0-9]":"[0-9][0-9](":"[0-9][0-9]("."[0-9]+)?)? // time
      ( "Z" / (("+" / "-")[0-9][0-9]":"[0-9][0-9]) )? // timezone (Z or +-hh:mm)
    )?)

  number
    = s:$( [+-]? [0-9]+ ("."[0-9]+)? ("e"[0-9]+)? ) { return safeNumber(s) }

  integer
    = s:$( [+-]? [0-9]+ ) { return parseInt(s) }

  identifier
    = !bool !guid s:$([_a-zA-Z][_a-zA-Z0-9"."]*) { return s }

  guid
    = $( hex16 hex16 "-"? hex16 "-"? hex16 "-"? hex16 "-"? hex16 hex16 hex16 )

  hex16
    = $( [0-9a-fA-F][0-9a-fA-F][0-9a-fA-F][0-9a-fA-F] )

  segment // > everything except / and ?
    = val:$( [^/?]+ ) { return { val } }

  skiptokenChars
    = $( [a-zA-Z0-9-"."_~!$'()*+,;=:@"/""?"]+ )

  binary // > url-safe base64
    = "binary'" s:$([a-zA-Z0-9-_]+ ("=="/"=")?) "'" { return standardBase64(s) }

//
// ---------- Punctuation ----------

  COLON = o":"o
  COMMA = o","o
  SEMI  = o";"o
  OPEN  = o"("o
  CLOSE = o")"

//
// ---------- Whitespaces -----------

  o "optional whitespaces" = $[ \t\n]*
  _ "mandatory whitespaces" = $[ \t\n]+

//
// ------------------------------------
