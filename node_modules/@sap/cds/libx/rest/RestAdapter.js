const cds = require('../_runtime/cds')

const express = require('express')

const auth = require('./middleware/auth')
const content = require('./middleware/content')
const parse = require('./middleware/parse')
const input = require('./middleware/input')

const create = require('./middleware/create')
const read = require('./middleware/read')
const update = require('./middleware/update')
const deleet = require('./middleware/delete')
const operation = require('./middleware/operation')

const error = require('./middleware/error')
const { alias2ref } = require('../_runtime/common/utils/csn')

class RestAdapter extends express.Router {
  constructor(srv) {
    super()

    alias2ref(srv)

    this.use(express.json())

    // pass srv-reated stuff to middlewares via req
    this.use('/', (req, res, next) => {
      req._srv = srv
      next()
    })

    // check @requires as soon as possible (DoS)
    this.use('/', auth)

    // service root
    const GH = { GET: 1, HEAD: 1 }
    this.use('/', (req, res, next) => {
      if (req.path !== '/' || !GH[req.method]) return next()
      if (req.method === 'HEAD') return res.json({})
      res.json(
        Object.keys(req._srv.entities).reduce(
          (acc, cur) => {
            acc.entities.push({ name: cur, url: cur })
            return acc
          },
          { entities: [] }
        )
      )
    })

    // content-type check
    this.use('/', content)

    // parse
    this.use('/', parse)

    // payload validation
    this.use('/', input)

    // begin tx
    this.use('/', (req, res, next) => {
      // create tx and set as cds.context
      // REVISIT: _model should not be necessary
      req._tx = cds.context = srv.tx({ user: req.user, req, res, _model: req._srv.model })
      next()
    })

    // POST
    this.post('/*', (req, res, next) => {
      if (req._operation) operation(req, res, next)
      else create(req, res, next)
    })

    // HEAD
    this.head('/*', (req, res, next) => {
      read(req, res, next)
    })

    // GET
    this.get('/*', (req, res, next) => {
      if (req._operation) operation(req, res, next)
      else read(req, res, next)
    })

    // PUT, PATCH, DELETE
    this.put('/*', update)
    this.patch('/*', update)
    this.delete('/*', deleet)

    // end tx (i.e., commit or rollback)
    this.use('/', async (req, res, next) => {
      const { result, status, location } = req._result

      // unfortunately, express doesn't catch async errors -> try catch needed
      try {
        await req._tx.commit(result)
      } catch (e) {
        return next(e)
      }

      // TODO: cf. bufferToBase64() in old rest adapter

      // only set status if not yet modified
      if (status && res.statusCode === 200) res.status(status)
      if (location) res.set('location', location)
      if (req.method === 'HEAD')
        res
          .set({
            'content-type': 'application/json; charset=utf-8',
            'content-length': JSON.stringify(result).length
          })
          .end()
      // need to convert number to string because express interprets integer as status code
      else res.send(typeof result === 'number' ? result.toString() : result)
    })
    this.use('/', (err, req, res, next) => {
      // request may fail during processing or during commit -> both caught here

      // REVISIT: rollback needed if error occured before commit attempted -> how to distinguish?
      if (req._tx) req._tx.rollback(err).catch(() => {})

      next(err)
    })

    /*
     * error handling
     */
    this.use(error)
  }
}

module.exports = RestAdapter
