const cds = require('./index'), { local, inspect } = cds.utils
const DEBUG = cds.debug('deploy')
/* eslint-disable no-console */

/**
 * Implementation of `cds.deploy` common to all databases.
 * It uses the database-specific `db.deploy` to prepare the database, e.g.
 * deploy create tables and views in case of a SQL database, then fills
 * in initial data, if present.
 */
exports = module.exports = function cds_deploy (model,options) { return {

  /** @param {cds.Service} db */
  async to (db, o = options || cds.options || {}) {
    const LOG = o.silent || !cds.log('deploy')._info ? ()=>{} : console.log

    if (model && !model.definitions) {
      model = await cds.load (model) .then (cds.minify)
      if (DEBUG) try {
        DEBUG (`model loaded from ${model.$sources.length} file(s):\n\x1b[2m`)
        for (let each of model.$sources)  console.log (' ', local(each))
      } finally {
        console.log ('\x1b[0m')
      }
    }

    if (o.mocked) exports.include_external_entities_in (model)
    else exports.exclude_external_entities_in (model)

    if (!db.run) db = await cds.connect.to(db)
    if (!cds.db) cds.db = cds.services.db = db
    if (!db.model) db.model = model

    // create tables & views...
    const any = await exports.create (db,model,o)
    if (!any) return db

    // fill in initial data...
    await exports.init (db,model, file => LOG(
      `\x1b[2m > init from ${local(file)} \x1b[0m`
    ))

    // done
    const {credentials:c} = db.options, file = c && (c.database || c.url)
    if (file !== ':memory:') LOG (`/> successfully deployed to ./${file}\n`)
    else LOG (`/> successfully deployed to sqlite in-memory db\n`)
    return db
  },

  // continue to support cds.deploy() as well...
  then(n,e) { return this.to (cds.db||'db') .then (n,e) },
  catch(e) { return this.to (cds.db||'db') .catch (e) },
}}



const { fs, path, read } = cds.utils
const { readdir } = fs.promises
const isdir = (..._) => fs.isdir(path.join(..._))
const isfile = (..._) => fs.isfile(path.join(..._))

exports.include_external_entities_in = function (model) {
  if (model._mocked) return model; else Object.defineProperty(model,'_mocked',{value:true})
  for (let each in model.definitions) {
    const def = model.definitions[each]
    if (def['@cds.persistence.mock'] === false) continue
    if (def['@cds.persistence.skip'] === true) {
      DEBUG && DEBUG ('including mocked', each)
      delete def['@cds.persistence.skip']
    }
  }
  exports.exclude_external_entities_in (model)
  return model
}

exports.exclude_external_entities_in = function (csn) { // NOSONAR
  // IMPORTANT to use cds.env.requires below, not cds.requires !!
  for (let [each,{service=each,model,credentials}] of Object.entries (cds.env.requires)) {
    if (!model) continue //> not for internal services like cds.requires.odata
    if (!credentials && csn._mocked) continue //> not for mocked unbound services
    DEBUG && DEBUG ('excluding external entities for', service, '...')
    const prefix = service+'.'
    for (let each in csn.definitions) if (each.startsWith(prefix)) _exclude (each)
  }
  return csn

  function _exclude (each) {
    const def = csn.definitions[each]; if (def.kind !== 'entity') return
    if (def['@cds.persistence.table'] === true) return // do not exclude replica table
    DEBUG && DEBUG ('excluding external entity', each)
    def['@cds.persistence.skip'] = true
    // propagate to all views on top...
    for (let other in csn.definitions) {
      const d = csn.definitions[other]
      const p = d.query && d.query.SELECT || d.projection
      if (p && p.from.ref && p.from.ref[0] === each) _exclude (other)
    }
  }
}


exports.create = async function (db, csn=db.model, o) {
  if (!db.deploy || o.lean) {
    const creates = cds.compile.to.sql (csn,o); if (!creates || creates.length === 0) return
    const drops = creates.map (each => {
      let [, kind, entity] = each.match(/^CREATE (TABLE|VIEW) "?([^\s"(]+)/im) || []
      return `DROP ${kind} IF EXISTS ${entity};`
    }).reverse()
    if (o.dry) {
      console.log(); for (let each of drops) console.log(each)
      console.log(); for (let each of creates) console.log(each,'\n')
      return
    } else await db.tx (async tx => {
      await tx.run(drops)
      await tx.run(creates)
      return true
    })
  } else return db.deploy (csn,o)
}


exports.init = (db, csn=db.model, log=()=>{}) => db.tx (async tx => {
  cds.context = tx //> registers tx as root transaction
  const resources = await exports.resources(csn), inits=[], err = new Error
  for (let [file,e] of Object.entries(resources)) {
    if (e === '*') { // init.js/ts
      const x = require(file); if (!x) continue
      log (file)
      inits.push (!x.then && typeof x === 'function' ? x(db) : x)
    } else { // from .csv or .json
      const INSERT_into = _from_csv_or_json [path.extname(file)]
      const src = await read(file,'utf8'); if (!src) continue
      const q = INSERT_into (e,src); if (!q) continue
      log (file,e)
      inits.push (tx.run(q) .catch (e => { throw Object.assign (e,{
        message: 'in cds.deploy(): ' + e.message +'\n'+ inspect(q),
      })}))
    }
  }
  await Promise.all (inits)
})


exports.resources = async function (csn) {
  if (!csn || !csn.definitions) csn = await cds.load (csn||'*') .then (cds.minify)
  const folders = await exports.resources.folders(csn)
  const found={}, ts = process.env.CDS_TYPESCRIPT
  for (let folder of folders) {
    // fetching init.js files
    const init_js = ts && isfile(folder,'init.ts') || isfile(folder,'init.js')
    if (init_js) found[init_js] = '*'
    // fetching .csv and .json files
    for (let each of ['data','csv']) {
      const subdir = isdir(folder,each); if (!subdir) continue
      const files = await readdir (subdir)
      for (let fx of files) {
        if (fx[0] === '-') continue
        const ext = path.extname(fx); if (ext in _from_csv_or_json) {
          const f = fx.slice(0,-ext.length)
          if (/[._]texts$/.test(f) && files.some(g => g.startsWith(f+'_'))) {
            // ignores 'Books_texts.csv/json' if there is any 'Books_texts_LANG.csv/json'
            DEBUG && DEBUG (`ignoring '${fx}' in favor of translated ones`); continue
          }
          const e = _entity4(f,csn); if (_skip(e)) continue
          found[path.join(subdir,fx)] = e.name
        }
      }
    }
  }
  return found
}


exports.resources.folders = async function (csn) {
  if (!csn || !csn.definitions) csn = await cds.load (csn||'*') .then (cds.minify)
  const folders = new Set (csn.$sources.map (path.dirname) .filter (f => f !== cds.home))
  if (cds.env.folders.db) folders.add (path.resolve(cds.root, cds.env.folders.db))
  if (cds.env.features.test_data) folders.add (path.resolve(cds.root,'test/'))
  return folders
}


const _entity4 = (file,csn) => {
  const name = file.replace(/-/g,'.')
  const entity = csn.definitions [name]
  if (!entity) {
    if (/(.+)[._]texts_?/.test(name)) { // 'Books.texts', 'Books.texts_de'
      const base = csn.definitions [RegExp.$1]
      return base && _entity4 (base.elements.texts.target,csn)
    }
    else return DEBUG && DEBUG (`warning: ${name} not in model`)
  }
  // We also support insert into simple views if they have no projection
  const p = entity.query && entity.query.SELECT || entity.projection
  if (p && !p.columns && p.from.ref && p.from.ref.length === 1) {
    if (csn.definitions [p.from.ref[0]])  return entity
  }
  return entity.name ? entity : { name, __proto__:entity }
}

const INSERT_from_csv = (entity, csv) => {
  let [ cols, ...rows ] = cds.parse.csv (csv)
  if (rows.length > 0) return INSERT.into (entity) .columns (cols) .rows (rows)
}

const INSERT_from_json = (entity, json) => {
  let records = JSON.parse (json)
  if (records.length > 0) return INSERT.into (entity) .entries (records)
}

const _from_csv_or_json = { '.json': INSERT_from_json, '.csv': INSERT_from_csv, }
const _skip = e => !e || e['@cds.persistence.skip'] === true
