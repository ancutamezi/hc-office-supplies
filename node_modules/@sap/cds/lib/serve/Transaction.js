const cds = require('../index'), { cds_tx_protection } = cds.env.features
const EventContext = require('../req/context')
class RootContext extends EventContext {}


/**
 * This is the implementation of the `srv.tx(req)` method. It constructs
 * a new Transaction as a derivate of the `srv` (i.e. {__proto__:srv})
 * @returns { Transaction & import('./Service-api') }
 * @param { EventContext } ctx
 */
module.exports = function tx (ctx,fn) { const srv = this

  if (srv.context) return srv // srv.tx().tx() -> idempotent

  // Last arg may be a function -> srv.tx (tx => { ... })
  if (typeof ctx === 'function') [ ctx, fn ] = [ undefined, ctx ]
  if (typeof fn === 'function') {
    const tx = srv.tx(ctx)
    return Promise.resolve(tx).then(fn) .then (tx.commit,tx.rollback)
  }

  // This is for compatibility with cds.tx(req)
  if (ctx instanceof EventContext) {
    if (ctx.context !== ctx) return NestedTransaction.for (srv, ctx.context)
    if (ctx._tx) return NestedTransaction.for (srv, ctx)
    else return RootTransaction.for (srv, ctx)
  }

  // `ctx` is a plain context object or undefined
  if (ctx) { // REVISIT: This is for compatibility with AFC only
    if (ctx._txed_before) return NestedTransaction.for (srv, ctx._txed_before)
    else Object.defineProperty(ctx, '_txed_before', { value: RootContext.for(ctx) }) // > must be non-enumerable
    return RootTransaction.for (srv, ctx._txed_before)
  }
  return RootTransaction.for (srv, RootContext.for(ctx))
}


class Transaction {

  /**
   * Returns an already started tx for given srv, or creates a new instance
   */
  static for (srv,root) {
    let txs = root.transactions
    if (!txs) Object.defineProperty(root, 'transactions', {value: txs = new Map})
    let tx = txs.get (srv)
    if (!tx) txs.set (srv, tx = new this (srv,root))
    return tx
  }

  constructor (srv,root) {
    const tx = _init ({ __proto__:srv, context:root })
    const proto = new.target.prototype
    tx.commit   = proto.commit.bind(tx)
    tx.rollback = proto.rollback.bind(tx)
    return tx
  }

  /**
   * In addition to srv.commit, sets the transaction to committed state,
   * in order to prevent continuous use without explicit reopen (i.e., begin).
   */
  async commit (res) {
    if (this.ready) { //> nothing to do if no transaction started at all
      if (this.__proto__.commit) await this.__proto__.commit.call (this,res)
      _init(this).ready = 'committed'
    }
    return res
  }

  /**
   * In addition to srv.rollback, sets the transaction to rolled back state,
   * in order to prevent continuous use without explicit reopen (i.e., begin).
   */
  async rollback (err) {
    // nothing to do if transaction already rolled back
    if (this.ready === 'rolled back') return

    /*
     * srv.on('error', function (err, req) { ... })
     * synchroneous modification of passed error only
     * err is undefined if nested tx (cf. "root.before ('failed', ()=> this.rollback())")
     */
    if (err) for (const each of this._handlers._error) each.handler.call(this, err, this.context)

    if (this.ready) { //> nothing to do if no transaction started at all
      // don't actually roll back if already committed (e.g., error thrown in on succeeded or on done)
      if (this.ready !== 'committed' && this.__proto__.rollback) await this.__proto__.rollback.call (this,err)
      _init(this).ready = 'rolled back'
    }
    if (err) throw err
  }

}


class RootTransaction extends Transaction {

  /**
   * Register the new transaction with the root context.
   * @param {EventContext} root
   */
  static for (srv,root) {
    return root._tx = super.for (srv,root)
  }

  /**
   * In addition to srv.commit, ensures all nested transactions
   * are informed by emitting 'succeeded' event to them all.
   */
  async commit (res) {
    if (cds_tx_protection) this.context._done = 'committed'
    try {
      await this.context.emit ('commit',res) //> allow custom handlers req.before('commit')
      await super.commit (res)
      await this.context.emit ('succeeded',res)
      await this.context.emit ('done')
    } catch (err) {
      await this.rollback (err)
    }
    return res
  }

  /**
   * In addition to srv.rollback, ensures all nested transactions
   * are informed by emitting 'failed' event to them all.
   */
  async rollback (err) {
    // nothing to do if transaction already rolled back (we need to check here as well to not emit failed twice)
    if (this.ready === 'rolled back') return

    if (cds_tx_protection) this.context._done = 'rolled back'
    try {
      await this.context.emit ('failed',err)
      await super.rollback (err)
    } finally {
      await this.context.emit ('done')
    }
    if (err) throw err
  }
}


class NestedTransaction extends Transaction {

  /**
   * Registers event listeners with the root context, to commit or rollback
   * when the root tx is about to commit or rollback.
   * @param {import ('../req/context')} root
   */
  constructor (srv,root) {
    super (srv,root)
    root.before ('succeeded', ()=> this.commit())
    root.before ('failed', ()=> this.rollback())
    if ('end' in srv) root.once ('done', ()=> srv.end())
  }

}


/**
 * Ensure the service's implementation of .begin is called appropriately
 * before any .dispatch.
 */
const _init = (tx) => {
  if ('begin' in tx) tx.dispatch = _begin
  else tx.ready = true //> to allow subclasses w/o .begin
  return tx
}
const _begin = async function (req) {
  if (!req.query && req.method === 'BEGIN') // IMPORTANT: !req.query is to exclude batch requests
    return this.ready = this.__proto__.dispatch.call (this,req)
  // Protection against unintended tx.run() after tx.commit/rollback()
  if (typeof this.ready === 'string' || !this.ready && this.context._done) {
    if (!cds_tx_protection) this.ready = this.begin() // compatibiliy to former behavior, which allowed tx.run() after commit/rollback
    else throw cds.error (
      `Transaction is ${this.ready || this.context._done}, no subsequent .run allowed, without prior .begin`,
      { code: 'TRANSACTION_CLOSED' }
    )
  }
  else if (!this.ready) this.ready = this.begin()
  await this.ready
  delete this.dispatch
  return this.dispatch (req)
}
