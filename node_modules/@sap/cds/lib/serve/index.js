const cds = require ('..')
const { ProtocolAdapter } = cds.service.adapters
const { Service } = cds.service.factory
const _ready = Symbol(), _pending = cds.services._pending || {}

/** @param som - a service name or a model (name or csn) */
function cds_serve (som, _options) { // NOSONAR

  if (som && typeof som === 'object' && !is_csn(som)) {
    [som,_options] = [undefined,
      som._is_service_instance ? { service:som, from:'*' } :
      som._is_service_class    ? { service:som, from:'*' } :
      som
    ]
  }
  else if (Array.isArray(som) && som.length === 1) som = som[0]
  const o = {..._options} // we must not modify inbound data

  // 1) Use fluent API to fill in remaining options...
  const fluent = {
    from (model)  { o.from = model;    return this },
    with (impl)   { o.with = impl;     return this },
    at (path)     { o.at   = path;     return this },
    to (protocol) { o.to   = protocol; return this },
  }

  // 2) Ensure options are filled in canonically based on defaults
  const options = Promise.resolve(o).then (o => { // noformat
    if (o.service)     { o.from     ||( o.from    = som); return o }
    if (o.from)        { o.service  ||( o.service = som); return o }
    if (som === 'all') { o.service ='all'; o.from = '*' ; return o }
    if (is_csn(som))   { o.service ='all'; o.from = som ; return o }
    if (is_file(som))  { o.service ='all'; o.from = som ; return o }
    if (is_class(som)) { o.service = som;  o.from = '?' ; return o }
    else               { o.service = som;  o.from = '*' ; return o }
  })

  // 3) Load/resolve the model asynchronously...
  const loaded = options.then (async ({from}=o) => {
    if (!from || from === 'all' || from === '*') from = cds.model || '*'
    if (from.definitions) return from
    if (from === '?') try { return await cds.load('*',o) } catch(e){ return }
    return cds.load(from,o)
  })

  // 4) Pass 1: Construct service provider instances...
  const all=[], provided = loaded.then (csn => { // NOSONAR

    // Shortcut for directly passed service instances
    if (o.service && o.service._is_service_instance) {
      return all.push (o.service)
    }

    // Shortcut for directly passed service classes
    if (o.service && o.service._is_service_class) {
      const Service = o.service, d = { name: o.service.name }
      const srv = _new (Service, d,csn,o)
      return all.push (srv)
    }

    // Get relevant service definitions from model...
    let {services} = csn = cds.compile.for.nodejs (csn)
    const required = cds.requires
    if (o.service && o.service !== 'all') {
      // skip services not chosen by o.service, if specified
      const specified = o.service.split(/\s*,\s*/).map (s => required[s] && required[s].service || s )
      services = services.filter (s => specified.some (n => s.name.endsWith(n)))
      if (!services.length) throw cds.error (`No such service: '${o.service}'`)
    }
    services = services.filter (d => !(
      // skip all services marked to be ignored
      d['@cds.ignore'] || d['@cds.serve.ignore'] ||
      // skip external services, unless asked to mock them and unbound
      required[d.name] && (!o.mocked || required[d.name].credentials)
    ))
    if (services.length > 1 && o.at) {
      throw cds.error `You cannot specify 'path' for multiple services`
    }

    // Construct service instances and register them to cds.services
    all.push (...services.map (d => _new (Service,d,csn,o)))
  })

  // 5) Pass 2: Finalize service bootstrapping by calling their impl functions.
  // Note: doing that in a second pass guarantees all own services are in
  // cds.services, so they'll be found when they cds.connect to each others.
  let ready = provided.then (()=> Promise.all (all.map (async srv => {
    if (o.service && o.service._is_service_instance) return srv
    srv.init && await srv.prepend (srv.init)
    srv.options.impl && await srv.prepend (srv.options.impl)
    cds.services[srv.name] = cds.service.paths[srv.path] = srv
    cds.service.providers.push (srv)
    if (srv[_ready]) srv[_ready](srv)
    return srv
  })))


  // 6) Fluent method to serve constructed providers to express app
  fluent.in = (app) => {
    ready = ready.then (()=>{
      const edms = {}
      if (cds.env.features.precompile_edms) { // > unofficial config for eval
        const all = cds.compile.to.edm(cds.model, { service: 'all' })
        for (let [edm,{ file }] of all) edms[file] = edm
      }

      for (let each of all) {
        each._edm = edms[each.name]
        ProtocolAdapter.serve(each,o.to).in(app)
        if (!o.silent) cds.emit ('serving',each)
      }
    })
    return fluent
  }

  // 7) Finally resolve to a single picked provider or a map of all
  fluent.then = (resolve, failed) => ready.then (()=>{
    if (all.length === 0) return resolve()
    let response={}
    for (let each of all) {
      response[each.name] = !each.definition ? each : ProtocolAdapter.serve(each,o.to).asRouter()
    }
    if (all.length === 1 && all[0].name.endsWith (o.service)) {
      response = Object.assign (all[0], response)
    }
    return resolve (response)
  }, failed)
  fluent.catch = (e) => ready.catch(e)

  return fluent
}


function _new (Service, d,m,o) {
  const srv = new Service (d.name,m,o)
  const required = cds.requires[d.name]
  if (required) {
    if (required.name) srv.name = required.name
    if (o.mocked) srv.mocked = true
  }
  if (!srv.path) srv.path = cds.service.path4(srv,o.at)
  _pending[srv.name] = new Promise (r => srv[_ready]=r).finally(()=>{
    delete _pending[srv.name]
    delete srv[_ready]
  })
  return srv
}


const is_csn = x => x && x.definitions
const is_file = x => typeof x === 'string' && !/^[\w$]*$/.test(x)
const is_class = x => typeof x === 'function' && x.prototype && /^class\b/.test(x)

Object.defineProperty (cds_serve, 'path4', { get(){ return cds.service.path4 } })
module.exports = cds_serve
