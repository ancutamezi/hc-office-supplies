const { is_mocha } = support_jest_and_mocha()

class Test extends require('./axios') {

  /**
   * Launches a cds server with arbitrary port and returns a subclass which
   * also acts as an axios lookalike, providing methods to send requests.
   */
  run (cmd='.', ...args) {

    this.cmd = cmd, this.args = args

    // launch cds server...
    before (`launching ${cmd} ${args.join(' ')}...`, () => { // NOSONAR

      const {cds} = this
      if (!/^(serve|run)$/.test(cmd)) try {
        const project = cds.utils.isdir (cmd) || require.resolve (cmd+'/package.json').slice(0,-13)
        cmd='serve'; args.push ('--in-memory?', '--project', project)
      } catch(e) {
        throw cds.error (`No such folder or package '${process.cwd()}' -> '${cmd}'`)
      }

      cds.once ('listening', ({server,url}) => {
        const axp = Reflect.getOwnPropertyDescriptor(this,'axios')
        if (axp) axp.value.defaults.baseURL = url
        this.server = server
        this.url = url
      })

      try { return cds.exec (cmd, ...args, '--port','0') }
      catch (e) { if (is_mocha) console.error(e) } // eslint-disable-line no-console
    })

    // shutdown cds server...
    after (done => {
      this.server ? this.server.close (done) : done && done()
    })

    beforeEach (async () => {
      if (this.data._autoReset)  await this.data.reset()
    })

    return this
  }

  /**
   * Serving projects from subfolders under the root specified by a sequence
   * of path components which are concatenated with path.resolve().
   * Checks conflicts with cds.env loaded in other folder before.
   */
  in (...paths) {
    const {cds} = this; cds.root = require('path').resolve (cds.root, ...paths)
    // const env = Reflect.getOwnPropertyDescriptor(global.cds,'env')
    // if (env && env.value && env.value._home !== cds.root) {
    //   throw new Error (`[cds.test] - 'cds.env' was invoked before 'cds.test.in' from a different home:

    //   cds.env._home: ${cds.env._home}
    //   cds.test.in:   ${cds.root}

    //   > throwing this as tests would likely behave erratically.
    //   `)
    // }
    return this
  }

  /**
   * Switch on/off console log output.
   */
  verbose(v) {
    v === false ? delete process.env.CDS_TEST_VERBOSE : process.env.CDS_TEST_VERBOSE=v
    initLogging()
    return this
  }

  /**  Lazily loads and returns an instance of chai */
  get chai() { return super.chai = load_chai() }
  get expect() { global.describe.each || support_jest_and_mocha(); return this.chai.expect }
  get assert() { global.describe.each || support_jest_and_mocha(); return this.chai.assert }
  get sleep() { return super.sleep = require('util').promisify(setTimeout) }
  get data() { return super.data = new (require('./data'))}
  get cds() { return require('../index') }
  get spy() { return spy }

}

function support_jest_and_mocha() {
  const is_jest = !!global.beforeAll
  const is_mocha = !!global.before
  if (is_mocha) {
    global.beforeAll = global.before
    global.afterAll = global.after
    global.test = global.it
    const { format } = require('util')
    for (let td of [ 'test', 'describe' ]) global[td].each = function(table) {
      return (title,fn) => Promise.all (table.map (each => {
        if (!Array.isArray(each))  each = [each]
        return this (format(title,...each), ()=> fn(...each))
      }))
    }
    after(()=>{
      delete global.cds
      for (let k in require.cache) delete require.cache[k]
    })
  } else if (is_jest) { // it's jest
    global.before = (msg,fn) => global.beforeAll(fn||msg)
    global.after = (msg,fn) => global.afterAll(fn||msg)
  } else { // it's none of both
    global.before = global.beforeAll = (_,fn) => fn()
    global.beforeEach = ()=>{}
    global.afterEach = ()=>{}
    global.after = global.afterAll = (fn) => {
      const repl = global.cds.repl
      repl && repl.on('exit',fn)
    }
    process.env.CDS_TEST_VERBOSE = true
  }
  initLogging()
  return { is_jest, is_mocha }
}

function load_chai() {
  const require = (mod) => { try { return module.require(mod) } catch(e) {
    if (e.code === 'MODULE_NOT_FOUND') throw new Error (`
    Failed to load required package '${mod}'. Please add it thru:
    npm add -D chai chai-as-promised chai-subset
  `)}}
  const chai = require('chai')
  chai.use (require('chai-subset'))
  chai.use (require('chai-as-promised'))
  return chai
}

function initLogging() {
  const levels = process.env.CDS_TEST_VERBOSE
    ? { deploy:'info', serve:'info', server:'info',cds:'info' }
    : { deploy:'warn', serve:'warn', server:'warn',cds:'silent' /* silences provoked request errors */ }

  const env = Reflect.getOwnPropertyDescriptor(global.cds,'env')
  for (const id of Object.keys(levels)) {
    if (env && env.value)
      global.cds.log(id, { level:levels[id] })
    else // uninitialized cds.env -> set env variables to avoid initializing cds.env eagerly
      process.env['cds_log_levels_'+id] = levels[id]
  }
}

const spy = (o,f) => {
  const origin = o[f]
  const fn = function (...args) {
    ++fn.called
    return origin.apply(this,args)
  }
  fn.called = 0
  fn.restore = ()=> o[f] = origin
  return o[f] = fn
}


/** @type Test & ()=>Test */
module.exports = Object.setPrototypeOf ((..._) => (new Test).run(..._), Test.prototype)
