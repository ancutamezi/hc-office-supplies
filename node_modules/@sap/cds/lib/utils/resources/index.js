const fs = require('fs')
const path = require('path')

const cds = require('../../../libx/_runtime/cds')
const { packArchive, packArchiveCLI, unpackArchive, unpackArchiveCLI } = require('./tar')
const { exists } = require('./utils')

// use tar command line interface
const TAR_CLI = true
const TEMP_DIR = fs.realpathSync(require('os').tmpdir())

const findCsvFiles = async (folder, deep = false) => {
  const files = await fs.promises.readdir(folder)
  const result = []

  for (const file of files) {
    const filePath = path.join(folder, file)
    if (deep && (await fs.promises.stat(filePath)).isDirectory()) {
      const files = await findCsvFiles(filePath)
      result.push(...files)
    } else {
      if (path.extname(file) === '.csv') {
        result.push(filePath)
      }
    }
  }

  return result
}

const collectCsvFiles = async sources => {
  const folders = sources.map(file => path.dirname(file))
  const uniqueFolders = [...new Set(folders)].filter(folder => !/node_modules/.test(folder))
  const db = (cds.env.folders && cds.env.folders.db) || 'db/'
  let dbFolder = path.join(global.cds.root, db)
  if (dbFolder.endsWith('/') || dbFolder.endsWith('\\')) dbFolder = dbFolder.slice(0, -1)
  if (!uniqueFolders.includes(dbFolder)) uniqueFolders.push(dbFolder)

  const result = []
  for (const folder of uniqueFolders) {
    const dataPath = path.join(folder, 'data')
    const dataFiles = (await exists(dataPath)) ? await findCsvFiles(dataPath) : []
    const csvPath = path.join(folder, 'csv')
    const csvFiles = (await exists(csvPath)) ? await findCsvFiles(csvPath) : []
    result.push(...dataFiles, ...csvFiles)
  }

  return result
}

const packTarArchive = async (files, root, flat = false, cli = true) => {
  let tgzBuffer, temp

  try {
    temp = await fs.promises.mkdtemp(`${TEMP_DIR}${path.sep}tar-`)
    if (flat) {
      const files_ = []
      for (const file of files) {
        const destination = path.join(temp, path.basename(file))
        await fs.promises.copyFile(file, destination)
        files_.push(destination)
      }
      files = files_
      root = temp
    }

    const relativeFiles = files.map(file => path.relative(root, file))
    if (cli) {
      const output = path.relative(root, path.join(temp, `${cds.utils.uuid()}.tgz`))
      tgzBuffer = await packArchiveCLI(relativeFiles, root, output)
    } else {
      tgzBuffer = await packArchive(relativeFiles, root)
    }
  } finally {
    if (await exists(temp)) {
      await (fs.promises.rm || fs.promises.rmdir)(temp, { recursive: true, force: true })
    }
  }

  return tgzBuffer
}

const unpackTarArchive = async (buffer, folder, cli = true) => {
  const temp = await fs.promises.mkdtemp(`${TEMP_DIR}${path.sep}tar-`)
  const tgz = path.join(temp, 'resources.tgz')
  await fs.promises.writeFile(tgz, buffer, 'binary')

  try {
    cli ? await unpackArchiveCLI(tgz, folder) : await unpackArchive(tgz, folder)
  } finally {
    if (await exists(temp)) await (fs.promises.rm || fs.promises.rmdir)(temp, { recursive: true, force: true })
  }
}

module.exports = {
  TAR_CLI,
  findCsvFiles,
  collectCsvFiles,
  packTarArchive,
  unpackTarArchive
}
