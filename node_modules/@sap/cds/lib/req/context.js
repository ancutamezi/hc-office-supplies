const cds = require ('../index'), { features } = cds.env, { uuid } = cds.utils
const async_events = { succeeded:1, failed:1, done:1 }
const req_locale = require('./locale')
const { EventEmitter } = require('events')

/**
 * This is the base class for `cds.Events` and `cds.Requests`,
 * providing the transaction context nature to all instances.
 * Calling `srv.tx()` without args to start new transacions
 * creates direct instances of this base class.
 */
class EventContext {

  /** Creates a new instance that inherits from cds.context */
  static for (_) {
    const ctx = new this (_)
    if (features.cds_tx_inheritance) {
      const base = cds.context
      if (base) ctx._set('_propagated', base)
    }
    return ctx
  }

  constructor(_={}) {
    Object.defineProperty (this, '_', { value:_, writable:true })
    Object.assign (this, _)
  }

  _set (property, value) {
    Object.defineProperty (this, property, { value, writable:true })
    return value
  }



  //
  // Emitting and listening to succeeded / failed / done events
  //

  get emitter() {
    return this.context._emitter || (this.context._emitter = new EventEmitter)
  }

  async emit (event,...args) {
    const emitter = this.context._emitter; if (!emitter) return
    if (event in async_events)
      for (const each of emitter.listeners(event))
        await each.call (this, ...args)
    else return emitter.emit (event,...args)
  }

  on (event, listener) {
    return this.emitter.on (event, listener.bind(this))
  }

  once (event, listener) {
    return this.emitter.once (event, listener.bind(this))
  }

  before (event, listener) {
    return this.emitter.prependListener (event, listener.bind(this))
  }


  //
  // The following properties are inherited from root contexts, if exist...
  //

  set context(c) { if (c) this._set('context', this._set('_propagated', c)) }
  get context() { return this }

  set id(id) {
    if (id) super.id = id
  }
  get id() {
    return super.id = this._propagated.id || this.headers[ 'x-correlation-id' ] || uuid()
  }

  set tenant(t) {
    if (t) super.tenant = t
  }
  get tenant() {
    return super.tenant = this._propagated.tenant
  }

  set user(u) {
    const user = super.user = u instanceof cds.User ? u : new cds.User(u)
    for (let p of ['tenant','locale']) { // compatibility
      if (u && u.hasOwnProperty(p)) this[p] = u[p] // eslint-disable-line no-prototype-builtins
      else Object.defineProperty (user, p, { get: () => this[p] })
    }
  }
  get user() {
    const u = this._propagated.user
    return this.user = u ? {__proto__:u} : new cds.User.default
  }

  set locale(l) {
    if (l) super.locale = super._locale = l
  }
  get locale() {
    return super.locale = this._propagated.locale || req_locale(this._.req)
  }
  get _locale() {
    return super._locale = this._propagated._locale || req_locale.from_req(this._.req)
    || this.hasOwnProperty('locale') && this.locale // eslint-disable-line no-prototype-builtins
  }

  get timestamp() {
    return super.timestamp = this._propagated.timestamp || new Date
  }

  set headers(h) {
    if (h) super.headers = h
  }
  get headers() {
    if (this._ && this._.req && this._.req.headers) {
      return super.headers = this._.req.headers
    } else {
      const headers={}, outer = this._propagated.headers
      if (outer) for (let each of EventContext.propagateHeaders) {
        if (each in outer) headers[each] = outer[each]
      }
      return super.headers = headers
    }
  }


  set _tx(tx) {
    Object.defineProperty (this,'_tx',{value:tx}) //> allowed only once!
    const ctx = tx.context
    if (ctx && ctx !== this) {
      if (!this.hasOwnProperty('context')) this.context = ctx // eslint-disable-line no-prototype-builtins
      ///////////////////////////////////////////////////////////////////
      // REVISIT: Eliminate req._children
      if (features.assert_integrity !== false) {
        const reqs = ctx._children || ctx._set('_children', {})
        const all = reqs[tx.name] || (reqs[tx.name] = [])
        all.push(this)
      } //////////////////////////////////////////////////////////////////
    }
  }


  /** REVISIT: remove -> @deprecated */
  set _model(m){ super._model = m }
  get _model() {
    return super._model = this._tx && this._tx.model || this._propagated._model
  }
}


EventContext.prototype._set('_propagated', Object.seal({}))
EventContext.propagateHeaders = [ 'x-correlation-id' ]
module.exports = EventContext
