const cds = require('../index'), { EventContext } = cds
const { EventEmitter } = require('events')


/**
 * Continuation Local Storage for cds.context
 */
 exports.for = (cds,v) => {

  if (cds.env.features.cls) {

    const { executionAsyncResource:current, createHook } = module.require ('async_hooks')
    const _context = Symbol('cds.context')

    createHook ({ init(id,t,tid, res) {
      const cr = current(); if (!cr) return
      const ctx = cr[_context]
      if (ctx) res[_context] = ctx
    }}).enable()

    Reflect.defineProperty (cds,'context',{ enumerable:1,
      set(v) {
        const cr = current(); if (!cr) return
        const ctx = (
          v instanceof EventContext || typeof v !== 'object' ? v :
          v.context || EventContext.for (v.req ? {_:v} : v)
        )
        cr[_context] = ctx
      },
      get() {
        const cr = current(); if (!cr) return undefined
        return cr[_context]
      },
    })

  } else {

    Reflect.defineProperty (cds,'context',{ enumerable:1,
      get:()=> undefined,
      set:()=> {},
    })

  }

  return v ? cds.context = v : cds.context
}



exports.spawn = function cds_spawn (o,fn) {

  if (typeof o === 'function') [fn,o] = [o,fn] //> for compatibility
  if (o instanceof cds.EventContext) throw new Error('The passed options must not be an instance of cds.EventContext.')
  else if (!o) o = {}

  const em = new EventEmitter()
  const fx = () => {
    // create a new transaction for each run of the background job
    // which inherits from the current event context by default
    const o2 = { ...o }; delete o2.timestamp //> spawned txes set their own timestamps
    const tx = cds.context = cds.tx(o2)
    const commit = async (res) => {
      await tx.commit()
      for (const handler of em.listeners('succeeded')) await handler(res)
      for (const handler of em.listeners('done')) await handler()
    }
    Promise.resolve().then(() => fn(tx)).then(commit, tx.rollback) .catch (async e => {
      // tx.rollback throws passed error -> we will arrive here for any error
      cds.log().error(`ERROR occured in background job:`, e)
      for (const handler of em.listeners('failed')) await handler(e)
      for (const handler of em.listeners('done')) await handler()
    })
  }

  const timer = (
    (o && o.after) ? setTimeout(fx, o.after) :
    (o && o.every) ? setInterval(fx, o.every) :
    setImmediate(fx)
  )

  return Object.assign (em, { timer })
}
