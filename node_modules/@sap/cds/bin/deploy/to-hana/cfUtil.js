const cp = require('child_process');

const cds = require('../../../lib');
const LOG = cds.log ? cds.log('deploy') : console;
const DEBUG = cds.debug('deploy');

const { bold } = require('../../utils/term');

const CF_COMMAND = 'cf';

const POLL_COUNTER = 40;
const POLL_DELAY = 2500; //ms


class CfUtil {

    _clear() {
        this.spaceInfo = null;
    }

    async _sleep(ms) {
        return new Promise((resolve) => {
            setTimeout(resolve, ms);
        });
    }

    async _cfRun(...args) {
        const cmdLine = `${CF_COMMAND} ${args.join(' ')}`;
        if (DEBUG) {
            console.time(cmdLine);
            LOG.debug('>>> ' + cmdLine);
        }

        try {
            return await new Promise((resolve, reject) => {
                const child = cp.spawn(CF_COMMAND, args);

                let stdout = '';
                child.stdout.on('data', (data) => {
                    stdout += data;
                });

                let stderr = '';
                child.stderr.on('data', (data) => {
                    stderr += data;
                });

                child.on('error', (err) => {
                    DEBUG && LOG.debug(`${stdout}\n${stderr}`);
                    if (err.code === 'ENOENT') {
                        reject(new Error(`Command ${bold(CF_COMMAND)} not found. Make sure to install the Cloud Foundry Command Line Interface.`));
                    } else {
                        reject(err);
                    }
                });

                child.on('close', (code) => {
                    DEBUG && LOG.debug(`${stdout}\n${stderr}`);
                    if (!code) {
                        resolve(stdout.trim());
                    } else {
                        const errorMessage = `${stdout}\n${stderr}`;
                        reject(new Error(errorMessage.trim()));
                    }
                });
            });
        } finally {
            DEBUG && console.timeEnd(cmdLine);
        }
    }

    async _cfRequest(urlPath, queryObj, bodyObj) {
        if (queryObj) {
            const entries = Object.entries(queryObj);
            const queryStr = entries.map((entry) => `${entry[0]}=${encodeURIComponent(entry[1])}`).join('&');
            urlPath = urlPath + `?${queryStr}`;
        }

        // cf curl PATH [-iv] [-X METHOD] [-H HEADER]... [-d DATA] [--output FILE]
        const args = ['curl', urlPath];
        if (bodyObj) {
            args.push('-d');
            args.push(JSON.stringify(bodyObj)); // cfRun uses spawn so no special handling for quotes on cli required
        }

        const response = await this._cfRun(...args);
        const result = response ? JSON.parse(response) : {};
        if (result.errors) {
            const errorMessage = result.errors.map((entry) => `${entry.title}: ${entry.detail} (${entry.code})`).join('\n');
            throw new Error(errorMessage);
        }
        return result;
    }

    _extract(string, pattern, errorMsg) {
        const match = string.match(pattern);
        if (!match || !match[1]) {
            throw new Error(errorMsg);
        }
        return match[1];
    }

    async getCfTargetFromCli() {
        const result = await this._cfRun('target');

        return {
            apiEndpoint: this._extract(result, /api endpoint\s*:\s*(.*)/i, `CF API endpoint is missing. Use 'cf login' to login.`),
            user: this._extract(result, /user\s*:\s*(.*)/i, `CF user is missing. Use 'cf login' to login.`),
            org: this._extract(result, /org\s*:\s*(.*)/i, `CF org is missing. Use 'cf target -o <ORG> to specify.`),
            space: this._extract(result, /space\s*:\s*(.*)/i, `CF space is missing. Use 'cf target -s <SPACE>' to specify.`),
        };
    }

    async getCfSpaceInfo() {
        if (!this.spaceInfo) {
            DEBUG && LOG.debug('getting space info');

            const target = await this.getCfTargetFromCli();

            const { org, space } = target;
            const orgs = await this._cfRequest(`/v3/organizations`, { names: org });
            if (!orgs.resources || orgs.resources.length !== 1) {
                throw new Error(`CF org ${bold(org)} not found!`);
            }

            const orgGuid = orgs.resources[0].guid;
            const spaces = await this._cfRequest(`/v3/spaces`, { names: space, organization_guids: orgGuid });
            if (!spaces.resources || spaces.resources.length !== 1) {
                throw new Error(`CF space ${bold(space)} not found in org ${bold(org)}!`);
            }

            const spaceGuid = spaces.resources[0].guid;

            this.spaceInfo = Object.assign({}, target, { orgGuid, spaceGuid });
        }

        return this.spaceInfo;
    }

    async getService(serviceName, showMessage = true) {
        showMessage && LOG.log(`Getting service ${bold(serviceName)}`);
        const spaceInfo = await this.getCfSpaceInfo();

        let counter = POLL_COUNTER;
        while (counter > 0) {
            counter--;
            const serviceInstances = await this._cfRequest('/v3/service_instances', {
                names: serviceName,
                space_guids: spaceInfo.spaceGuid,
                organization_guids: spaceInfo.orgGuid
            });
            if (!serviceInstances || !serviceInstances.resources || serviceInstances.resources.length < 1) {
                return null;
            }

            const serviceInstance = serviceInstances.resources[0];
            if (serviceInstance && serviceInstance.last_operation && serviceInstance.last_operation.state !== 'in progress') {
                return serviceInstance;
            }

            await this._sleep(POLL_DELAY);
        }

        throw new Error(`Timeout occurred while getting service ${bold(serviceName)}`);
    }


    async getOrCreateService(serviceOfferingName, planName, serviceName, options) {

        const probeService = await this.getService(serviceName, false);
        if (probeService) {
            LOG.log(`Getting service ${bold(serviceName)}`);
            return probeService;
        }

        LOG.log(`Creating service ${bold(serviceName)} - please be patient...`);

        const spaceInfo = await this.getCfSpaceInfo();

        const servicePlan = await this._cfRequest(`/v3/service_plans`, {
            names: planName,
            space_guids: spaceInfo.spaceGuid,
            organization_guids: spaceInfo.orgGuid,
            service_offering_names: serviceOfferingName
        });

        if (!servicePlan.resources || servicePlan.resources.length === 0) {
            throw new Error(`No service plans found`);
        }

        const body = {
            type: 'managed',
            name: serviceName,
            tags: [serviceOfferingName],
            relationships: {
                space: {
                    data: {
                        guid: spaceInfo.spaceGuid
                    }
                },
                service_plan: {
                    data: {
                        guid: servicePlan.resources[0].guid
                    }
                }
            }
        }

        if (options) {
            body.parameters = { ...options };
        }

        const postResult = await this._cfRequest('/v3/service_instances', undefined, body);
        if (postResult.errors) {
            throw new Error(postResult.errors[0].detail);
        }

        const newService = await this.getService(serviceName, false);
        if (newService) {
            return newService;
        }

        throw new Error(`Could not create service ${bold(serviceName)}`);
    }


    async getServiceKey(serviceInstance, serviceKeyName, showMessage = true) {
        showMessage && LOG.log(`Getting service key ${bold(serviceKeyName)}`);

        let counter = POLL_COUNTER;
        while (counter > 0) {
            counter--;
            const bindings = await this._cfRequest(`/v3/service_credential_bindings`, { names: serviceKeyName, service_instance_guids: serviceInstance.guid });
            if (!bindings || !bindings.resources || bindings.resources.length < 1) {
                return null;
            }
            const binding = bindings.resources[0];
            if (binding && binding.last_operation && binding.last_operation.state !== 'in progress') {
                const keyDetails = await this._cfRequest(`/v3/service_credential_bindings/${encodeURIComponent(binding.guid)}/details`);
                return keyDetails.credentials;
            }

            await this._sleep(POLL_DELAY);
        }

        throw new Error(`Timeout occurred while getting service key ${bold(serviceKeyName)}`);
    }


    async getOrCreateServiceKey(serviceInstance, serviceKeyName) {

        const serviceKey = await this.getServiceKey(serviceInstance, serviceKeyName, false);
        if (serviceKey) {
            LOG.log(`Getting service key ${bold(serviceKeyName)}`);
            return serviceKey;
        }

        LOG.log(`Creating service key ${bold(serviceKeyName)} - please be patient...`);

        const body = {
            type: 'key',
            name: serviceKeyName,
            relationships: {
                service_instance: {
                    data: {
                        guid: serviceInstance.guid
                    }
                }
            },
            parameters: {
                permissions: 'development'
            }
        }

        const postResult = await this._cfRequest('/v3/service_credential_bindings', undefined, body);
        if (postResult.errors) {
            throw new Error(postResult.errors[0].detail);
        }

        const newServiceKey = await this.getServiceKey(serviceInstance, serviceKeyName, false);
        if (newServiceKey) {
            return newServiceKey;
        }

        throw new Error(`Could not create service key ${bold(serviceKeyName)}`);
    }
}

module.exports = new CfUtil();
