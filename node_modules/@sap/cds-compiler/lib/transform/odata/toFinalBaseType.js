'use strict';

const {
  forEachDefinition, forEachMemberRecursively,
  isBuiltinType, cloneCsnDictionary, cloneCsnNonDict,
} = require('../../model/csnUtils');
const { isArtifactInSomeService, isArtifactInService } = require('./utils');

function expandToFinalBaseType(csn, transformers, csnUtils, services, options, isExternalServiceMember) {
  const isV4 = options.toOdata.version === 'v4';
  forEachDefinition(csn, (def, defName) => {
    // Unravel derived type chains to final one for elements, actions, action parameters (propagating annotations)
    forEachMemberRecursively(def, (member) => {
      expandToFinalBaseType(member, defName);
      expandToFinalBaseType(member.items, defName);
      expandToFinalBaseType(member.returns, defName);
      expandToFinalBaseType(member.returns && member.returns.items, defName);

    }, ['definitions', defName]);

    expandToFinalBaseType(def, defName);
    expandToFinalBaseType(def.items, defName);
    expandToFinalBaseType(def.returns, defName);
    expandToFinalBaseType(def.returns && def.returns.items, defName);

    // If the definition('def' variable) is a type definition and the assigned type of this very same definition('def' variable)
    // is structured type, e.g.:
    //
    // type Struct1 {
    //    a : Integer;
    //    b : Integer;
    //  };
    // type Struct2: Struct1;
    // after compilation the csn looks like this:
    // ...
    // "S.Struct1": {
    //   "kind": "type",
    //   "elements": {
    //     "a": { "type": "cds.Integer" },
    //     "b": { "type": "cds.Integer" }
    //   } },
    // "S.Struct2": {
    //   "kind": "type",
    //   "type": "S.Struct1",
    //   "elements": {
    //     "a": { "type": "cds.Integer" },
    //     "b": { "type": "cds.Integer" }
    //   } } ...
    //
    // "S.Struct2" should looks just like "S.Struct1" => the "type": "S.Struct1" property has to be removed
    if (def.kind === 'type' && def.type && !isBuiltinType(def.type) && !def.type.ref) {
      // elements are already there -> do not show the type
      delete def.type;
    }
    // TODO: this is more types exposure related, check and move
    // In case we have in the model something like:
    // type Foo: array of Bar; type Bar: { qux: Integer };
    // In the type Foo we expand the first level of elements of the items or
    // type Foo: array of { qux: Integer };
    if (def.kind === 'type' && def.items && isArtifactInSomeService(defName, services)) {
      expandFirstLevelOfArrayed(def);
    }
  }, { skipArtifact: isExternalServiceMember });

  // In case we have in the model something like:
  // type Foo: array of Bar; type Bar: { qux: Integer };
  // In the type Foo we expand the first level of elements of the items like we have in CDL this:
  // type Foo: array of { qux: Integer };
  function expandFirstLevelOfArrayed(def) {
    if (def.items.type && !isBuiltinType(def.items.type)) {
      let finalType = csnUtils.getFinalTypeDef(def.items.type);
      if (csnUtils.isStructured(finalType)) {
        def.items.elements = cloneCsnDictionary(finalType.elements, options);
        delete def.items.type;
      }
    }
  }

  function expandToFinalBaseType(node, defName) {
    if (!node) return;
    // TODO: Clarify how should events be handled?
    // They are not treated by the transformUtilsNew::toFinalBaseType function
    // in the same manner as named types, because the elements of structured events are not
    // propagated as it is with types.
    // It is ok to skip the expansion to the final base type for now as events are not rendered in
    // EDMX at the moment and the reference in the OData CSN is fulfilled.
    if (node.kind === 'event') return;

    // elements have precedence over type
    if (node.type && (!isBuiltinType(node.type) &&isExpandable(node, defName) || node.kind === 'type')) {
      // 1. Get the final type of the node (resolve derived type chain)
      const finalType = csnUtils.getFinalBaseType(node.type);
      if (finalType) {
        // The type replacement depends on whether 'node' is a definition or a member[element].
        if (node.kind) {
          // It is a definition and we expand to builtin type and to elements
          // type T: S; --> Integer;
          // type S: X; --> Integer;
          // type X: Integer;
          //
          // type A: B; -> {...}
          // type B: C; -> { ... }
          // type C { .... };
          if (isBuiltinType(finalType)) {
            // use transformUrilsNew::toFinalBaseType for the moment,
            // as it is collects along the chain of types
            // attributes that need to be propagated
            // enum, length, scale, etc.
            transformers.toFinalBaseType(node);
            // node.type = finalType;
          }
          else if (csnUtils.isStructured(finalType)) {
            cloneElements(finalType);
          }
          else if (node.type && node.items)
            delete node.type;
        }
        else {
          // this is a member and we expand to final base only if builtin
          //  type T: S; --> Integer;
          //  type S: X; --> Integer;
          //  type X: Integer;
          //
          //  type {
          //    struct_elt: many A; ---> stays the same
          //    scalar_elt: T; ---> Integer;
          //    type_ref_elt: type of struct_elt;
          //  };
          //  type A: B; -> {...}
          //  type B: C; -> { ... }
          //  type C { .... };
          if (isBuiltinType(finalType)) {
            // use transformUrilsNew::toFinalBaseType for the moment,
            // as it is collects along the chain of types
            // attributes that need to be propagated
            // enum, length, scale, etc.
            transformers.toFinalBaseType(node);
            // node.type = finalType;
          }
          else if (node.type && node.type.ref) {
            cloneElements(finalType);
          }
        }
      }
    }
    if (node.type && !isBuiltinType(node.type)) {
        // handle array of defined via a named type
        // example in actions: 'action act() return Primitive; type Primitive: array of String;'
      const currService = csnUtils.getServiceName(defName);
      const finalType = csnUtils.getFinalTypeDef(node.type);
      if (finalType.items && isBuiltinType(finalType.items.type)) {
        if (!isArtifactInService(node.type, currService) || !isV4) {
          node.items = finalType.items;
          delete node.type;
        }
      }
    }

    function cloneElements(finalType) {
      // cloneCsn only works correctly if we start "from the top"
      let clone;
      // do the clone only if really needed
      if((finalType.items && !node.items) ||
         (finalType.elements && !node.elements))
        clone = cloneCsnNonDict({ definitions: { 'TypeDef': finalType } }, options);
      if (finalType.items) {
        delete node.type;
        if(!node.items)
          Object.assign(node, { items: clone.definitions.TypeDef.items });
      }
      if (finalType.elements) {
        if(!finalType.items)
          delete node.type;
        if(!node.elements)
          Object.assign(node, { elements: clone.definitions.TypeDef.elements });
      }
    }
  }

  function isExpandable(node, defName) {
    return !isV4 || !isUserDefinedBuiltinFromTheCurrService(node, defName);
  }

  function isUserDefinedBuiltinFromTheCurrService(node, defName) {
    // in V4 we should use TypeDefinitions whenever possible, thus in case the final type of a field is
    // a builtin from the service - do not expand to the final base type
    let finalBaseType = csnUtils.getFinalBaseType(node.type);
    // if (finalBaseType && finalBaseType.items) finalBaseType = csnUtils.getFinalBaseType(finalBaseType.items);
    const currService = csnUtils.getServiceName(defName);
    return node.type && !node.type.ref
      && isBuiltinType(finalBaseType) && !csnUtils.isAssocOrComposition(finalBaseType)
      && isArtifactInService(node.type, currService);
  }
}

module.exports = expandToFinalBaseType;
