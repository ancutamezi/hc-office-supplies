'use strict';

const {
  forEachGeneric, forEachMemberRecursively, hasAnnotationValue, isPersistedOnDatabase,
  getUtils,
} = require('../../model/csnUtils');
const transformUtils = require('../transformUtilsNew');

const exists = '@cds.persistence.exists';

/**
 * Return a callback function for forEachDefinition that marks artifacts that are abstract or @cds.persistence.exists/skip
 * with _ignore.
 *
 * @returns {(artifact: CSN.Artifact, artifactName) => void} Callback function for forEachDefinition
 */
function getAnnoProcessor() {
  return handleCdsPersistence;
  /**
   * @param {CSN.Artifact} artifact
   */
  function handleCdsPersistence(artifact) {
    const ignoreArtifact = (artifact.kind === 'entity') &&
                           (artifact.abstract ||
                            hasAnnotationValue(artifact, '@cds.persistence.skip') ||
                            hasAnnotationValue(artifact, exists));
    if (ignoreArtifact)
      artifact._ignore = true;
  }
}

/**
 * Return a callback function for forEachDefinition that marks associations with _ignore
 * if their target does not reach the database, i.e. marked with @cds.persistence.skip or is abstract
 *
 * @param {CSN.Model} csn
 * @param {CSN.Options} options
 * @param {object} messageFunctions
 * @param {Function} messageFunctions.info
 * @returns {(artifact: CSN.Artifact, artifactName: string, prop: string, path: CSN.Path) => void} Callback function for forEachDefinition
 */
function getAssocToSkippedIgnorer(csn, options, messageFunctions) {
  const { info } = messageFunctions;
  const doA2J = !(options.transformation === 'hdbcds' && options.sqlMapping === 'hdbcds');

  const { isAssocOrComposition } = getUtils(csn);

  return ignoreAssociationToSkippedTarget;
  /**
   * Associations that target a @cds.persistence.skip artifact must be removed
   * from the persistence model
   *
   * @param {CSN.Artifact} artifact
   * @param {string} artifactName
   * @param {string} prop
   * @param {CSN.Path} path
   */
  function ignoreAssociationToSkippedTarget(artifact, artifactName, prop, path) {
    if (isPersistedOnDatabase(artifact)) {
      // TODO: structure in CSN is artifact.query.[SELECT/SET].mixin
      if (artifact.query) {
        // If we do A2J, we don't need to check the mixin. Either it is used -> a join
        // or published -> handled via elements/members. Unused mixins are removed anyway.
        if (!doA2J && artifact.query.SELECT && artifact.query.SELECT.mixin)
          forEachGeneric(artifact.query.SELECT, 'mixin', ignore, path.concat([ 'query', 'SELECT' ]));

        else if (!doA2J && artifact.query.SET && artifact.query.SET.mixin)
          forEachGeneric(artifact.query.SET, 'mixin', ignore, path.concat([ 'query', 'SET' ]));
      }
      forEachMemberRecursively(artifact, ignore, [ 'definitions', artifactName ]);
    }
  }

  /**
   * Mark the given member with _ignore if it is an association/composition and it's target is unreachable.
   *
   * @param {CSN.Element} member
   * @param {string} memberName
   * @param {string} prop
   * @param {CSN.Path} path
   * @todo Why do we check for @cds.persistence.exists here if the parent-function only calls this for skip/abstract?
   */
  function ignore(member, memberName, prop, path) {
    if (options.sqlDialect === 'hana' && !member._ignore && member.target && isAssocOrComposition(member.type) && isUnreachableAssociationTarget(csn.definitions[member.target])) {
      const targetAnnotation = hasAnnotationValue(csn.definitions[member.target], exists) ? exists : '@cds.persistence.skip';
      info(null, path,
           { target: member.target, anno: targetAnnotation },
           'Association has been removed as it\'s target $(TARGET) is annotated with $(ANNO)');
      member._ignore = true;
    }
  }

  /**
   * Check whether the given artifact is an unreachable association target because it will not "realy" hit the database:
   * - @cds.persistence.skip/exists
   * - abstract
   *
   * @param {CSN.Artifact} art
   * @returns {boolean}
   */
  function isUnreachableAssociationTarget(art) {
    return !isPersistedOnDatabase(art) || hasAnnotationValue(art, exists);
  }
}

/**
 * Return a callback function for forEachDefinition that handles artifacts marked with @cds.persistence.table.
 * If a .query artifact has this annotation, the .query will be deleted and it will be treated like a table.
 *
 * @param {CSN.Model} csn
 * @param {CSN.Options} options
 * @param {object} messageFunctions
 * @param {Function} messageFunctions.error
 * @returns {(artifact: CSN.Artifact, artifactName) => void} Callback function for forEachDefinition
 */
function getPersistenceTableProcessor(csn, options, messageFunctions ) {
  const { error } = messageFunctions;
  const {
    recurseElements,
  } = transformUtils.getTransformers(csn, options, '_');

  return handleQueryish;


  /**
   * @param {CSN.Artifact} artifact
   * @param {string} artifactName
   */
  function handleQueryish(artifact, artifactName) {
    const stripQueryish = artifact.query && hasAnnotationValue(artifact, '@cds.persistence.table');

    if (stripQueryish) {
      artifact.kind = 'entity';
      delete artifact.query;

      recurseElements(artifact, [ 'definitions', artifactName ], (member, path) => {
        // All elements must have a type for this to work
        if (!member._ignore && !member.kind && !member.type)
          error(null, path, 'Expecting element to have a type if view is annotated with “@cds.persistence.table“');
      });
    }
  }
}


module.exports = {
  getAnnoProcessor,
  getAssocToSkippedIgnorer,
  getPersistenceTableProcessor,
};
