'use strict';

const keywords = require('../base/keywords');
const { getLastPartOf } = require('../model/csnUtils');
const { isBuiltinType, generatedByCompilerVersion, getNormalizedQuery } = require('../model/csnUtils');
const { renderFunc, findElement, getExpressionRenderer } = require('./utils/common');
const { escapeString, hasUnpairedUnicodeSurrogate } = require('./utils/stringEscapes');
const { checkCSNVersion } = require('../json/csnVersion');
const { timetrace } = require('../utils/timetrace');
const { csnRefs } = require('../model/csnRefs');
const { forEachDefinition } = require('../model/csnUtils');
const enrichUniversalCsn = require('../transform/universalCsn/universalCsnEnricher');
const { isBetaEnabled } = require('../base/model');
const { ModelError } = require('../base/error');
const { typeParameters } = require('../compiler/builtins');
const { forEach } = require('../utils/objectUtils');

/**
 * Render the CSN model 'model' to CDS source text.
 * Returned object has the following properties:
 *  - `model`: CSN model rendered as CDL (string).
 *  - [csn.namespace]: Namespace statement + `using from './model.cds'.
 *  - `unappliedExtensions`: Annotations / Extensions from the `csn.extensions` array.
 *
 * @param {CSN.Model} csn
 * @param {CSN.Options} [options]
 */
function toCdsSourceCsn(csn, options) {
  timetrace.start('CDL rendering');
  const { artifactRef } = csnRefs(csn);
  let _renderExpr = null;

  if (options.csnFlavor === 'universal' && isBetaEnabled(options, 'enableUniversalCsn'))
    enrichUniversalCsn(csn, options);

  checkCSNVersion(csn, options);

  const cdlResult = Object.create(null);
  cdlResult.model = options.testMode ? '' : `// ${generatedByCompilerVersion()} \n`;

  const subelementAnnotates = [];

  cdlResult.model += renderDefinitions();
  // sub-element annotations that can't be written directly.
  cdlResult.model += renderExtensions(subelementAnnotates, createEnv());

  if (csn.vocabularies)
    cdlResult.model += renderVocabularies(csn.vocabularies);

  if (csn.namespace) {
    cdlResult[csn.namespace] = `namespace ${renderArtifactName(csn.namespace)};\n`;
    cdlResult[csn.namespace] += 'using from \'./model.cds\';';
  }

  // If there are extensions, such as 'extend' and 'annotate' statements, render them separately.
  // Used for e.g. parseCdl-style CSN or Universal CSN.
  if (csn.extensions)
    cdlResult.unappliedExtensions = renderExtensions(csn.extensions, createEnv());

  timetrace.stop();
  return cdlResult;

  /**
   * Render entries from the `csn.definitions` dictionary.
   * Returns an empty string if nothing is rendered.
   *
   * @return {string}
   */
  function renderDefinitions() {
    let result = '';
    const env = createEnv();
    forEachDefinition(csn, (artifact, artifactName) => {
      const sourceStr = renderArtifact(artifactName, artifact, env);
      if (sourceStr !== '')
        result += `${sourceStr}\n`;
    });
    return result;
  }

  /**
   * Render annotation definitions, i.e. entries from csn.vocabularies.
   * Returns an empty string if there isn't anything to render.
   *
   * @param {object} vocabularies
   * @return {string}
   */
  function renderVocabularies(vocabularies) {
    let result = '';
    forEach(vocabularies, renderVocabulariesEntry);
    return result;

    function renderVocabulariesEntry(name, anno) {
      if (!anno._ignore) {
        // This environment is passed down the call hierarchy, for dealing with
        // indentation and name resolution issues
        const env = createEnv();
        const sourceStr = renderTypeOrAnnotation(name, anno, env, 'annotation');
        result += `${sourceStr}\n`;
      }
    }
  }

  /**
   * Render 'extend' and 'annotate' statements from the `extensions` array.
   * Could be annotate-statements for sub-elements annotations or from parseCdl's
   * extensions array or just unapplied extensions.
   *
   * @param {CSN.Extension[]} extensions
   * @param {CdlRenderEnvironment} env
   * @return {string}
   */
  function renderExtensions(extensions, env) {
    return extensions.map(ext => renderExtension(ext, env)).join('\n');
  }

  /**
   * Render an 'extend' and 'annotate' statement.
   *
   * @param {CSN.Extension} ext
   * @param {CdlRenderEnvironment} env
   * @return {string}
   */
  function renderExtension(ext, env) {
    if (ext.extend)
      return renderExtendStatement(ext.extend, ext, env);
    return renderAnnotateStatement(ext, env);
  }

  /**
   * Render an 'extend' statement.
   * `extName` is the extension's artifact's name, most likely `ext.extend`.
   * This function is recursive, which is why you need to pass it explicitly.
   *
   * @param {string} extName
   * @param {object} ext
   * @param {CdlRenderEnvironment} env
   * @return {string}
   */
  function renderExtendStatement(extName, ext, env) {
    extName = renderArtifactName(extName);
    // Element extensions have `kind` set.
    const isElementExtend = (ext.kind === 'extend');
    let result = renderAnnotationAssignmentsAndDocComment(ext, env);

    if (ext.includes && ext.includes.length > 0) {
      // Includes can't be combined with anything in braces {}.  Multiple includes
      // are possible through CSN, but in CDL, only one include at once is possible.
      const affix = isElementExtend ? 'element ' : '';
      for (const id of ext.includes)
        result += `${env.indent}extend ${affix}${extName} with ${quoteIdIfRequired(id)};\n`;
      return result;
    }

    // We have the "old-style" prefix syntax and the "new-style" postfix "with <type>" syntax.
    // The former one can not only extend (sub-)elements but also actions in the same statement whereas
    // the latter cannot.
    // If there are actions, check if there are also elements/columns, and if so, use the prefix notation.
    const usePrefixNotation = isElementExtend || ext.actions && (ext.columns || ext.elements);
    if (usePrefixNotation)
      result += `${env.indent}extend ${getExtendPrefixVariant(ext)} ${extName} with {\n`;
    else
      result += `${env.indent}extend ${extName} with ${getExtendPostfixVariant(ext)} {\n`;

    if (ext.columns) {
      result += renderViewColumns(ext.columns, increaseIndent(env));
    }
    else if (ext.elements) {
      result += renderExtendStatementElements(ext, env);
    }
    else if (ext.enum) {
      const childEnv = increaseIndent(env);
      forEach(ext.enum, (name, value) => {
        result += renderEnumElement(name, value, childEnv);
      });
    }

    // Not part of if/else cascade, because it may be in postfix notation.
    if (ext.actions) {
      // TODO: Merge with renderActionsAndFunctions() -> requires removal of static `with actions`
      const childEnv = increaseIndent(env);
      let actions = '';
      forEach(ext.actions, (actionName, action) => {
        actions += renderActionOrFunction(actionName, action, childEnv);
      });
      if (!usePrefixNotation)
        result += actions;
      else if (actions !== '')
        result += `${env.indent}} actions {\n${actions}`;
    }

    result += `${env.indent}};\n`;
    return result;
  }

  /**
   * What <extend> prefix type to use.  Used to render `extend <type> <ref>` statements.
   *
   * @param {object} ext
   * @return {string}
   */
  function getExtendPrefixVariant(ext) {
    if (ext.kind === 'extend')
      return 'element'; // element extensions inside an `extend`
    if (ext.columns)
      return 'projection';
    if (ext.elements)
      return 'entity';
    return '';
  }

  /**
   * What <extend> postfix type to use.  Used to render `extend <ref> with <type>` statements.
   *
   * @param {CSN.Extension} ext
   * @return {string}
   */
  function getExtendPostfixVariant(ext) {
    if (ext.columns)
      return 'columns';
    if (ext.actions)
      return 'actions';
    if (ext.elements)
      return 'elements';
    if (ext.enum)
      return 'enum';
    return '';
  }

  /**
   * Render the elements inside an `extend` statement. They may themselves be `extend` statements.
   *
   * @param {CSN.Extension} ext
   * @param {CdlRenderEnvironment} env
   * @return {string}
   */
  function renderExtendStatementElements(ext, env) {
    let result = '';
    forEach(ext.elements || {}, (elemName, element) => {
      if (element.kind === 'extend')
        result += renderExtendStatement(elemName, element, increaseIndent(env));
      else
        // As soon as we are inside an element, nested `extend` are not possible,
        // since we can't extend an existing element of a new one.
        result += renderElement(elemName, element, increaseIndent(env), true);
    });
    return result;
  }

  /**
   * Render an 'annotate' statement.
   *
   * @param {CSN.Extension} ext
   * @param {CdlRenderEnvironment} env
   * @return {string}
   */
  function renderAnnotateStatement(ext, env) {
    // Top-level annotations of the artifact
    let result = renderAnnotationAssignmentsAndDocComment(ext, env);
    result += `${env.indent}annotate ${renderArtifactName(ext.annotate)}`;

    if (ext.params)
      result += renderAnnotateParamsInParentheses(ext.params, env);

    // Element extensions and annotations (possibly nested)
    if (ext.elements)
      result += renderAnnotateStatementElements(ext.elements, env);

    // Returns annotations
    if (ext.returns) {
      const childEnv = increaseIndent(env);
      result += ` returns${renderAnnotateStatementElements(ext.returns.elements, childEnv)}`;
    }

    // Action annotations
    if (ext.actions) {
      result += ' actions {\n';
      const childEnv = increaseIndent(env);
      for (const name in ext.actions) {
        const action = ext.actions[name];
        result += renderAnnotationAssignmentsAndDocComment(action, childEnv) + childEnv.indent + quoteIdIfRequired(name);
        // Action parameter annotations
        if (action.params)
          result += renderAnnotateParamsInParentheses(action.params, childEnv);

        // Annotations on action returns
        if (action.returns && action.returns.elements) {
          const grandChildEnv = increaseIndent(childEnv);
          result += ` returns${renderAnnotateStatementElements(action.returns.elements, grandChildEnv)}`;
        }

        result += ';\n';
      }
      result += `${env.indent}}`;
    }


    result += ';\n';
    return result;
  }

  /**
   * Render the elements-specific part of an 'annotate' statement for an element dictionary
   * 'elements' (assuming that the surrounding parent has just been rendered, without trailing newline).
   * Returns the resulting source string, ending without a trailing newline.
   *
   * @param {CSN.Elements} elements
   * @param {CdlRenderEnvironment} env
   * @return {string}
   */
  function renderAnnotateStatementElements(elements, env) {
    let result = ' {\n';
    const childEnv = increaseIndent(env);
    for (const name in elements) {
      const elem = elements[name];
      result += renderAnnotationAssignmentsAndDocComment(elem, childEnv) + childEnv.indent + quoteIdIfRequired(name);
      if (elem.elements)
        result += renderAnnotateStatementElements(elem.elements, childEnv);

      result += ';\n';
    }
    result += `${env.indent}}`;
    return result;
  }

  /**
   * Render a parameter list for `annotate` statements, in parentheses `()`.
   *
   * @param {object} params
   * @param {CdlRenderEnvironment} env
   * @return {string}
   */
  function renderAnnotateParamsInParentheses(params, env) {
    const childEnv = increaseIndent(env);
    let result = '(\n';
    const paramAnnotations = [];
    forEach(params, (paramName, param) => {
      paramAnnotations.push( renderAnnotationAssignmentsAndDocComment(param, childEnv) + childEnv.indent + quoteIdIfRequired(paramName) );
    });
    result += `${paramAnnotations.join(',\n')}\n${env.indent})`;
    return result;
  }

  /**
   * Render an artifact. Return the resulting source string.
   *
   * @param {string} artifactName
   * @param {CSN.Artifact} art
   * @param {CdlRenderEnvironment} env
   */
  function renderArtifact(artifactName, art, env) {
    // FIXME: Correctly build the paths during runtime to give better locations
    env.path = [ 'definitions', artifactName ];
    env.artifactName = artifactName;

    switch (art.kind) {
      case 'entity':
        if (art.query || art.projection)
          return renderView(artifactName, art, env);

        return renderEntity(artifactName, art, env);

      case 'context':
      case 'service':
        return renderContext(artifactName, art, env);
      case 'type':
      case 'aspect':
      case 'annotation':
        return renderTypeOrAnnotation(artifactName, art, env, art.$syntax);
      case 'action':
      case 'function':
        return renderActionOrFunction(artifactName, art, env);
      case 'event':
        return renderEvent(artifactName, art, env);
      default:
        throw new ModelError(`Unknown artifact kind: ${art.kind}`);
    }
  }

  /**
   * @param {string} artifactName
   * @param {CSN.Artifact} art
   * @param {CdlRenderEnvironment} env
   */
  function renderEvent(artifactName, art, env) {
    let result = renderAnnotationAssignmentsAndDocComment(art, env);
    const childEnv = increaseIndent(env);
    const normalizedArtifactName = renderArtifactName(artifactName);
    result += `${env.indent}event ${normalizedArtifactName}`;
    if (art.includes)
      result += renderIncludes(art.includes);
    if (art.query || art.projection) {
      env._artifact = art;
      result += ' : ';
      result += renderQuery(getNormalizedQuery(art).query, true, 'projection', env,
                            [ 'definitions', artifactName, 'query' ]);
      result += ';\n';
      delete env._artifact;
    }
    else if (art.type) {
      // Derived type or annotation with non-anonymous type
      result += ` : ${renderTypeReference(art, env)};\n`;
    }
    else if (art.elements) {
      result += ' {\n';
      for (const name in art.elements)
        result += renderElement(name, art.elements[name], childEnv);

      result += `${env.indent}}`;
    }
    return result;
  }

  /**
   * Render a context or service. Return the resulting source string.
   *
   * @param {string} artifactName
   * @param {CSN.Artifact} art
   * @param {CdlRenderEnvironment} env
   */
  function renderContext(artifactName, art, env) {
    let result = renderAnnotationAssignmentsAndDocComment(art, env);
    result += `${env.indent + (art.abstract ? 'abstract ' : '') + art.kind} ${renderArtifactName(artifactName)}`;
    if (art.includes)
      result += renderIncludes(art.includes);

    return `${result} {};\n`;
  }

  /**
   * Render a (non-projection, non-view) entity. Return the resulting source string.
   *
   * @param {string} artifactName
   * @param {CSN.Artifact} art
   * @param {CdlRenderEnvironment} env
   * @return {string}
   */
  function renderEntity(artifactName, art, env) {
    let result = renderAnnotationAssignmentsAndDocComment(art, env);
    const childEnv = increaseIndent(env);
    const normalizedArtifactName = renderArtifactName(artifactName);
    result += `${env.indent + (art.abstract ? 'abstract ' : '')}entity ${normalizedArtifactName}`;
    const parameters = Object.keys(art.params || []).map(name => renderParameter(name, art.params[name], childEnv)).join(',\n');
    result += (parameters === '') ? '' : ` (\n${parameters}\n${env.indent})`;
    if (art.includes)
      result += renderIncludes(art.includes);
    result += ' {\n';
    for (const name in art.elements) {
      const element = art.elements[name];
      // For subelement annotations, this seems to be a pattern to recognize them
      // plus some other stuff unfortunately...
      if (element.type && element.elements) {
        subelementAnnotates.push({
          annotate: artifactName,
          elements: {
            [name]: {
              elements: element.elements,
            },
          },
        });
      }
      result += renderElement(name, element, childEnv);
    }

    result += `${env.indent}}`;
    result += `${renderActionsAndFunctions(art, env)};\n`;
    return result;
  }

  /**
   * Render an element (of an entity, type or annotation, not a projection or view).
   * Return the resulting source string.
   *
   * @param {string} elementName
   * @param {CSN.Element} elm
   * @param {CdlRenderEnvironment} env
   * @param {Boolean} [isSubElement]
   */
  function renderElement(elementName, elm, env, isSubElement) {
    env.elementName = elementName;
    let result = renderAnnotationAssignmentsAndDocComment(elm, env);
    const quotedElementName = quoteIdIfRequired(elementName);
    result += `${env.indent + (elm.virtual ? 'virtual ' : '') +
                         (elm.key && !isSubElement ? 'key ' : '') +
                         ((elm.masked && !elm._ignoreMasked) ? 'masked ' : '') +
                         quotedElementName} : ${
      renderTypeReference(elm, env, undefined)
    }${elm.on ? '' : renderNullability(elm)}`;
    if (elm.default)
      result += ` default ${renderExpr(elm.default, env)}`;

    delete env.elementName;
    return `${result};\n`;
  }

  /**
   * Render a query's actions and functions (if any) separately as extend-statements, so that actions
   * work not only for projections but also for views, which have no syntax (yet) to directly specify
   * actions and functions inline.
   * Return the resulting 'extend' statement or '' if no actions or functions
   * FIXME: Simplify once we have such a syntax
   *
   * @param {string} artifactName
   * @param {CSN.Artifact} art
   * @param {CdlRenderEnvironment} env
   * @return {string}
   */
  function renderQueryActionsAndFunctions(artifactName, art, env) {
    let result = renderActionsAndFunctions(art, env);
    // Even if we have seen actions/functions, they might all have been ignored
    if (result !== '')
      result = `${env.indent}extend entity ${artifactName} with${result};`;

    return result;
  }

  /**
   * Render annotations that were extended to a query element of a view or projection (they only
   * appear in the view's 'elements', not in their 'columns' for client CSN, because the element
   * itself may not even be in 'columns', e.g. if it was expanded from a '*').  Return the
   * resulting rendered 'annotate' statement or an empty string if none required.
   *
   * Note: In the past, we checked if the annotation also exists in the respective column,
   *       however, in client CSN, annotations are not part of the column and in parseCdl CSN,
   *       no `elements` exist.
   *
   * @param {string} artifactName
   * @param {CSN.Artifact} art
   * @param {CdlRenderEnvironment} env
   * @return {string}
   */
  function renderQueryElementAnnotations(artifactName, art, env) {
    const annotate = collectAnnotationsOfElements(artifactName, art);
    if (annotate)
      return renderExtensions([ annotate ], env);
    return '';
  }

  /**
   * Create an "annotate" statement as a CSN extension for all annotations of (sub-)elements.
   * If no annotation was found, we return `null`.
   *
   * @param {string} artifactName
   * @param {CSN.Artifact} artWithElements
   * @return {CSN.Extension|null}
   */
  function collectAnnotationsOfElements(artifactName, artWithElements) {
    const annotate = { annotate: artifactName };
    return collectAnnos(annotate, artWithElements) ? annotate : null;

    /**
     * Recursive function to collect annotations. `annotateObj` will get an `elements`
     * object with annotations only if there are annotations on `art`'s (sub-)elements.
     *
     * @return {boolean} True, if there were annotations, false otherwise.
     */
    function collectAnnos(annotateObj, art) {
      if (!art.elements)
        return false;

      const collected = { elements: Object.create(null) };
      let hasAnnotation = false;

      forEach(art.elements, (elemName, element) => {
        if (!collected.elements[elemName])
          collected.elements[elemName] = { };

        let hasElementAnnotations = false;
        for (const name in element) {
          if (name.startsWith('@')) {
            collected.elements[elemName][name] = element[name];
            hasElementAnnotations = true;
            hasAnnotation = true;
          }
        }

        const hasSubAnnotations = collectAnnos(collected.elements[elemName], element);
        if (!hasElementAnnotations && !hasSubAnnotations)
          delete collected.elements[elemName]; // delete if no annotations exist
        hasAnnotation = hasAnnotation || hasSubAnnotations;
      });

      if (hasAnnotation)
        annotateObj.elements = collected.elements;

      return hasAnnotation;
    }
  }

  /**
   * Render the source of a query, which may be a path reference, possibly with an alias,
   * or a subselect, or a join operation, as seen from artifact 'art'.
   * Returns the source as a string.
   *
   * @param {object} source
   * @param {CdlRenderEnvironment} env
   * @return {string}
   */
  function renderViewSource(source, env) {
    // Sub-SELECT
    if (source.SELECT || source.SET) {
      let result = `(${renderQuery(source, false, 'view', increaseIndent(env))})`;
      if (source.as)
        result += ` as ${quoteIdIfRequired(source.as)}`;

      return result;
    }
    // JOIN
    else if (source.join) {
      // One join operation, possibly with ON-condition
      let result = `(${renderViewSource(source.args[0], env)}`;
      for (let i = 1; i < source.args.length; i++) {
        result += ` ${source.join} `;
        result += renderJoinCardinality(source.cardinality);
        result += `join ${renderViewSource(source.args[i], env)}`;
        if (source.on)
          result += ` on ${renderExpr(source.on, env, true, true)}`;
      }
      result += ')';
      return result;
    }
    // Ordinary path, possibly with an alias

    return renderAbsolutePathWithAlias(source, env);
  }

  function renderJoinCardinality(card) {
    let result = '';
    if (card) {
      if (card.srcmin && card.srcmin === 1)
        result += 'exact ';
      result += card.src && card.src === 1 ? 'one ' : 'many ';
      result += 'to ';
      if (card.min && card.min === 1)
        result += 'exact ';
      if (card.max)
        result += (card.max === 1) ? 'one ' : 'many ';
    }
    return result;
  }

  /**
   * Render a path that starts with an absolute name (as used e.g. for the source of a query),
   * with plain or quoted names, depending on options. Expects an object 'path' that has a 'ref'.
   * Returns the name as a string.
   *
   * @param {object} path
   * @param {CdlRenderEnvironment} env
   * @return {string}
   */
  function renderAbsolutePath(path, env) {
    // Sanity checks
    if (!path.ref)
      throw new ModelError(`Expecting ref in path: ${JSON.stringify(path)}`);


    // Determine the absolute name of the first artifact on the path (before any associations or element traversals)
    const firstArtifactName = path.ref[0].id || path.ref[0];

    // Render the first path step (absolute name, with different quoting/naming ..)
    let result = renderArtifactName(firstArtifactName);

    // Even the first step might have parameters and/or a filter
    if (path.ref[0].args)
      result += `(${renderArgs(path.ref[0], ':', env)})`;

    if (path.ref[0].where)
      result += `[${path.ref[0].cardinality ? (`${path.ref[0].cardinality.max}: `) : ''}${renderExpr(path.ref[0].where, env, true, true)}]`;

    // Add any path steps (possibly with parameters and filters) that may follow after that
    if (path.ref.length > 1)
      result += `:${renderExpr({ ref: path.ref.slice(1) }, env)}`;

    return result;
  }

  /**
   * Render a path that starts with an absolute name (as used for the source of a query),
   * possibly with an alias, with plain or quoted names, depending on options. Expects an object 'path' that has a
   * 'ref' and (in case of an alias) an 'as'. If necessary, an artificial alias
   * is created to the original implicit name.
   * Returns the name and alias as a string.
   *
   * @param {object} path
   * @param {CdlRenderEnvironment} env
   * @return {string}
   */
  function renderAbsolutePathWithAlias(path, env) {
    let result = renderAbsolutePath(path, env);
    if (path.as) {
      // Source had an alias - render it
      result += ` as ${quoteIdIfRequired(path.as)}`;
    }
    return result;
  }

  /**
   * Render the given columns.
   *
   * @param {any[]} columns
   * @param {object} elements
   * @param {CdlRenderEnvironment} env
   * @return {string}
   */
  function renderViewColumns(columns, env, elements = Object.create(null)) {
    const result = columns.map(col => renderViewColumn(col, env, findElement(elements, col)))
      .filter(s => s !== '')
      .join(',\n');
    return `${result}\n`;
  }

  /**
   * Render a single view or projection column 'col', as it occurs in a select list or
   * projection list within 'art', possibly with annotations.
   * Return the resulting source string (no trailing LF).
   *
   * @param {object} col
   * @param {CdlRenderEnvironment} env
   * @param {CSN.Element} element Element corresponding to the column. Generated by the compiler.
   */
  function renderViewColumn(col, env, element) {
    // Annotations and column
    let result = '';
    if (!col.doc) {
      // TODO: In contrast to annotations, we do not render the doc comment as part
      //       of an `annotate` statement.  That may change in the future.
      result += renderDocComment(element, env);
    }
    // Note: parentheses are a workaround for #9015
    result += renderAnnotationAssignmentsAndDocComment(col, env, { parens: true });
    result += env.indent;

    // only if column is virtual, keyword virtual was present in the source text
    if (col.virtual)
      result += 'virtual ';

    const key = col.key ? 'key ' : '';
    // Use special rendering for .expand/.inline - renderExpr cannot easily handle some cases
    result += key + ((col.expand || col.inline) ? renderInlineExpand(col, env) : renderExpr(col, env, true));

    // Alias for inline/expand is already handled by renderInlineExpand
    // A new association (cast with `type` and `target`) uses `as` as its primary name, not alias.
    const isNewAssociation = col.cast && col.cast.type && col.cast.target;
    if (col.as && !col.inline && !col.expand && !isNewAssociation)
      result += ` as ${quoteIdIfRequired(col.as)}`;

    // Explicit type provided for the view element?
    if (col.cast) {
      // Special case: Explicit association type is actually a redirect
      if (col.cast.target && !col.cast.type)
        result += ` : ${renderRedirectedTo(col.cast, env)}`;
      else
        result += ` : ${renderTypeReference(col.cast, env, true)}`;
    }
    return result;
  }

  /**
   * For the current column, render a (nested) inline/expand. If the current column
   * does not have an .expand/.inline, '' is returned
   *
   * @param {object} col Thing with .expand or .inline
   * @param {CdlRenderEnvironment} parentEnv
   * @returns {string}
   */
  function renderInlineExpand(col, parentEnv) {
    if (!col.inline && !col.expand)
      return '';

    return renderIX(col, parentEnv);

    function renderIX(obj, env) {
      // No expression to render for { * } as alias
      let result = (obj.as && obj.expand && !obj.ref) ? '' : renderExpr(obj, env);

      // s as alias { * }
      if (obj.as && (obj.ref || obj.xpr || obj.val !== undefined || obj.func !== undefined))
        result += ` as ${obj.as}`;

      // We found a leaf - no further drilling
      if (!obj.inline && !obj.expand) {
        if (obj.cast && obj.cast.type)
          result += ` : ${renderTypeReference(obj.cast, createEnv())}`;
        else if (obj.cast && obj.cast.target) // test tbd
          result += ` : ${renderRedirectedTo(obj.cast, env)}`;
        return result;
      }

      if (obj.inline)
        result += '.{\n';
      else
        result += result !== '' ? ' {\n' : '{\n';

      // Drill down and render children of the expand/inline
      const childEnv = increaseIndent(env);
      const expandInline = obj.expand || obj.inline;
      expandInline.forEach((elm, i) => {
        result += `${childEnv.indent}${renderIX(elm, childEnv)}`;
        if (i < expandInline.length - 1)
          result += ',\n';
      });
      result += `\n${env.indent}}`;

      // Don't forget about the .excluding
      if (obj.excluding)
        result += ` excluding { ${obj.excluding.join(',')} }`;

      // { * } as expand
      if (!obj.ref && obj.as)
        result += ` as ${obj.as}`;

      return result;
    }
  }

  /**
   * Render .doc properties as comments in CDL
   *
   * @param {object} obj Object to render for
   * @param {CdlRenderEnvironment} env
   * @returns {String}
   */
  function renderDocComment(obj, env) {
    if (!obj || obj && obj.doc === undefined)
      return '';
    else if (obj && obj.doc === null) // empty doc comment needs to be rendered
      return `\n${env.indent}/** */\n`;

    // Smaller comment for single-line comments.  If the comments starts or ends with whitespace
    // we must use a block comment, or it will be lost when compiling the source again.
    if (!obj.doc.includes('\n') && !/^\s|\s$/.test(obj.doc))
      return `${env.indent}/** ${obj.doc} */\n`;

    const comment = obj.doc.split('\n').map(line => `${env.indent} * ${line}`).join('\n');
    return `${env.indent}/**\n${comment}\n${env.indent} */\n`;
  }

  /**
   * Render a view. If '$syntax' is set (to 'projection', 'view', 'entity'),
   * the view query is rendered in the requested syntax style, otherwise it
   * is rendered as a view.
   *
   * @param {string} artifactName
   * @param {CSN.Artifact} art
   * @param {CdlRenderEnvironment} env
   */
  function renderView(artifactName, art, env) {
    const syntax = (art.projection) ? 'projection' : 'entity';
    let result = renderAnnotationAssignmentsAndDocComment(art, env);
    result += `${env.indent}${art.abstract ? 'abstract ' : ''}${syntax === 'projection' ? 'entity' : syntax} ${renderArtifactName(artifactName)}`;
    if (art.params) {
      const childEnv = increaseIndent(env);
      const parameters = Object.keys(art.params).map(name => renderParameter(name, art.params[name], childEnv)).join(',\n');
      result += `(\n${parameters}\n${env.indent}) as `;
    }
    else {
      result += ' as ';
    }
    env._artifact = art;
    result += renderQuery(getNormalizedQuery(art).query, true, syntax, env, [ 'definitions', artifactName, 'query' ], art.elements);
    result += ';\n';
    result += renderQueryElementAnnotations(artifactName, art, env);
    result += renderQueryActionsAndFunctions(artifactName, art, env);
    return result;
  }

  /**
   * Render a query 'query', i.e. a select statement with where-condition etc.
   * If 'isLeadingQuery' is true, mixins, actions and functions of 'art' are
   * also rendered into the query. Use 'syntax' style ('projection', 'view',
   * or 'entity')
   *
   * @param {CSN.Query} query
   * @param {boolean} isLeadingQuery
   * @param {string} syntax The query syntax, either "projection", "entity" or "view"
   * @param {CdlRenderEnvironment} env
   * @param {CSN.Path} [path=[]]
   * @param {object} [elements]
   */
  function renderQuery(query, isLeadingQuery, syntax, env, path = [], elements = query.elements || Object.create(null)) {
    if (query.SET) {
      // Set operator, such as UNION, INTERSECT, or EXCEPT...
      return renderQuerySet();
    }
    else if (!query.SELECT) {
      // ...otherwise must have a SELECT
      throw new ModelError(`Unexpected query operation ${JSON.stringify(query)}`);
    }

    let result = '';
    const select = query.SELECT;
    const childEnv = increaseIndent(env);

    // If not a projection, must be view/entity.
    result += (syntax === 'projection') ? 'projection on ' : 'select from ';
    result += renderViewSource(select.from, env);

    if (select.mixin) {
      let elems = '';
      forEach(select.mixin, (name, mixin) => {
        elems += renderElement(name, mixin, childEnv);
      });
      if (elems) {
        result += ' mixin {\n';
        result += elems;
        result += `${env.indent}} into`;
      }
    }
    result += select.distinct ? ' distinct' : '';
    if (select.columns) {
      result += ' {\n';
      result += renderViewColumns(select.columns, increaseIndent(env), elements);
      result += `${env.indent}}`;
    }

    if (select.excluding) {
      result += ` excluding {\n${select.excluding.map(id => `${childEnv.indent}${quoteIdIfRequired(id)}`).join(',\n')}\n`;
      result += `${env.indent}}`;
    }
    // FIXME: Currently, only projections can have actions and functions, but we cannot distinguish
    // a projection from a view any more
    if (isLeadingQuery)
      result += renderActionsAndFunctions(query, env);

    if (select.where)
      result += `${continueIndent(result, env)}where ${renderExpr(select.where, env, true, true)}`;

    if (select.groupBy)
      result += `${continueIndent(result, env)}group by ${select.groupBy.map(expr => renderExpr(expr, env, true, false, true)).join(', ')}`;

    if (select.having)
      result += `${continueIndent(result, env)}having ${renderExpr(select.having, env, true, true)}`;

    if (select.orderBy)
      result += `${continueIndent(result, env)}order by ${select.orderBy.map(entry => renderOrderByEntry(entry, env)).join(', ')}`;

    if (select.limit)
      result += `${continueIndent(result, env)}${renderLimit(select.limit, env)}`;

    return result;

    /**
     * Utility function to make sure that we continue with the same indentation in WHERE, GROUP BY, ... after a closing curly brace and beyond
     *
     * @param {string} str
     * @param {CdlRenderEnvironment} indentEnv
     * @return {string}
     */
    function continueIndent(str, indentEnv) {
      if (str.endsWith('}') || str.endsWith('})')) {
        // The preceding clause ended with '}', just append after that
        return ' ';
      }
      // Otherwise, start new line and indent normally
      return `\n${increaseIndent(indentEnv).indent}`;
    }

    /**
     * Render a query's LIMIT clause, which may have also have OFFSET.
     *
     * @param {CSN.QueryLimit} limit
     * @param {CdlRenderEnvironment} limitEnv
     * @return {string}
     */
    function renderLimit(limit, limitEnv) {
      let limitStr = '';
      if (limit.rows !== undefined)
        limitStr += `limit ${renderExpr(limit.rows, limitEnv)}`;

      if (limit.offset !== undefined)
        limitStr += `${limitStr !== '' ? `\n${increaseIndent(limitEnv).indent}` : ''}offset ${renderExpr(limit.offset, limitEnv)}`;

      return limitStr;
    }

    /**
     * Render UNION, INTERSECT, and EXCEPT, i.e. sets.
     *
     * @return {string}
     */
    function renderQuerySet() {
      const subQueries = query.SET.args.map((arg, i) => {
        // First arg may be leading query
        const subQuery = renderQuery(arg, isLeadingQuery && (i === 0), 'view', env, path.concat([ 'SET', 'args', i ]), elements);
        return `(${subQuery})`;
      });

      let setResult = subQueries.join(`\n${env.indent}${query.SET.op}${query.SET.all ? ' all' : ''} `);
      // Set operation may also have an ORDER BY and LIMIT/OFFSET (in contrast to the ones belonging to
      // each SELECT)
      if (query.SET.orderBy)
        setResult += `${continueIndent(setResult, env)}order by ${query.SET.orderBy.map(entry => renderOrderByEntry(entry, env)).join(', ')}`;

      if (query.SET.limit)
        setResult += `${continueIndent(setResult, env)}${renderLimit(query.SET.limit, env)}`;
      return setResult;
    }
  }

  /**
   * Render one entry of a query's ORDER BY clause (which always has a 'value' expression, and may
   * have a 'sort' property for ASC/DESC and a 'nulls' for FIRST/LAST
   *
   * @param {object} entry
   * @param {CdlRenderEnvironment} env
   * @return {string}
   */
  function renderOrderByEntry(entry, env) {
    let result = renderAnnotationAssignmentsAndDocComment(entry, env) + renderExpr(entry, env, true, false, true);
    if (entry.sort)
      result += ` ${entry.sort}`;

    if (entry.nulls)
      result += ` nulls ${entry.nulls}`;

    return result;
  }

  /**
   * Render an entity's actions and functions (if any)
   * (expect an entity with trailing '}' or an 'extend' statement ending with 'with'
   * to have just been rendered).
   * Return the resulting source string.
   *
   * @param {CSN.Artifact} art
   * @param {CdlRenderEnvironment} env
   * @return {string}
   */
  function renderActionsAndFunctions(art, env) {
    let result = '';
    const childEnv = increaseIndent(env);
    for (const name in art.actions)
      result += renderActionOrFunction(name, art.actions[name], childEnv);

    // Even if we have seen actions/functions, they might all have been ignored
    if (result !== '')
      result = ` actions {\n${result}${env.indent}}`;

    return result;
  }

  /**
   * Render an action or function 'act' with name 'actName'. Return the resulting source string.
   *
   * @param {string} actionName
   * @param {CSN.Action} act
   * @param {CdlRenderEnvironment} env
   * @return {string}
   */
  function renderActionOrFunction(actionName, act, env) {
    let result = `${renderAnnotationAssignmentsAndDocComment(act, env) + env.indent + act.kind} ${renderArtifactName(actionName)}`;
    const childEnv = increaseIndent(env);
    const parameters = Object.keys(act.params || []).map(name => renderParameter(name, act.params[name], childEnv)).join(',\n');
    result += (parameters === '') ? '()' : `(\n${parameters}\n${env.indent})`;
    if (act.returns) {
      if (act.returns.type && act.returns.elements) {
        // Annotation in action returns' structure.  Render it as an annotate statement.
        const isBoundAction = (env.artifactName !== actionName);
        const anno = {
          annotate: env.artifactName || actionName,
        };
        if (isBoundAction)
          anno.actions = { [actionName]: { returns: { elements: act.returns.elements } } };
        else
          anno.returns = { elements: act.returns.elements };
        subelementAnnotates.push(anno);
      }
      result += ` returns ${renderTypeReference(act.returns, env)}${renderNullability(act.returns)}`;
    }

    result += ';\n';
    return result;
  }

  /**
   * Render an action or function parameter 'par' with name 'parName'. Return the resulting source string (no trailing LF).
   *
   * @param {string} parName
   * @param {object} par
   * @param {CdlRenderEnvironment} env
   * @return {string}
   */
  function renderParameter(parName, par, env) {
    let result = `${renderAnnotationAssignmentsAndDocComment(par, env) + env.indent + quoteIdIfRequired(parName)} : ${renderTypeReference(par, env)}`;
    if (par.default)
      result += ` default ${renderExpr(par.default, env)}`;

    result += renderNullability(par);
    return result;
  }

  /**
   * Render a type (derived or structured) or an annotation decl with name 'artifactName'.
   * Return the resulting source string.
   *
   * @param {string} artifactName
   * @param {CSN.Artifact} art
   * @param {CdlRenderEnvironment} env
   * @param {String} artType - used for rendering csn.vocabularies, as the annotations there do not have a kind. Only in toCdl mode
   * @return {string}
   */
  function renderTypeOrAnnotation(artifactName, art, env, artType) {
    let result = renderAnnotationAssignmentsAndDocComment(art, env);
    result += `${env.indent + (artType || art.$syntax || art.kind )} ${renderArtifactName(artifactName)}`;
    if (art.includes)
      result += renderIncludes(art.includes);

    const childEnv = increaseIndent(env);
    if (art.elements && !art.type) {
      // Structured type or annotation with anonymous struct type
      result += ' {\n';
      for (const name in art.elements)
        result += renderElement(name, art.elements[name], childEnv);

      result += `${env.indent}};\n`;
    }
    else {
      // Derived type or annotation with non-anonymous type
      result += ` : ${renderTypeReference(art, env, false)}`;
      if (art.default)
        result += ` default ${renderExpr(art.default, env)}`;
      result += ';\n';
    }
    return result;
  }

  /**
   * Render a reference to a type used by 'elm' (named or inline)
   * Allow suppressing enum-rendering - used in columns for example
   *
   * @param {CSN.Element} elm
   * @param {CdlRenderEnvironment} env
   * @param {boolean} [noEnum=false]
   * @return {string}
   */
  function renderTypeReference(elm, env, noEnum = false) {
    let result = '';

    // Array type: Render items instead
    if (elm.items && !elm.type) {
      // HANA CDS does not support keyword many
      let rc = `many ${renderTypeReference(elm.items, env)}`;
      if (elm.items.notNull != null)
        rc += elm.items.notNull ? ' not null' : ' null';
      // many sub element annotates
      // TODO(andre): This does handle deeply nested elements because we take the full `elements`.
      //              But when is env.elementName set and when not?
      if (elm.items.type && elm.items.elements && env.artifactName) {
        const annotate = { annotate: env.artifactName };
        if (env.elementName)
          annotate.elements = { [env.elementName]: elm.items };
        else
          annotate.elements = elm.items.elements;
        subelementAnnotates.push(annotate);
      }

      return rc;
    }

    // FIXME: Is this a type attribute?
    result += (elm.localized ? 'localized ' : '');

    // Anonymous structured type
    if (!elm.type) {
      if (!elm.elements)
        throw new ModelError(`Missing type of: ${JSON.stringify(elm)}`);

      result += '{\n';
      const childEnv = increaseIndent(env);
      for (const name in elm.elements)
        result += renderElement(name, elm.elements[name], childEnv, null);

      result += `${env.indent}}`;
      return result;
    }

    const comp = 'cds.Composition';
    // Association type
    if ([ 'cds.Association', comp ].includes(elm.type)) {
      // Type, cardinality and target; CAPire uses CamelCase
      result += (elm.type === comp) ? 'Composition' : 'Association';

      if (isSimpleCardinality(elm.cardinality)) {
        result += renderSimpleCardinality(elm);
      }
      else {
        result += renderCardinality(elm.cardinality) +
          ((elm.type === comp) ? ' of ' : ' to ');
      }

      // `targetAspect` may be set by the core compiler and refers to the original named or unnamed aspect.
      // In parseCdl, `target` may still be an object containing elements.  This would be replaced
      // by targetAspect in client CSN, but we can't rely on that.
      // If a name exists (either in target or targetAspect), prefer it over rendering elements.
      const elements = elm.target && elm.target.elements || elm.targetAspect && elm.targetAspect.elements;
      if (typeof elm.target === 'string' || typeof elm.targetAspect === 'string') {
        result += renderAbsolutePath({ ref: [ elm.target || elm.targetAspect ] }, env);
      }
      else if (elements) {
        // anonymous aspect, either parseCdl or client CSN.
        const childEnv = increaseIndent(env);
        result += '{\n';
        for (const name in elements)
          result += renderElement(name, elements[name], childEnv);

        result += `${env.indent}}`;
      }
      else {
        throw new ModelError('Association/Composition is missing its target! Throwing exception to trigger recompilation.');
      }

      // ON-condition (if any)
      if (elm.on)
        result += ` on ${renderExpr(elm.on, env, true, true)}`;


      // Foreign keys (if any, unless we also have an ON_condition (which means we have been transformed from managed to unmanaged)
      if (elm.keys && !elm.on)
        result += ` { ${Object.keys(elm.keys).map(name => renderForeignKey(elm.keys[name], env)).join(', ')} }`;

      return result;
    }

    // Reference to another element
    if (elm.type.ref) {
      if (elm.enum) {
        const source = artifactRef(elm.type);
        if (!source.enum) {
          // enum was defined at this element and not at the referenced one
          result += renderAbsolutePath(elm.type, env) + renderEnum(elm.enum, env);
        }
        else {
          result += renderAbsolutePath(elm.type, env);
        }
      }
      else {
        result += renderAbsolutePath(elm.type, env);
      }
      return result;
    }

    // If we get here, it must be a named type
    result += renderNamedTypeWithParameters(elm);

    if (elm.enum && !noEnum)
      result += renderEnum(elm.enum, env);

    return result;
  }

  /**
   * Render REDIRECTED TO with its keys/on condition for the given artifact.
   *
   * @param {object} art
   * @param {CdlRenderEnvironment} env
   * @return {string}
   */
  function renderRedirectedTo(art, env) {
    let result = `redirected to ${quoteIdIfRequired(art.target)}`;
    if (art.on)
      result += ` on ${renderExpr(art.on, env, true, true)}`;
    else if (art.keys)
      result += ` { ${Object.keys(art.keys).map(name => renderForeignKey(art.keys[name], env)).join(', ')} }`;
    return result;
  }

  /**
   * Render the named type with optional parameters, e.g. `MyString(length: 10)`.
   * @param {CSN.Artifact} artWithType
   * @return {string}
   */
  function renderNamedTypeWithParameters(artWithType) {
    let result = '';

    if (isBuiltinType(artWithType.type)) {
      // If there is a user-defined type with the same short name (cds.Integer -> Integer),
      // we render the full name, including the leading "cds."
      if (csn.definitions[artWithType.type.slice(4)])
        result += artWithType.type;
      else
        result += artWithType.type.slice(4);
    }
    else {
      // Simple absolute name
      // Type names are never flattened (derived types are unraveled in HANA)
      result += renderArtifactName(artWithType.type);
    }

    result += renderTypeParameters(artWithType);
    return result;
  }


  /**
   * Render the 'enum { ... } part of a type declaration
   *
   * @param {CSN.EnumElements} enumPart
   * @param {CdlRenderEnvironment} env
   * @return {string}
   */
  function renderEnum(enumPart, env) {
    let result = ' enum {\n';
    const childEnv = increaseIndent(env);
    for (const name in enumPart)
      result += renderEnumElement(name, enumPart[name], childEnv);
    result += `${env.indent}}`;
    return result;
  }

  /**
   * Render the element of a `<type> enum {}` structure.
   *
   * @param {string} name
   * @param {CSN.EnumValue} enumValue
   * @param {CdlRenderEnvironment} env
   * @return {string}
   */
  function renderEnumElement(name, enumValue, env) {
    let result = '';
    result += renderAnnotationAssignmentsAndDocComment(enumValue, env);
    result += env.indent + quoteIdIfRequired(name);
    if (enumValue.val !== undefined)
      result += ` = ${renderExpr(enumValue, env)}`;
    else if (enumValue['#'] !== undefined)
      result += ` = #${enumValue['#']}`;
    result += ';\n';
    return result;
  }

  /**
   * Render an annotation value (somewhat like a simplified expression, with slightly different
   * representation)
   *
   * @param {any} x
   * @param {CdlRenderEnvironment} env
   */
  function renderAnnotationValue(x, env) {
    if (Array.isArray(x)) {
      // Render array parts as values. Spaces required if last array value is
      // a delimited identifier.
      return `[ ${x.map(item => renderAnnotationValue(item, env)).join(', ')} ]`;
    }
    else if (typeof x === 'object' && x !== null) {
      // Enum symbol
      if (x['#']) {
        return `#${x['#']}`;
      }
      // Shorthand for absolute path (as string)
      else if (x['=']) {
        return quotePathString(x['=']);
      }
      // Shorthand for ellipsis: `... up to <val>`
      else if (x['...']) {
        if (x['...'] === true)
          return '...';
        return `... up to ${renderAnnotationValue(x['...'], env)}`;
      }

      // Struct value (can actually only occur within an array)

      // Note that we have to quote the struct keys here manually and not use quoteIdIfRequired, because they may even contain dots (yuc!)
      // FIXME: Should that really be allowed?
      return `{${Object.keys(x).map(key => `![${key}]: ${renderAnnotationValue(x[key], env)}`).join(', ')}}`;
    }
    // Null
    else if (x === null) {
      return 'null';
    }
    // Primitive: string, number, boolean

    // Quote strings, leave all others as they are
    return (typeof x === 'string') ? renderString(x, env) : x;
  }

  /**
   * Render a single path step 's' at path position 'idx', which can have filters or parameters or be a function
   *
   * @param {string|object} s
   * @param {number} idx
   * @returns {string}
   */
  function renderPathStep(s, idx, inline, env) {
    // Simple id or absolute name
    if (typeof s === 'string') {
      // In first path position, do not quote $projection and magic $-variables like CURRENT_DATE, $now etc.
      // FIXME: We should rather explicitly recognize quoting somehow

      if (idx === 0 &&
              s.startsWith('$'))
        return s;

      return quoteIdIfRequired(s);
    }
    // ID with filters or parameters
    else if (typeof s === 'object') {
      // Sanity check
      if (!s.func && !s.id)
        throw new ModelError(`Unknown path step object: ${JSON.stringify(s)}`);

      // Not really a path step but an object-like function call
      if (s.func)
        return `${s.func}(${renderArgs(s, '=>', env)})`;

      // Path step, possibly with view parameters and/or filters
      let result = `${quoteIdIfRequired(s.id)}`;
      if (s.args) {
        // View parameters
        result += `(${renderArgs(s, ':', env)})`;
      }
      if (s.where) {
        // Filter, possibly with cardinality
        result += `[${s.cardinality ? (`${s.cardinality.max}: `) : ''}${renderExpr(s.where, env, inline, true)}]`;
      }

      return result;
    }

    throw new ModelError(`Unknown path step: ${JSON.stringify(s)}`);
  }

  /**
   * Render function arguments or view parameters (positional if array, named if object/dict),
   * using 'sep' as separator for named parameters
   *
   * @param {object} node with `args` to render
   * @param {string} sep
   * @param {CdlRenderEnvironment} env
   * @returns {string}
   */
  function renderArgs(node, sep, env) {
    const args = node.args || [];

    // Positional arguments
    if (Array.isArray(args))
      return args.map(arg => renderArgument(arg, env)).join(', ');

    // Named arguments (object/dict)
    else if (typeof args === 'object')
      return Object.keys(args).map(key => `${quoteIdIfRequired(key)} ${sep} ${renderArgument(args[key], env)}`).join(', ');

    throw new ModelError(`Unknown args: ${JSON.stringify(args)}`);
  }

  /**
   * Render a function argument, e.g. for generic functions or CAST().
   * Ensures that parentheses are used if necessary, e.g. for `someFct( (1=1), (1=1) )`.
   *
   * @param {any} arg
   * @param {CdlRenderEnvironment} env
   * @return {string}
   */
  function renderArgument(arg, env) {
    // If the argument is a xpr with e.g. `=`, it may require parentheses.
    // For nested xpr, `renderExpr()` will already add parentheses.
    return renderExpr(arg, env, true, !isSimpleFunctionExpression(arg && arg.xpr), true);
  }

  /**
   * Render a cardinality (only those parts that were actually provided)
   *
   * @param {CSN.Cardinality} card
   * @return {string}
   */
  function renderCardinality(card) {
    if (!card)
      return '';

    let result = '[';
    if (card.src !== undefined)
      result += `${card.src}, `;

    if (card.min !== undefined)
      result += `${card.min}..`;

    if (card.max !== undefined)
      result += card.max;

    return `${result}]`;
  }

  /**
   * A "simple" cardinality is one that only has a "max" cardinality property
   * which is either '*' or 1.
   *
   * @param {CSN.Cardinality} cardinality
   * @return {boolean}
   */
  function isSimpleCardinality(cardinality) {
    return !cardinality || (
      cardinality.min === undefined &&
      cardinality.src === undefined &&
      cardinality.srcmin === undefined &&
      (cardinality.max === '*' || cardinality.max === 1)
    );
  }

  /**
   * Renders the simple cardinality of an association/composition, i.e. "many"/"one",
   * including the "of"/"to" part.
   *
   * @param {CSN.Element} elem
   * @return {string}
   */
  function renderSimpleCardinality(elem) {
    let result = (elem.type === 'cds.Association' ? ' to ' : ' of ');
    if (!elem.cardinality)
      return result;
    if (elem.cardinality.max === '*')
      result += 'many ';
    else if (elem.cardinality.max === 1)
      result += 'one ';
    return result;
  }

  // Render the nullability of an element or parameter (can be unset, true, or false)
  function renderNullability(obj /* , env */) {
    if (obj.notNull === undefined) {
      // Attribute not set at all
      return '';
    }
    return obj.notNull ? ' not null' : ' null';
  }

  /**
   * Render a foreign key (no trailing LF)
   *
   * @param {object} fKey
   * @param {CdlRenderEnvironment} env
   * @return {string}
   */
  function renderForeignKey(fKey, env) {
    return `${renderExpr(fKey, env)}${fKey.as ? (` as ${fKey.as}`) : ''}`;
  }

  /**
   * Render (primitive) type parameters of artifact 'artWithType', i.e.
   * length, precision and scale (even if incomplete), plus any other unknown ones.
   *
   * @param {CSN.Artifact} artWithType
   * @returns {string}
   */
  function renderTypeParameters(artWithType) {
    const params = typeParameters.list.filter(param => artWithType[param] !== undefined);
    if (params.length === 0)
      return '';

    // TODO(v3): Remove special handling of srid
    // For backwards compatibility, do not render srid as a named argument for POINT/GEOMETRY builtins.
    if (artWithType.srid !== undefined &&
       (artWithType.type === 'cds.hana.ST_POINT' || artWithType.type === 'cds.hana.ST_GEOMETRY'))
      return `(${artWithType.srid})`;

    // Special cases for 1 or 2 arguments.
    if (params.length === 1 && artWithType.length !== undefined)
      return `(${artWithType.length})`;
    if (params.length === 2 && artWithType.precision !== undefined && artWithType.scale !== undefined)
      return `(${artWithType.precision}, ${artWithType.scale})`;

    // Render named params
    const renderedParams = [];
    for (const param of params)
      renderedParams.push(`${param}: ${artWithType[param]}`);

    return `(${renderedParams.join(', ')})`;
  }

  /**
   * Render all annotation assignments of annotatable object 'obj'.
   *
   * @param {object} obj Object that has annotations
   * @param {CdlRenderEnvironment} env
   * @param {{parens: boolean}} [config] Config for renderAnnotationAssignment()
   * @return {string}
   */
  function renderAnnotationAssignmentsAndDocComment(obj, env, config) {
    let result = renderDocComment(obj, env);
    for (const name in obj) {
      if (name.startsWith('@'))
        result += renderAnnotationAssignment(obj[name], name, env, config);
    }
    return result;
  }

  /**
   * Render a single annotation assignment 'anno' with fully qualified name 'name' (no trailing LF).
   * We might see variants like 'A.B.C#foo' or even 'A.B#foo.C'. The latter needs to be quoted as
   * dots in the variant are not recognized by the compiler.
   *
   * @param {any} anno Annotation value
   * @param {string} name Annotation name, e.g. `@A.B.C#foo.C`
   * @param {CdlRenderEnvironment} env
   * @param {object} [config] parens: Whether the annotation assignment must be surrounded by parentheses.
   * @return {string} Rendered annotation, possibly quoted: `@![A.B.C#foo.C]: value`
   */
  function renderAnnotationAssignment(anno, name, env, config = { parens: false }) {
    name = name.substring(1);
    // Take the annotation assignment apart into <nameBeforeVariant>#<variantAndRest>
    const parts = name.split('#');
    const nameBeforeVariant = parts[0];
    const variant = parts[1];
    const { parens } = config;

    // Identifier according to our grammar: /[$_a-zA-Z][$_a-zA-Z0-9]*/
    // We expand this pattern to also include dots after the first character.
    // If the annotation does not follow this pattern `ident(.@ident)*`, it must be quoted:
    // `@identifier@identifier` must be quoted but `@identifier.@identifier` should not.
    const annoRequiresQuoting = !/^[$_a-zA-Z][$_a-zA-Z0-9.]*(?:\.@[$_a-zA-Z][$_a-zA-Z0-9.]*)*$/.test(nameBeforeVariant);
    // Unfortunately, the compiler does not allow `.` after the first variant identifier,
    // even though that is the result after flattening.
    const variantRequiresQuoting = variant && !/^[$_a-zA-Z][$_a-zA-Z0-9]*$/.test(variant);

    let result = `${env.indent}@`;
    if (parens)
      result += '(';

    if (annoRequiresQuoting || variantRequiresQuoting)
      result += quote(name);
    else
      result += name;

    result += ` : ${renderAnnotationValue(anno, env)}`;
    if (parens)
      result += ')';
    return `${result}\n`;
  }

  /**
   * Render the name of an artifact, using the current name prefix from 'env'
   * and the real name of the artifact. In case of plain names, this
   * is equivalent to simply flattening and uppercasing the whole name.
   *
   * In cdlMode, the prefix is extended to handle cases like an entity shadowing the prefix
   * of another entity -> Service.E and Service.E.Sub
   *
   * To handle such cases for hdbcds in quoted/hdbcds, we:
   * - Find the part of the name that is no longer prefix (context/service)
   * - For Service.E -> E, for Service.E.Sub -> E.Sub
   * - Replace all dots in this "real name" with underscores
   * - Join with the env prefix
   *
   * @param {string} artifactName Artifact name to render
   * @return {string} Artifact name ready for rendering
   */
  function renderArtifactName(artifactName) {
    const realname = getRealName(artifactName);
    const prefix = (realname !== artifactName) ? artifactName.slice(0, artifactName.length - realname.length - 1) : '';
    return prefix ? `${quoteIdIfRequired(prefix)}.${realname.split('.').map(quoteIdIfRequired).join('.')}` : realname.split('.').map(quoteIdIfRequired).join('.');
  }

  /**
   * Get the part that is really the name of this artifact and not just prefix caused by a context/service
   *
   * @param {String} artifactName Artifact name to use
   * @returns {String} non-prefix part of the artifact name
   */
  function getRealName(artifactName) {
    const parts = artifactName.split('.');
    // Length of 1 -> There can be no prefix
    if (parts.length === 1)
      return artifactName;


    let seen = '';
    for (let i = 0; i < parts.length; i++) {
      if (seen !== '')
        seen = `${seen}.${parts[i]}`;
      else
        seen = parts[i];


      const art = csn.definitions[seen];
      if (!art || (art.kind !== 'service' && art.kind !== 'context')) {
        // We found a case where the prefix ended
        // Return everything following
        return parts.slice(i).join('.');
      }
    }

    // we seem to have a normal case - just return the last part
    return getLastPartOf(artifactName);
  }

  /**
   * Render an expression.
   *
   * @param {any} expr
   * @param {CdlRenderEnvironment} env
   * @param {boolean} [inline]
   * @param {boolean} [nestedExpr]
   * @param {boolean} [alwaysRenderCast]
   * @returns {string}
   */
  function renderExpr(expr, env, inline, nestedExpr, alwaysRenderCast) {
    if (!_renderExpr) {
      _renderExpr = getExpressionRenderer({
        finalize: x => x,
        explicitTypeCast: (x, env) => {
          const typeRef = renderTypeReference(x.cast, env, true);
          const arg = { ...x, cast: null }; // "arg" without cast to avoid recursion.
          return `cast(${renderArgument(arg, env)} as ${typeRef})`;
        },
        val(x, env) {
          // Literal value, possibly with explicit 'literal' property
          switch (x.literal || typeof x.val) {
            case 'number':
            case 'boolean':
            case 'null':
              return x.val;
            case 'x':
            case 'date':
            case 'time':
            case 'timestamp':
              return `${x.literal}'${x.val}'`;
            case 'string':
              return renderString(x.val, env);
            case 'object':
              if (x.val === null)
                return 'null';
            // otherwise fall through to
            default:
              throw new ModelError(`Unknown literal or type: ${JSON.stringify(x)}`);
          }
        },
        aliasOnly(x, _env) {
          return x.as;
        },
        enum: x => `#${x['#']}`,
        ref(x, env) {
          const { inline } = this;
          return `${(x.param || x.global) ? ':' : ''}${x.ref.map((step, index) => renderPathStep(step, index, inline, env)).join('.')}`;
        },
        windowFunction: (x, env) => {
          const funcDef = renderFunc(x.func, x, null, a => renderArgs(a, '=>', env));
          const windowFunctionOperator = x.xpr.shift(); // OVER ...
          return `${funcDef} ${windowFunctionOperator} ( ${renderExpr(x.xpr, env, true)} )`;
        },
        func: (x, env) => {
          // FIXME: Why care about HANA identifier?
          // test for non-regular HANA identifier that needs to be quoted
          // identifier                  {letter}({letter_or_digit}|[#$])*
          // letter                      [A-Za-z_]
          // letter_or_digit             [A-Za-z_0-9]

          const regex = /^[a-zA-Z][\w#$]*$/g;
          const funcName = regex.test(x.func) ? x.func : quoteIdIfRequired(x.func);
          return renderFunc(funcName, x, 'cap', a => renderArgs(a, '=>', env));
        },
        xpr(x, env) {
          if (this.nestedExpr && !x.cast || x.xpr.some(s => s === 'exists'))
            return `(${renderExpr(x.xpr, env, this.inline, true)})`;

          return renderExpr(x.xpr, env, this.inline, true);
        },
        // Sub-queries in expressions need to be in parentheses, otherwise
        // left-associativity of UNIONS may result in different results.
        // For example: `select from E where id in (select from E union select from E);`:
        // Without parentheses, it would be different query.
        SET: (x, env) => `(${renderQuery(x, false, 'view', increaseIndent(env))})`,
        SELECT: (x, env) => `(${renderQuery(x, false, 'view', increaseIndent(env))})`,
      });
    }
    return _renderExpr(expr, env, inline, nestedExpr, alwaysRenderCast);
  }
}

/**
 * Returns a newly created default environment (which keeps track of indentation, required USING
 * declarations and name prefixes.
 *
 * @return {CdlRenderEnvironment}
 */
function createEnv() {
  return {
    // Current indentation string
    indent: '',
    // Dictionary of aliases for used artifact names, each entry like 'name' : { quotedName, quotedAlias }
    topLevelAliases: Object.create(null),
    // Current name prefix (including trailing dot if not empty)
    namePrefix: '',
    artifactName: '',
    elementName: '',
  };
}

/**
 * Returns a copy of 'env' with increased indentation (and reset name prefix)
 *
 * @param {CdlRenderEnvironment} env
 * @returns {CdlRenderEnvironment}
 */
function increaseIndent(env) {
  return Object.assign({}, env, { namePrefix: '', indent: `${env.indent}  ` });
}

/**
 * Return a path string 'path' with appropriate "-quotes.
 *
 * @param {string} path
 * @returns {string}
 */
function quotePathString(path) {
  // "foo"."bar"."wiz"."blub"
  return path.split('.').map(quoteIdIfRequired).join('.');
}

/**
 * Return an id 'id' with appropriate "-quotes
 *
 * @param {string} id
 * @return {string}
 */
function quoteIdIfRequired(id) {
  // Quote if required for CDL
  if (requiresQuotingForCdl(id))
    return quote(id);

  return id;
}

/**
 * Quotes the identifier using CDL-style ![]-quotes.
 *
 * @param id
 * @returns {string}
 */
function quote(id) {
  return `![${id.replace(/]/g, ']]')}]`;
}

/**
 * Returns true if 'id' requires quotes for CDL, i.e. if 'id'
 *  1. starts with a digit
 *  2. contains chars different than:
 *   - uppercase letters
 *   - lowercase letters
 *   - digits
 *   - underscore
 *  3. is a CDL keyword or a CDL function without parentheses (CURRENT_*, SYSUUID, ...)
 *
 * @param {string} id
 * @return {boolean}
 */
function requiresQuotingForCdl(id) {
  return /^\d/.test(id) ||
    /\W/g.test(id.replace(/\./g, '')) ||
    keywords.cdl.includes(id.toUpperCase()) ||
    keywords.cdl_functions.includes(id.toUpperCase());
}

const functionExpressionOperatorsRequireParentheses = [
  // Antlr rule 'condition', 'conditionAnd'
  'and', 'or',

  // Antlr rule 'conditionTerm'
  '=', '<>', '>', '>=', '<', '<=', '!=',
  // These are not forbidden, since they must be preceded by one of the comparators above.
  // 'any', 'some', 'all',

  'is', 'in', 'not', 'null', 'exists',
  // Antlr rule 'predicate'
  'between', 'like', 'escape',
];

/**
 * Returns true if the given xpr-array can be rendered without parentheses
 * in a `fct(<xpr>)` expression such as `cast(<xpr> as Type)`.  We only need to
 * look at the first nesting level.  Otherwise, `renderExpr()` will already add parentheses.
 *
 * The list was created by looking at the `expression` Antlr rule.
 *
 * This is more of a heuristic for "nicer" CDL output.  For example the
 * following snippet is parsable without parentheses:
 *   `cast( case when int > 1 then int else 0 end as Integer ),`
 * However, because it is a flat xpr-array, we see `>` and assume that it is not a simple expression.
 *
 * @param {any[]} xpr
 * @return {boolean}
 */
function isSimpleFunctionExpression(xpr) {
  return !xpr || xpr.every(val => typeof val !== 'string' || !functionExpressionOperatorsRequireParentheses.includes(val.toLowerCase()));
}

/**
 * @param {string[]} includes
 * @return {string}
 */
function renderIncludes(includes) {
  return ` : ${includes.map(name => quoteIdIfRequired(name)).join(', ')}`;
}

/**
 * Render the given string.  Uses back-tick strings.
 * env is used for indentation of three-back-tick strings.
 *
 * @param str
 * @param env
 * @returns {string}
 */
function renderString(str, env) {
  if (isSimpleString(str))
    return `'${str.replace(/'/g, '\'\'')}'`;

  // We try to work similar to how JavaScript implements JSON.stringify.
  // JSON.stringify() also checks for unpaired unicode surrogates (see §25.5.2.2,
  // <https://tc39.es/ecma262/#sec-quotejsonstring>).
  str = escapeString(str, {
    $: '\\$',
    '`': '\\`',
    '\\': '\\\\',
    // Replace commonly known escape sequences for control characters
    // See lib/language/multiLineStringParser.js
    '\f': '\\f',
    '\v': '\\v',
    '\t': '\\t',
    '\b': '\\b',
    // If CR, LS, or PS appear, they have been encoded explicitly.  If we don't escape
    // them, a recompilation may yield different results because of newline normalization.
    '\r': '\\r',
    '\u{2028}': '\\u{2028}',
    '\u{2029}': '\\u{2029}',
    // Don't encode LF
    '\n': '\n',
    // JSON.stringify() is not required to escape all control characters, but if used, files may
    // be interpreted as binary.  Therefore, we replace them.
    // We exclude LF from this list (\n). Characters with "nice" escapes have been replaced above.
    control: hexEscape,
    unpairedSurrogate: hexEscape,
  });

  // Note: String is normalized, only \n is the line separator.
  const lines = str.split('\n');
  // We don't know whether a text block was used or not.  But if there
  // are more than three lines, text blocks with indentation "look nicer".
  // This value was chosen by personal taste.
  if (lines.length > 3) {
    str = lines.join(`\n${env.indent}`);
    return `\`\`\`\n${env.indent}${str}\n${env.indent}\`\`\``;
  }

  return `\`${str}\``;
}

/** @param {number} codePoint */
function hexEscape(codePoint) {
  const hex = codePoint.toString(16);
  return `\\u{${hex}}`;
}

/**
 * Returns true if the given string can be represented by using single quotes.
 * @param {string} str
 */
function isSimpleString(str) {
  // A single-line string allows everything except certain line separators/breaks.
  // See ANTLR grammar for specifics.
  // Furthermore, if control characters are used, we escape them,
  // as these are explicitly mentioned in the JSON spec (§9):
  // <https://www.ecma-international.org/wp-content/uploads/ECMA-404_2nd_edition_december_2017.pdf>
  // On top, because (invalid) surrogate pairs need to be handled, we check for them as well.
  // v3: Not a simple string if ' (\u0027) is in string.
  return str === '' || (/^[^\u{0000}-\u{001F}\u2028\u2029]+$/u.test(str) &&
    !hasUnpairedUnicodeSurrogate(str));
}

/**
 * @typedef CdlRenderEnvironment Rendering environment used throughout the render process.
 *
 * @property {string}   indent Current indentation as a string, e.g. '  ' for two spaces.
 * @property {CSN.Path} [path] CSN path to the current artifact
 * @property {string}   [artifactName] Name of the artifact - set in renderArtifact
 * @property {string}   [elementName] Name of the element being rendered - set in renderElement
 * @property {{[name: string]: {
      quotedName: string,
      quotedAlias: string
    }}} topLevelAliases Dictionary of aliases for used artifact names
 *
 * @property {string} [namePrefix] Current name prefix (including trailing dot if not empty)
 * @property {boolean} [skipKeys]
 * @property {CSN.Artifact} [_artifact]
 */

module.exports = { toCdsSourceCsn };
