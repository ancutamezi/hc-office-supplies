'use strict';

/**
 * A single StopWatch encapsulates the runtime of a selected code frame.
 *
 * @class TimeTrace
 */
class StopWatch {
  /**
   * Creates an instance of TimeTrace.
   * @param {string} id
   *
   * @memberOf TimeTrace
   */
  constructor(id) {
    this.id = id;
    // TODO: If we require Node 12, use process.hrtime.bigint()
    //       as process.hrtime() is deprecated.
    // eslint-disable-next-line no-multi-assign
    this.startTime = this.lapTime = process.hrtime();
  }

  /**
     * Start watch.
     */
  start() {
    // eslint-disable-next-line no-multi-assign
    this.startTime = this.lapTime = process.hrtime();
  }

  /**
   * Stop and return delta T
   * but do not set start time
   */
  stop() {
    return process.hrtime(this.startTime);
  }

  /**
   * return lap time
   */
  lap() {
    const dt = process.hrtime(this.lapTime);
    this.lapTime = process.hrtime();
    return dt;
  }

  // stop as sec.ns float
  stopInFloatSecs() {
    const dt = this.stop();
    return dt[0] + dt[1] / 1000000000;
  }

  // lap as sec.ns float
  lapInFloatSecs() {
    const dt = this.lap();
    return dt[0] + dt[1] / 1000000000;
  }
}

/**
 * The main class to handle measuring the runtime of code blocks
 *
 * Results are logged to stderr
 *
 * To enable time tracing, set CDSC_TIMETRACE to true in the environment
 *
 * @class TimeTracer
 */
class TimeTracer {
  /**
   * Creates an instance of TimeTracer.
   *
   * @memberOf TimeTracer
   */
  constructor() {
    this.traceStack = [];
  }

  /**
   * Start a new TimeTrace, using the given id for logging etc.
   *
   * @param {string} id A short description of whats going on
   *
   * @memberOf TimeTracer
   */
  start(id) {
    try {
      const b = new StopWatch(id);
      this.traceStack.push(b);
      b.start();
      // eslint-disable-next-line no-console
      console.error(`${ ' '.repeat((this.traceStack.length - 1) * 2) }${ id } started`);
    }
    catch (e) {
      // eslint-disable-next-line no-console
      console.error(`Starting time trace with id ${ id } failed: ${ e }`);
    }
  }

  /**
   * Stop the current TimeTrace and log the execution time.
   *
   *
   * @memberOf TimeTracer
   */
  stop() {
    try {
      const current = this.traceStack.pop();
      const dT = current.stop();
      const base = `${ ' '.repeat(this.traceStack.length * 2) }${ current.id } took:`;
      // eslint-disable-next-line no-console
      console.error( `${ base }${ ' '.repeat(60 - base.length) } %ds %dms`, dT[0], dT[1] / 1000000);
    }
    catch (e) {
      // eslint-disable-next-line no-console
      console.error(`Stopping time trace failed: ${ e }`);
    }
  }
}

const ignoreTimeTrace = {
  start: () => { /* ignore */ },
  stop: () => { /* ignore */ },
};

const doTimeTrace = process && process.env && process.env.CDSC_TIMETRACING !== undefined;
module.exports = {
  timetrace: (doTimeTrace ? new TimeTracer() : ignoreTimeTrace),
  TimeTracer,
  StopWatch,
};
