// Main entry point for the CDS Compiler
//
// File for external usage = which is read in other modules with
//   require('cdsv');

// Proposed intra-module lib dependencies:
//  - lib/base/<file>.js: can be required by all others, requires no other
//    of this project
//  - lib/<dir>/<file>.js: can be required by other files lib/<dir>/,
//    can require other files lib/<dir>/ and lib/base/<file>.js
//  - lib/main.js (this file): can be required by none in lib/ (only in
//    bin/ and test/), can require any other

'use strict';

const backends = require('./backends');
const { odata, cdl, sql, hdi, hdbcds, edm, edmx } = require('./api/main');
const { getArtifactDatabaseNameOf, getElementDatabaseNameOf } = require('./model/csnUtils');
const { traverseCsn } = require('./model/api');
const { createMessageFunctions, sortMessages, sortMessagesSeverityAware, deduplicateMessages } = require('./base/messages');
const { smartId, smartFuncId, delimitedId } = require('./sql-identifier');
const keywords = require( './base/keywords' );

const parseLanguage = require('./language/antlrParser');
const { parseX, compileX, compileSyncX, compileSourcesX, InvocationError } = require('./compiler');
const { fns } = require('./compiler/shared');
const define = require('./compiler/define');
const { isInReservedNamespace } = require("./compiler/builtins");
const finalizeParseCdl = require('./compiler/finalize-parse-cdl');

// The compiler version (taken from package.json)
function version() {
  return require('../package.json').version;
}

const {
  CompilationError,
  messageString,
  messageStringMultiline,
  messageContext,
  hasErrors,
  explainMessage,
  hasMessageExplanation
} = require('./base/messages');

const { compactModel, compactQuery, compactExpr } = require('./json/to-csn')

function parseCdl( cdlSource, filename, options = {} ) {
  options = Object.assign( {}, options, { parseCdl: true } );
  const sources = Object.create(null);
  /** @type {XSN.Model} */
  const model = { sources, options, $functions: {}, $volatileFunctions: {} };
  const messageFunctions = createMessageFunctions( options, 'parse', model );
  model.$messageFunctions = messageFunctions;

  const xsn = parseLanguage( cdlSource, filename, Object.assign( { parseOnly: true }, options ),
                             messageFunctions );
  sources[filename] = xsn;
  fns( model );
  define( model );
  finalizeParseCdl( model );
  messageFunctions.throwWithError();
  return compactModel( model );
}

function parseCql( cdlSource, filename = '<query>.cds', options = {} ) {
  const messageFunctions = createMessageFunctions( options, 'parse' );
  const xsn = parseLanguage( cdlSource, filename, Object.assign( { parseOnly: true }, options ),
                             messageFunctions, 'query' );
  messageFunctions.throwWithError();
  return compactQuery( xsn );
}

function parseExpr( cdlSource, filename = '<expr>.cds', options = {} ) {
  const messageFunctions = createMessageFunctions( options, 'parse' );
  const xsn = parseLanguage( cdlSource, filename, Object.assign( { parseOnly: true }, options ),
                             messageFunctions, 'expr' );
  messageFunctions.throwWithError();
  return compactExpr( xsn );
}

// FIXME: The implementation of those functions that delegate to 'backends' should probably move here
// ATTENTION: Keep in sync with main.d.ts!
module.exports = {
  // Compiler
  version,
  compile: (...args) => compileX(...args).then( compactModel ), // main function
  compileSync: (filenames, dir, options, fileCache) => compactModel( compileSyncX(filenames, dir, options, fileCache) ), // main function
  compileSources: (sourcesDict, options) => compactModel( compileSourcesX(sourcesDict, options) ), // main function
  compactModel: csn => csn,     // for easy v2 migration
  CompilationError,
  sortMessages,
  sortMessagesSeverityAware,
  deduplicateMessages,
  messageString,
  messageStringMultiline,
  messageContext,
  explainMessage,
  hasMessageExplanation,
  InvocationError,    // TODO: make it no error if same file name is provided twice
  hasErrors,

  // Backends
  // TODO: Expose when transformers are switched to CSN
  // toOdataWithCsn: backends.toOdataWithCsn,
  preparedCsnToEdmx : (csn, service, options) => { return backends.preparedCsnToEdmx(csn, service, options).edmx},
  preparedCsnToEdm :  (csn, service, options) => { return backends.preparedCsnToEdm(csn, service, options).edmj},

  // additional API:
  parse: { cdl: parseCdl, cql: parseCql, expr: parseExpr }, // preferred names
  /**
   * @deprecated Use parse.cql instead
   */
  parseToCqn: parseCql,
  /**
   * @deprecated Use parse.expr instead
   */
  parseToExpr: parseExpr,       // deprecated name
  // SNAPI
  for: { odata },
  to: {
    cdl: Object.assign(cdl, {
      keywords: Object.freeze([ ...keywords.cdl ]),
      functions: Object.freeze([ ...keywords.cdl_functions ]),
    }),
    sql: Object.assign(sql, {
      sqlite: { keywords: Object.freeze([ ...keywords.sqlite ] )},
      smartId,
      smartFunctionId: smartFuncId,
      delimitedId,
    }),
    hdi: Object.assign(hdi, {
      keywords: Object.freeze([ ...keywords.hana ]),
    }),
    hdbcds: Object.assign(hdbcds, {
      keywords: Object.freeze([ ...keywords.hdbcds ]),
    }),
    edm,
    edmx
  },
  // Convenience for hdbtabledata calculation in @sap/cds
  getArtifactCdsPersistenceName: getArtifactDatabaseNameOf,
  getElementCdsPersistenceName: getElementDatabaseNameOf,

  // Other API functions:
  traverseCsn,

  // INTERNAL functions for the cds-lsp package and friends - before you use
  // it, you MUST talk with us - there can be potential incompatibilities with
  // new releases (even having the same major version):
  $lsp: { parse: parseX, compile: compileX, getArtifactName: a => a.name },

  // CSN Model related functionality
  model: {
    isInReservedNamespace,
  },
};
