// Things which needs to done for parse.cdl after define()

'use strict';

const { forEachGeneric, forEachMember } = require('../base/model');
const { setLink, setArtifactLink } = require('./utils');


// Used for resolving types in parseCdl mode.
// See resolveTypesForParseCdl().
const parseCdlSpeciallyHandledXsnProps = [ '$queries', 'mixin', 'columns', 'args', 'returns' ];
const parseCdlIgnoredXsnProps = [ 'location', 'query', '$tableAliases' ];

function finalizeParseCdl( model ) {
  // Get simplified "resolve" functionality and the message function:
  const { message, error } = model.$messageFunctions;
  const {
    resolveUncheckedPath,
    resolveTypeArgumentsUnchecked,
    defineAnnotations,
    initMembers,
    extensionsDict,
  } = model.$functions;

  resolveTypesAndExtensionsForParseCdl();
  return;

  function resolveTypesAndExtensionsForParseCdl() {
    const extensions = [];

    // TODO: probably better to loop over extensions of all sources (there is just one)
    for (const name in extensionsDict) {
      for (const ext of extensionsDict[name]) {
        ext.name.absolute = resolveUncheckedPath( ext.name, 'extend', ext );
        // Define annotations of this top-level extension
        defineAnnotations( ext, ext, ext._block );
        mergeAnnotatesForSameArtifact( ext );
        // Initialize members and define annotations in sub-elements.
        initMembers( ext, ext, ext._block, true );
        extensions.push( ext );
        for (const col of ext.columns || []) {
          // Note, no `priority` argument, since we don't apply the extension in the end.
          defineAnnotations( col, col, ext._block );
        }
      }
    }

    forEachGeneric(model, 'definitions', art => resolveTypesForParseCdl(art, art));
    forEachGeneric(model, 'vocabularies', art => resolveTypesForParseCdl(art, art));

    if (extensions.length > 0) {
      model.extensions = extensions;
      model.extensions.forEach(ext => resolveTypesForParseCdl(ext, ext));
    }
  }

  /**
   * Resolve all types in parseCdl mode for the given artifact.
   * `main` refers to the current user/scope, e.g. top-level definition, element, function, etc.
   *
   * @param {*} artifact
   * @param {XSN.Artifact} main
   */
  function resolveTypesForParseCdl(artifact, main) {
    if (!artifact || typeof artifact !== 'object')
      return;

    if (Array.isArray(artifact)) {
      // e.g. `args` array
      artifact.forEach(art => resolveTypesForParseCdl(art, main));
      return;
    }

    if (artifact.kind === 'namespace' || artifact.kind === 'service' || artifact.kind === 'context')
      // Services and context artifacts don't have any types.
      return;

    if (artifact.type)
      resolveTypeUnchecked(artifact, main);

    for (const include of artifact.includes || [])
      resolveUncheckedPath(include, 'include', main);

    if (artifact.target)
      resolveUncheckedPath(artifact.target, 'target', main);

    if (artifact.from) {
      const { from } = artifact;
      // Note: `_from` only contains sources necessary for calculating elements,
      //       not e.g. those from the `where exists` clause.
      resolveUncheckedPath(from, 'from', main);
      resolveTypesForParseCdl(from, main);
    }

    if (artifact.targetAspect) {
      if (artifact.targetAspect.path)
        resolveUncheckedPath(artifact.targetAspect, 'target', main);
      resolveTypesForParseCdl(artifact.targetAspect, main);
    }

    // Recursively go through all XSN properties.  There are a few that need to be
    // handled specifically.  Refer to the code below this loop for details.
    for (const prop in artifact) {
      if (parseCdlSpeciallyHandledXsnProps.includes(prop) || parseCdlIgnoredXsnProps.includes(prop))
        continue;

      // define.js (and initMembers()) initializes annotations.  If there is a duplicate, the
      // annotation is an array in XSN.
      if (prop[0] === '@' && Array.isArray(artifact[prop]))
        chooseAndReportDuplicateAnnotation(artifact, prop);

      if (artifact[prop] && Object.getPrototypeOf(artifact[prop]) === null)
        // Dictionary in XSN
        forEachGeneric(artifact, prop, art => resolveTypesForParseCdl(art, art));
      else
        resolveTypesForParseCdl(artifact[prop], main);
    }

    // `$queries` has a flat structure that we can use instead of going through all `query`.
    // For these query-related properties, we need to keep the reference to the artifact
    // containing it.  Otherwise some type's aren't properly resolved.
    // TODO: If resolveTypeUnchecked is reworked, we may be able to simplify this coding.
    (artifact.$queries || []).forEach( art => resolveTypesForParseCdl(art, artifact) );
    (artifact.columns || []).forEach( art => resolveTypesForParseCdl(art, artifact) );
    forEachGeneric( artifact, 'mixin', art => resolveTypesForParseCdl(art, artifact) );

    // For better error messages for `type of`s in `returns`, we pass the object as the new main.
    resolveTypesForParseCdl(artifact.returns, artifact.returns);

    // Because `args` can be used in different contexts with different semantics,
    // it needs to be handled specifically.
    if (artifact.args && typeof artifact.args === 'object') {
      if (Array.isArray(artifact.args)) {
        // `args` may either be an array (e.g. query 'from' args) ...
        artifact.args.forEach((from) => {
          // ... and could be either inside a `from` ...
          if (from && from.kind === '$tableAlias')
            resolveUncheckedPath(from, 'from', from._main);

          // ... or only params ...
          resolveTypesForParseCdl(from, main);
        });
      }
      else {
        // ... or dictionary (e.g. params)
        forEachGeneric(artifact, 'args', obj => resolveTypesForParseCdl(obj, obj));
      }
    }
  }

  /**
   * Resolves `artWithType.type` in an unchecked manner. Handles `type of` cases.
   * `artWithType` has the `type` property, i.e. it could be an `items` object.
   * `user` is the actual artifact, e.g. entity or element.
   *
   * @param {object} artWithType
   * @param {XSN.Artifact} user
   */
  function resolveTypeUnchecked(artWithType, user) {
    if (!artWithType.type)
      return;
    const root = artWithType.type.path && artWithType.type.path[0];
    if (!root) // parse error
      return;
    // `scope` is only `typeOf` for `type of element` and not
    // `type of Entity:element`. For the latter we can resolve the path
    // without special treatment.
    if (artWithType.type.scope !== 'typeOf') {
      // elem: Type   or   elem: type of Artifact:elem
      const name = resolveUncheckedPath( artWithType.type, 'type', user );
      const type = name && model.definitions[name] || { name: { absolute: name } };
      resolveTypeArgumentsUnchecked( artWithType, type, user );
      return;
    }
    else if (!user._main) {
      error( 'ref-undefined-typeof', [ artWithType.type.location, user ], {},
             'Current artifact has no element to refer to as type' );
      return;
    }
    else if (root.id === '$self' || root.id === '$projection') {
      setArtifactLink( root, user._main );
    }
    else {
      // For better error messages, check for invalid TYPE OFs similarly
      // to how `resolveType()` does.
      let struct = artWithType;
      while (struct.kind === 'element')
        struct = struct._parent;
      if (struct.kind === 'select' || struct !== user._main) {
        message( 'type-unexpected-typeof', [ artWithType.type.location, user ],
                 { keyword: 'type of', '#': struct.kind } );
        return;
      }

      const fake = { name: { absolute: user.name.absolute } };
      // to-csn just needs a fake element whose absolute name and _parent/_main links are correct
      setLink( fake, '_parent', user._parent );
      setLink( fake, '_main', user._main ); // value does not matter...
      setArtifactLink( root, fake );
    }
  }

  function chooseAndReportDuplicateAnnotation(artifact, annoName) {
    for (const anno of artifact[annoName])
      message( 'anno-duplicate', [ anno.name.location, artifact ], { anno: annoName } );

    // Choose any annotation, doesn't matter because of the error above.
    artifact[annoName] = artifact[annoName][0];
  }

  /**
   * For duplicate entries in `annotate {}` blocks, we de-duplicate the entries and merge them.
   * Since it is allowed in "normal" compilations to have e.g.
   * `annotate E with { @anno1 id, @anno2 id }`.
   *
   * @param {object} ext
   */
  function mergeAnnotatesForSameArtifact( ext ) {
    if (!ext || typeof ext !== 'object')
      return;

    forEachMember(ext, sub => mergeAnnotatesForSameArtifact(sub));

    if (ext.$annotations && Array.isArray(ext.$duplicates)) {
      const annotates = ext.$duplicates.filter(val => (val.kind === 'annotate'));
      for (const dup of annotates) {
        ext.$annotations.push(...dup.$annotations);
        delete dup.$annotations;
      }
      ext.$duplicates = ext.$duplicates.filter(val => (val.kind !== 'annotate'));
      if (ext.$duplicates.length === 0)
        delete ext.$duplicates;
    }
  }
}

module.exports = finalizeParseCdl;
