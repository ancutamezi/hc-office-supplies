// Compiler phase "resolve": resolve all references

// The resolve phase tries to find the artifacts (and elements) for all
// references in the augmented CSN.  If there are unresolved references, this
// compiler phase fails with an error containing a vector of corresponding
// messages (alternatively, we could just store this vector in the CSN).

// References are resolved according to the scoping rules of CDS specification.
// That means, the first name of a reference path is not only searched in the
// current environments, but also in the parent environments, with the source
// as second-last, and the environment for builtins as the last search
// environment.

// For all type references, we set the property `type._artifact`, the latter is
// the actual type definition.

// If the referred type definition has a `parameters` property, we use it to
// transform the `$typeArgs` property (sibling to the `type` property`) to
// named properties.  See function `resolveTypeExpr` below for details.

// Example 'file.cds' (see './define.js' for the CSN before "resolve"):
//   type C { elem: String(4); }
//
// The corresponding definition of element "elem" looks as follows:
//   {
//     kind: 'element',
//     name: { id: 'elem', component: 'elem', location: ... }
//     type: { absolute: 'cds.String', _artifact: {...}, path: ...},
//     length: { val: 4, location: <of the number literal> },
//     location: ..., _parent: ...
//   }

// Potential file names:
// lookup-refs / memorize:  main refs loop (phase 2)
// monitor-refs: resolve-refs (not leading to new defs/elems)
// repair-props: rewrite, late extensions
// test-model: cycle detection, late tests (currently in checks)

'use strict';

const {
  isDeprecatedEnabled,
  forEachDefinition,
  forEachMember,
  forEachGeneric,
  forEachInOrder,
} = require('../base/model');
const { dictAdd } = require('../base/dictionaries');
const { dictLocation } = require('../base/location');
const { searchName, weakLocation } = require('../base/messages');
const { combinedLocation } = require('../base/location');
const { forEachValue } = require('../utils/objectUtils');
const { typeParameters } = require('./builtins');

const { kindProperties } = require('./base');
const {
  setLink,
  setArtifactLink,
  pathName,
  linkToOrigin,
  setMemberParent,
  withAssociation,
  storeExtension,
  dependsOn,
  dependsOnSilent,
  testExpr,
  targetMaxNotOne,
  traverseQueryPost,
} = require('./utils');

const detectCycles = require('./cycle-detector');
const layers = require('./moduleLayers');

const $location = Symbol.for('cds.$location');

const annotationPriorities = {
  define: 1, extend: 2, annotate: 2, edmx: 3,
};
const $inferred = Symbol.for('cds.$inferred');

// Export function of this file.  Resolve type references in augmented CSN
// `model`.  If the model has a property argument `messages`, do not throw
// exception in case of an error, but push the corresponding error object to
// that property (should be a vector).
function resolve( model ) {
  const { options } = model;
  // Get shared functionality and the message function:
  const {
    info, warning, error, message,
  } = model.$messageFunctions;
  const {
    resolvePath,
    defineAnnotations,
    attachAndEmitValidNames,
    lateExtensions,
    effectiveType,
    directType,
    resolveType,
    resolveTypeArgumentsUnchecked,
    populateQuery,
  } = model.$functions;
  const { environment } = model.$volatileFunctions;
  Object.assign( model.$functions, {
    resolveExpr,
  } );

  /** @type {any} may also be a boolean */

  // behavior depending on option `deprecated`:
  const enableExpandElements = !isDeprecatedEnabled( options, 'noElementsExpansion' );
  // TODO: we should get rid of noElementsExpansion soon; both
  // beta.nestedProjections and beta.universalCsn do not work with it.

  return doResolve();

  function doResolve() {
    // Phase 1: check paths in usings has been moved to kick-start.js Phase 2:
    // calculate/init view elements & collect views in order:
    // TODO: It might be that we need to call propagateKeyProps() and
    // addImplicitForeignKeys() in populate.js, as we might need to know the
    // foreign keys in populate.js (foreign key access w/o JOINs).

    // Phase 3: calculate keys along simple queries in collected views:
    model._entities.forEach( propagateKeyProps );
    // While most dependencies leading have been added at this point, new
    // cycles could be added later (e.g. via assocs in where conditions),
    // i.e. keep cycle detection with messages at the end (or after phase 4).

    // Phase 4: resolve all artifacts:
    forEachDefinition( model, resolveRefs );
    forEachGeneric( model, 'vocabularies', resolveRefs );
    // for builtin types
    forEachGeneric( model.definitions.cds, '_subArtifacts', chooseAnnotationsInArtifact);
    forEachGeneric( model.definitions['cds.hana'], '_subArtifacts', chooseAnnotationsInArtifact);
    // Phase 6: apply ANNOTATE on autoexposed entities and unknown artifacts:
    lateExtensions( annotateMembers );
    if (model.extensions)
      model.extensions.map( annotateUnknown );
    // Phase 7: report cyclic dependencies:
    detectCycles( model.definitions, ( user, art, location ) => {
      if (location) {
        error( 'ref-cyclic', [ location, user ], { art }, {
          std: 'Illegal circular reference to $(ART)',
          element: 'Illegal circular reference to element $(MEMBER) of $(ART)',
        });
      }
    });
    return model;
  }

  //--------------------------------------------------------------------------
  // Phase 3: calculate propagated KEYs
  //--------------------------------------------------------------------------

  function propagateKeyProps( view ) {
    // Second argument true ensure that `key` is only propagated along simple
    // view, i.e. ref or subquery in FROM, not UNION or JOIN.
    traverseQueryPost( view.query, true, ( query ) => {
      if (!withExplicitKeys( query ) && inheritKeyProp( query ) &&
          withKeyPropagation( query )) // now the part with messages
        inheritKeyProp( query, true );
    } );
  }

  function withExplicitKeys( query ) {
    for (const name in query.elements) {
      const elem = query.elements[name];
      if (elem.key && !elem.$duplicates) // also those from includes
        return true;
    }
    return false;
  }

  function inheritKeyProp( query, doIt ) {
    for (const name in query.elements) {
      const elem = query.elements[name];
      // no key prop for duplicate elements or additional specified elements:
      if (elem.$duplicates || !elem.value)
        continue;
      const nav = pathNavigation( elem.value );
      if (!nav.navigation)
        continue;            // undefined, expr, $magic, :const, $self (!), $self.elem
      const { item } = nav;
      if (item !== elem.value.path[elem.value.path.length - 1])
        continue;         // having selected a sub elem / navigated along assoc
      const { key } = item._artifact;
      if (key) {
        if (!doIt)
          return true;
        elem.key = { location: elem.value.location, val: key.val, $inferred: 'query' };
      }
    }
    return false;
  }

  function primarySourceNavigation( aliases ) {
    for (const name in aliases)
      return aliases[name].elements;
    return undefined;
  }

  function withKeyPropagation( query ) {
    const { from } = query;
    if (!from)                  // parse error SELECT FROM <EOF>
      return false;

    let propagateKeys = true;   // used instead early RETURN to get more messages
    const toMany = withAssociation( from, targetMaxNotOne, true );
    if (toMany) {
      propagateKeys = false;
      info( 'query-from-many', [ toMany.location, query ], { art: toMany },
            {
              // eslint-disable-next-line max-len
              std: 'Selecting from to-many association $(ART) - key properties are not propagated',
              // eslint-disable-next-line max-len
              element: 'Selecting from to-many association $(MEMBER) of $(ART) - key properties are not propagated',
            } );
    }
    // Check that all keys from the source are projected:
    const notProjected = [];    // we actually push to the array
    const navElems = primarySourceNavigation( query.$tableAliases );
    for (const name in navElems) {
      const nav = navElems[name];
      if (nav.$duplicates)
        continue;
      const { key } = nav._origin;
      if (key && key.val && !(nav._projections && nav._projections.length))
        notProjected.push( nav.name.id );
    }
    if (notProjected.length) {
      propagateKeys = false;
      info( 'query-missing-keys', [ from.location, query ], { names: notProjected },
            {
              std: 'Keys $(NAMES) have not been projected - key properties are not propagated',
              one: 'Key $(NAMES) has not been projected - key properties are not propagated',
            } );
    }
    // Check that there is no to-many assoc used in select item:
    for (const name in query.elements) {
      const elem = query.elements[name];
      if (!elem.$inferred && elem.value &&
          testExpr( elem.value, selectTest, () => false ))
        propagateKeys = false;
    }
    return propagateKeys;

    function selectTest( expr ) {
      const art = withAssociation( expr, targetMaxNotOne );
      if (art) {
        info( 'query-navigate-many', [ art.location, query ], { art },
              {
                // eslint-disable-next-line max-len
                std: 'Navigating along to-many association $(ART) - key properties are not propagated',
                // eslint-disable-next-line max-len
                element: 'Navigating along to-many association $(MEMBER) of $(ART) - key properties are not propagated',
                // eslint-disable-next-line max-len
                alias: 'Navigating along to-many mixin association $(MEMBER) - key properties are not propagated',
              } );
      }
      return art;
    }
  }

  //--------------------------------------------------------------------------
  // Phase 4:
  //--------------------------------------------------------------------------

  function adHocOrMainKind( elem ) {
    const main = elem._main;
    if (main) {
      do {
        elem = elem._parent;
        if (elem.targetAspect)
          return 'aspect';        // ad-hoc composition target aspect
      } while (elem !== main);
    }
    return elem.kind;
  }
  // TODO: have $applied/$extension/$status on extension with the following values
  //  - 'unknown': artifact to extend/annotate is not defined or contains unknown member
  //  - 'referred': contains annotation for element of referred type (not yet supported)
  //  - 'inferred': only contains extension for known member, but some inferred ones
  //    (inferred = elements from structure includes, query elements)
  //  - 'original': only contains extensions on non-inferred members

  // Resolve all references in artifact or element `art`.  Do so recursively in
  // all sub elements.
  // TODO: make this function smaller
  function resolveRefs( art ) {
    // console.log(message( null, art.location, art, {}, 'Info','REFS').toString())
    // console.log(message( null, art.location, art, {target:art.target}, 'Info','RR').toString())
    const parent = art._parent;
    const allowedInMain = [ 'entity', 'aspect' ].includes( adHocOrMainKind( art ) );
    const isTopLevelElement = parent && (parent.kind !== 'element' || parent.targetAspect);
    if (art.key && art.key.val && !art.key.$inferred && !(allowedInMain && isTopLevelElement)) {
      warning( 'unexpected-key', [ art.key.location, art ],
               { '#': allowedInMain ? 'sub' : 'std' }, {
                 std: 'KEY is only supported for elements in an entity or an aspect',
                 sub: 'KEY is only supported for top-level elements',
               });
    }
    if (art.targetAspect && !(allowedInMain && isTopLevelElement)) {
      message( 'type-managed-composition', [ art.targetAspect.location, art ],
               { '#': allowedInMain ? 'sub' : 'std' } );
    }
    if (art.includes && !allowedInMain) {
      for (const include of art.includes) {
        const struct = include._artifact;
        if (struct && struct.kind !== 'type' && struct.elements &&
            Object.values( struct.elements ).some( e => e.targetAspect)) {
          message( 'type-managed-composition', [ include.location, art ],
                   { '#': struct.kind, art: struct } );
        }
      }
    }
    let obj = art;
    if (obj.type)             // TODO: && !obj.type.$inferred ?
      resolveTypeExpr( obj, art );
    const type = effectiveType( obj ); // make sure implicitly redirected target exists
    if (!obj.items && type && type.items && enableExpandElements) {
      // TODO: shouldn't be this part of populate.js ?
      const items = {
        location: weakLocation( (obj.type || obj).location ),
        $inferred: 'expand-items',
      };
      setLink( items, '_outer', obj );
      setLink( items, '_origin', type.items );
      obj.items = items;
      obj.$expand = 'origin';
    }
    if (obj.items) {            // TODO: make this a while in v2 (also items proxy)
      obj = obj.items || obj; // the object which has type properties
      if (enableExpandElements)
        effectiveType(obj);
    }
    if (obj.type) {             // TODO: && !obj.type.$inferred ?
      if (obj !== (art.returns || art)) // not already checked
        resolveTypeExpr( obj, art );
      // typeOf unmanaged assoc?  TODO: is this the right place to check this?
      // (probably better in rewriteAssociations)
      const elemtype = obj.type._artifact;
      if (elemtype && effectiveType( elemtype )) {
        const assocType = getAssocSpec( elemtype ) || {};
        if (assocType.on && !obj.on)
          obj.on = { $inferred: 'rewrite' };
        if (assocType.targetAspect) {
          error( 'composition-as-type-of', [ obj.type.location, art ], {},
                 'A managed aspect composition element can\'t be used as type' );
          return;
        }
        else if (assocType.on) {
          error( 'assoc-as-type-of', [ obj.type.location, art ], {},
                 'An unmanaged association can\'t be used as type' );
          return;
        }

        // Check if relational type is missing its target or if it's used directly.
        if (elemtype.category === 'relation' && obj.type.path.length > 0 &&
          !obj.target && !obj.targetAspect) {
          const isCsn = (obj._block && obj._block.$frontend === 'json');
          error('type-missing-target', [ obj.type.location, obj ],
                { '#': isCsn ? 'csn' : 'std', type: elemtype.name.absolute }, {
                  // We don't say "use 'association to <target>" because the type could be used
                  // in action parameters, etc. as well.
                  std: 'The type $(TYPE) can\'t be used directly because it\'s compiler internal',
                  csn: 'Type $(TYPE) is missing a target',
                });
        }
      }
    }
    if (obj.target) {
      // console.log(obj.name,obj._origin.name)
      if (obj._origin && obj._origin.$inferred === 'REDIRECTED')
        resolveTarget( art, obj._origin );
      // console.log(error( 'test-target', [ obj.location, obj ],
      //   { target: obj.target, kind: obj.kind }, 'Target: $(TARGET), Kind $(KIND)'));
      if (!obj.target.$inferred || obj.target.$inferred === 'aspect-composition')
        resolveTarget( art, obj );
      else
        // TODO: better write when inferred target must be redirected
        resolveRedirected( obj, obj.target._artifact );
    }
    else if (obj.kind === 'mixin') {
      error( 'non-assoc-in-mixin', [ (obj.type || obj.name).location, art ], {},
             'Only unmanaged associations are allowed in mixin clauses' );
    }
    if (art.targetElement) {    // in foreign keys
      const target = parent && parent.target;
      if (target && target._artifact) {
        // we just look in target for the path
        // TODO: also check that we do not follow associations? no args, no filter
        resolvePath( art.targetElement, 'targetElement', art,
                     environment( target._artifact ), target._artifact );
      }
    }
    // Resolve projections/views
    // if (art.query)console.log( info( null, [art.query.location,art.query], 'VQ:' ).toString() );

    if (art.$queries)
      art.$queries.forEach( resolveQuery );

    if (obj.type || obj._origin || obj.value && obj.value.path || obj.elements) // typed artifacts
      effectiveType(obj);  // set _effectiveType if appropriate, (future?): copy elems if extended

    if (obj.elements) {           // silent dependencies
      forEachGeneric( obj, 'elements', elem => dependsOnSilent( art, elem ) );
    }
    else if (obj.targetAspect && obj.targetAspect.elements) { // silent dependencies
      forEachGeneric( obj.targetAspect, 'elements', elem => dependsOnSilent( art, elem ) );
    }
    if (obj.foreignKeys) {       // silent dependencies
      forEachGeneric( obj, 'foreignKeys', (elem) => {
        dependsOnSilent( art, elem );
      } );
      addForeignKeyNavigations( art );
    }

    resolveExpr( art.default, 'default', art );
    resolveExpr( art.value, 'expr', art, undefined, art.expand || art.inline );
    if (art.value && !art.type && !art.target && !art.elements)
      inferTypeFromCast( art );

    if (art.kind === 'element' || art.kind === 'mixin')
      effectiveType( art );

    annotateMembers( art );     // TODO recheck - recursively, but also forEachMember below
    chooseAnnotationsInArtifact( art );

    forEachMember( art, resolveRefs, art.targetAspect );

    // Set '@Core.Computed' in the Core Compiler to have it propagated...
    if (art.kind !== 'element' || art['@Core.Computed'])
      return;
    if (art.virtual && art.virtual.val ||
        art.value &&
        (!art.value._artifact || !art.value.path || // in localization view: _artifact, but no path
          art.value._artifact.kind === 'builtin' || art.value._artifact.kind === 'param' )) {
      art['@Core.Computed'] = {
        name: {
          path: [ { id: 'Core.Computed', location: art.location } ],
          location: art.location,
        },
        $inferred: '$generated',
      };
    }
  }

  // Return type containing the assoc spec (keys, on); note that no
  // propagation/rewrite has been done yet, cyclic dependency must have been
  // checked before!
  function getAssocSpec( type ) {
    const cyclic = new Set(); // TODO(#8942): May not be necessary if effectiveType() is adapted.
    // only to be called without cycles
    while (type && !cyclic.has(type)) {
      cyclic.add(type);
      if (type.on || type.foreignKeys || type.targetAspect)
        return type;
      type = directType( type );
    }
    return null;
  }

  function inferTypeFromCast( elem ) {
    // TODO: think about CAST checks in checks.js
    const { op, type } = elem.value;
    if (op && op.val === 'cast' && type && type._artifact) {
      // op.val is also correctly set with CSN input
      elem.type = { ...type, $inferred: 'cast' };
      setArtifactLink( elem.type, type._artifact );
      for (const prop of typeParameters.list) {
        if (elem.value[prop])
          elem[prop] = { ...elem.value[prop], $inferred: 'cast' };
      }
    }
  }

  // Phase 4 - annotations ---------------------------------------------------

  function annotateUnknown( ext ) {
    // extensions may have annotations for elements/actions/... which may
    // themselves may be unknown
    forEachMember(ext, annotateUnknown);

    if (ext.$extension) // extension for known artifact -> already applied
      return;
    annotateMembers( ext );
    for (const prop in ext) {
      if (prop.charAt(0) === '@')
        chooseAssignment( prop, ext );
    }
  }

  /**
   * @param {XSN.Artifact} art
   * @param {XSN.Extension[]} [extensions]
   * @param {string} [prop]
   * @param {string} [name]
   * @param {object} [parent]
   * @param {string} [kind]
   */
  function annotateMembers( art, extensions, prop, name, parent, kind ) {
    const showMsg = !art && parent && parent.kind !== 'annotate';
    if (!art && extensions && extensions.length) {
      if (Array.isArray( parent ))
        return;
      const parentExt = extensionFor(parent);
      art = parentExt[prop] && parentExt[prop][name];
      if (!art) {
        art = {
          kind,                 // for setMemberParent()
          name: { id: name, location: extensions[0].name.location },
          location: extensions[0].location,
        };
        setMemberParent( art, name, parentExt, prop );
        art.kind = 'annotate';  // after setMemberParent()!
      }
    }

    for (const ext of extensions || []) {
      if ('_artifact' in ext.name) // already applied
        continue;
      setArtifactLink( ext.name, art );

      if (art) {
        defineAnnotations( ext, art, ext._block, ext.kind );
        // eslint-disable-next-line no-shadow
        forEachMember( ext, ( elem, name, prop ) => {
          storeExtension( elem, name, prop, art, ext._block );
        });
      }
      if (showMsg) {
        // somehow similar to checkDefinitions():
        const feature = kindProperties[parent.kind][prop];
        if (prop === 'elements' || prop === 'enum') {
          if (!feature) {
            warning( 'anno-unexpected-elements', [ ext.name.location, art ], {},
                     'Elements only exist in entities, types or typed constructs' );
          }
          else {
            notFound( 'anno-undefined-element', ext.name.location, art,
                      { art: searchName( parent, name, parent.enum ? 'enum' : 'element' ) },
                      parent.elements || parent.enum );
          }
        }
        else if (prop === 'actions') {
          if (!feature) {
            warning( 'anno-unexpected-actions', [ ext.name.location, art ], {},
                     'Actions and functions only exist top-level and for entities' );
          }
          else {
            notFound( 'anno-undefined-action', ext.name.location, art,
                      { art: searchName( parent, name, 'action' ) },
                      parent.actions );
          }
        }
        else if (!feature) {
          warning( 'anno-unexpected-params', [ ext.name.location, art ], {},
                   'Parameters only exist for actions or functions' );
        } // TODO: entities betaMod
        else {
          notFound( 'anno-undefined-param', ext.name.location, art,
                    { art: searchName( parent, name, 'param' ) },
                    parent.params );
        }
      }
    }
    if (art && art._annotate) {
      if (art.kind === 'action' || art.kind === 'function') {
        expandParameters( art );
        if (art.returns)
          effectiveType( art.returns );
      }
      const aor = art.returns || art;
      const obj = aor.items || aor.targetAspect || aor;
      // Currently(?), effectiveType() does not calculate the effective type of
      // its line item:
      effectiveType( obj );
      if (art._annotate.elements)
        setExpandStatusAnnotate( aor, 'annotate' );
      annotate( obj, 'element', 'elements', 'enum', art );
      annotate( art, 'action', 'actions' );
      annotate( art, 'param', 'params' );
      // const { returns } = art._annotate;
      // if (returns) {
      //   const dict = returns.elements;
      //   const env = obj.returns && obj.returns.elements || null;
      //   for (const n in dict)
      //     annotateMembers( env && env[n], dict[n], 'elements', n, parent, 'element' );
      // }
    }
    return;

    function notFound( msgId, location, address, args, validDict ) {
      // TODO: probably move this to shared.js and use for EXTEND, too
      const msg = message( msgId, [ location, address ], args );
      attachAndEmitValidNames(msg, validDict);
    }

    // eslint-disable-next-line no-shadow
    function annotate( obj, kind, prop, altProp, parent = obj ) {
      const dict = art._annotate[prop];
      const env = obj[prop] || altProp && obj[altProp] || null;
      for (const n in dict)
        annotateMembers( env && env[n], dict[n], prop, n, parent, kind );
    }
  }

  function setExpandStatusAnnotate( elem, status ) {
    for (;;) {
      if (elem.$expand === status)
        return;                 // already set
      elem.$expand = status;    // meaning: expanded, containing annos
      for (let line = elem.items; line; line = line.items)
        line.$expand = status; // to-csn just uses the innermost $expand
      if (!elem._main)
        return;
      elem = elem._parent;
    }
  }


  function expandParameters( action ) {
    // see also expandElements()
    if (!enableExpandElements || !effectiveType( action ))
      return;
    const chain = [];
    // Should we be able to consider params and returns separately?
    // Probably not, let to-csn omit unchanged params/returns.
    while (action._origin && !action.params) {
      chain.push( action );
      action = action._origin;
    }
    chain.reverse();
    for (const art of chain) {
      const origin = art._origin;
      if (!art.params && origin.params) {
        for (const name in origin.params) {
          // TODO: we could check _annotate here to decide whether we really
          // not to create proxies
          const orig = origin.params[name];
          linkToOrigin( orig, name, art, 'params', weakLocation( orig.location ), true )
            .$inferred = 'expand-param';
        }
      }
      if (!art.returns && origin.returns) {
        // TODO: make linkToOrigin() work for returns, kind/name?
        const location = weakLocation( origin.returns.location );
        art.returns = {
          name: Object.assign( {}, art.name, { id: '', param: '', location } ),
          kind: 'param',
          location,
          $inferred: 'expand-param',
        };
        setLink( art.returns, '_parent', art );
        setLink( art.returns, '_main', art._main || art );
        setLink( art.returns, '_origin', origin.returns );
      }
    }
  }

  function extensionFor( art ) {
    if (art.kind === 'annotate')
      return art;
    if (art._extension)
      return art._extension;

    // $extension means: already applied
    const ext = {
      kind: art.kind,           // set kind for setMemberParent()
      $extension: 'exists',
      location: art.location,    // location( extension to existing art ) = location(art)
    };
    const { location } = art.name;
    if (!art._main) {
      ext.name = {
        path: [ { id: art.name.absolute, location } ],
        location,
        absolute: art.name.absolute,
      };
      if (model.extensions)
        model.extensions.push(ext);
      else
        model.extensions = [ ext ];
    }
    else {
      ext.name = { id: art.name.id, location };
      const parent = extensionFor( art._parent );
      const kind = kindProperties[art.kind].normalized || art.kind;
      // enums would be first in elements
      if ( parent[kindProperties[kind].dict] &&
           parent[kindProperties[kind].dict][art.name.id] )
        throw new Error(art.name.id);
      setMemberParent( ext, art.name.id, parent, kindProperties[kind].dict );
    }
    ext.kind = 'annotate';    // after setMemberParent()!
    setLink( art, '_extension', ext );
    setArtifactLink( ext.name, art );
    if (art.returns)
      ext.$syntax = 'returns';
    return ext;
  }

  /**
   * Goes through all (applied) annotations in the given artifact and chooses one
   * if multiple exist according to the module layer.
   *
   * @param {XSN.Artifact} art
   */
  function chooseAnnotationsInArtifact( art ) {
    for (const prop in art) {
      if (prop.charAt(0) === '@')
        chooseAssignment( prop, art );
    }
  }

  function chooseAssignment( annoName, art ) {
    // TODO: getPath an all names
    const anno = art[annoName];
    if (!Array.isArray(anno)) { // just one assignment -> use it
      if (removeEllipsis( anno )) {
        error( 'anno-unexpected-ellipsis',
               [ anno.name.location, art ], { code: '...' } );
      }
      return;
    }
    // sort assignment according to layer
    const layerAnnos = Object.create(null);
    for (const a of anno) {
      const layer = layers.layer( a._block );
      const name = (layer) ? layer.realname : '';
      const done = layerAnnos[name];
      if (done)
        done.annos.push( a );
      else
        layerAnnos[name] = { layer, annos: [ a ] };
    }
    mergeArrayInSCCs();
    art[annoName] = mergeLayeredArrays( findLayerCandidate( ) );
    return;

    // Merge annotations in each layer, i.e. multiple annotations in the same layer are
    // stored in an array and need to be merged before different layers can be merged.
    function mergeArrayInSCCs( ) {
      let pos = 0;
      forEachValue(layerAnnos, (layer) => {
        const mergeSource = layer.annos.find(v => (v.$priority === undefined ||
           annotationPriorities[v.$priority] === annotationPriorities.define));
        if (mergeSource) {
          // If the source annotation (at 'define' level) contains an ellipsis,
          // there is no base to apply to.
          if (removeEllipsis( mergeSource )) {
            error( 'anno-unexpected-ellipsis',
                   [ mergeSource.name.location, art ], { code: '...' } );
          }
          // merge source into ellipsis array annotates
          layer.annos.forEach( (mergeTarget) => {
            if (mergeTarget.$priority &&
                annotationPriorities[mergeTarget.$priority] > annotationPriorities.define) {
              pos = findEllipsis( mergeTarget );
              if (pos > -1) {
                if (mergeSource.literal !== 'array') {
                  error( 'anno-mismatched-ellipsis',
                         [ mergeSource.name.location, art ], { code: '...' } );
                  return;
                }
                mergeTarget.val = mergeArrayValues( mergeSource.val, mergeTarget.val );
              }
            }
          });
        }
      });
    }

    function mergeLayeredArrays( mergeTarget ) {
      if (mergeTarget.literal === 'array') {
        let layer = layers.layer( mergeTarget._block );
        delete layerAnnos[(layer) ? layer.realname : ''];
        let pos = findEllipsis( mergeTarget );
        let hasRun = false;
        while (pos > -1 && Object.keys( layerAnnos ).length ) {
          hasRun = true;
          const mergeSource = findLayerCandidate();
          if (mergeSource.literal !== 'array') {
            error( 'anno-mismatched-ellipsis',
                   [ mergeSource.name.location, art ], { code: '...' } );
            return mergeTarget;
          }
          mergeTarget.val = mergeArrayValues( mergeSource.val, mergeTarget.val );
          layer = layers.layer( mergeSource._block );
          delete layerAnnos[(layer) ? layer.realname : ''];
          pos = findEllipsis( mergeTarget );
        }
        // All layers were processed. Remove excess ellipsis.
        if (removeEllipsis( mergeTarget, pos ) && hasRun) {
          // There shouldn't be any ellipsis or we don't have a base annotation.
          // But only if the loop above has run. Otherwise the in-layer merge
          // already warned about this case.
          message( 'anno-unexpected-ellipsis-layers',
                   [ mergeTarget.name.location, art ], { code: '...' } );
        }
      }
      return mergeTarget;
    }

    function mergeArrayValues( previousValue, arraySpec ) {
      let prevPos = 0;
      const result = [];
      for (const item of arraySpec) {
        const ell = item && item.literal === 'token' && item.val === '...';
        if (!ell) {
          result.push( item );
        }
        else {
          let upToSpec = item.upTo && checkUpToSpec( item.upTo, true );
          while (prevPos < previousValue.length) {
            const prevItem = previousValue[prevPos++];
            result.push( prevItem );
            if (upToSpec && prevItem && equalUpTo( prevItem, item.upTo)) {
              upToSpec = false;
              break;
            }
          }
          if (upToSpec) {       // non-matched UP TO
            warning( null, [ item.upTo.location, art ], { anno: annoName, code: '... up to' },
                     'The $(CODE) value does not match any item in the base annotation $(ANNO)' );
          }
        }
      }
      return result;
    }

    function checkUpToSpec( upToSpec, trueIfFullUpTo ) {
      const { literal } = upToSpec;
      if (trueIfFullUpTo !== true) { // inside struct of UP TO
        if (literal !== 'struct' && literal !== 'array' )
          return true;
      }
      else if (literal === 'struct') {
        return Object.values( upToSpec.struct ).every( checkUpToSpec );
      }
      else if (literal !== 'array' && literal !== 'boolean' && literal !== 'null') {
        return true;
      }
      error( null, [ upToSpec.location, art ],
             { anno: annoName, code: '... up to', '#': literal },
             {
               std: 'Unexpected $(CODE) value type in the assignment of $(ANNO)',
               array: 'Unexpected array as $(CODE) value in the assignment of $(ANNO)',
               // eslint-disable-next-line max-len
               struct: 'Unexpected structure as $(CODE) structure property value in the assignment of $(ANNO)',
               boolean: 'Unexpected boolean as $(CODE) value in the assignment of $(ANNO)',
               null: 'Unexpected null as $(CODE) value in the assignment of $(ANNO)',
             } );
      return false;
    }

    function equalUpTo( previousItem, upToSpec ) {
      if (!previousItem)
        return false;
      if ('val' in upToSpec) {
        if (previousItem.val === upToSpec.val) // enum, struct and ref have no val
          return true;
        const typeUpTo = typeof upToSpec.val;
        const typePrev = typeof previousItem.val;
        if (typeUpTo === 'number')
          return typePrev === 'string' && previousItem.val === upToSpec.val.toString();
        if (typePrev === 'number')
          return typeUpTo === 'string' && upToSpec.val === previousItem.val.toString();
      }
      else if (upToSpec.path) {
        return previousItem.path && normalizeRef( previousItem ) === normalizeRef( upToSpec );
      }
      else if (upToSpec.sym) {
        return previousItem.sym && previousItem.sym.id === upToSpec.sym.id;
      }
      else if (upToSpec.struct && previousItem.struct) {
        return Object.entries( upToSpec.struct )
          .every( ([ n, v ]) => equalUpTo( previousItem.struct[n], v ) );
      }
      return false;
    }

    function normalizeRef( node ) { // see to-csn.js
      const ref = pathName( node.path );
      return node.variant ? `${ ref }#${ node.variant.id }` : ref;
    }

    function removeEllipsis(a, pos = findEllipsis( a )) {
      let count = 0;
      while (a.literal === 'array' && pos > -1) {
        count++;
        a.val.splice(pos, 1);
        pos = findEllipsis( a );
      }
      return count;
    }

    function findEllipsis(a) {
      return (a.literal === 'array' && a.val)
        ? a.val.findIndex(v => v.literal === 'token' && v.val === '...') : -1;
    }

    function findLayerCandidate() {
      // collect assignments of upper layers (are in no _layerExtends)
      const exts = Object.keys( layerAnnos ).map( layerExtends );
      const allExtends = Object.assign( Object.create(null), ...exts );
      const collected = [];
      for (const name in layerAnnos) {
        if (!(name in allExtends))
          collected.push( prioritizedAnnos( layerAnnos[name].annos ) );
      }
      // inspect collected assignments - choose the one or signal error
      const justOnePerLayer = collected.every( annos => annos.length === 1);
      if (!justOnePerLayer || collected.length > 1) {
        for (const annos of collected) {
          for (const a of annos ) {
          // Only the message ID is different.
            if (justOnePerLayer) {
              message( 'anno-duplicate-unrelated-layer',
                       [ a.name.location, art ], { anno: annoName },
                       'Duplicate assignment with $(ANNO)' );
            }
            else {
              message( 'anno-duplicate', [ a.name.location, art ], { anno: annoName } );
            }
          }
        }
      }
      return collected[0][0];  // just choose any one with error
    }

    function layerExtends( name ) {
      const { layer } = layerAnnos[name];
      return layer && layer._layerExtends;
    }
  }

  function prioritizedAnnos( annos ) {
    let prio = 0;
    let r = [];
    for (const a of annos) {
      const p = annotationPriorities[a.$priority] || annotationPriorities.define;
      if (p === prio) {
        r.push(a);
      }
      else if (p > prio) {
        r = [ a ];
        prio = p;
      }
    }
    return r;
  }

  // Phase 4 - queries and associations --------------------------------------

  function resolveQuery( query ) {
    if (!query._main)           // parse error
      return;
    traverseQueryPost( query, null, populateQuery ); // TODO: still necessary?
    forEachGeneric( query, '$tableAliases', ( alias ) => {
      // console.log( info( null, [alias.location,alias], 'SQA:' ).toString() );
      if (alias.kind === 'mixin')
        resolveRefs( alias );   // mixin element
      else if (alias.kind !== '$self')
        // pure path has been resolved, resolve args and filter now:
        resolveExpr( alias, 'from', query._parent );
    } );
    for (const col of query.$inlines)
      resolveExpr( col.value, 'expr', col, undefined, true );
    // for (const col of query.$inlines)
    //   if (!col.value.path) throw Error(col.name.element)
    if (query !== query._main._leadingQuery) // will be done later
      forEachGeneric( query, 'elements', resolveRefs );
    if (query.from)
      resolveJoinOn( query.from );
    if (query.where)
      resolveExpr( query.where, 'expr', query, query._combined );
    if (query.groupBy)
      resolveBy( query.groupBy, 'expr' );
    resolveExpr( query.having, 'expr', query, query._combined );
    if (query.$orderBy)       // ORDER BY from UNION:
      // TODO clarify: can I access the tab alias of outer queries?  If not:
      // 4th arg query._main instead query._parent.
      resolveBy( query.$orderBy, 'order-by-union', query.elements, query._parent );
    if (query.orderBy) {       // ORDER BY
    // search in `query.elements` after having checked table aliases of the current query
      resolveBy( query.orderBy, 'expr', query.elements );
      // TODO: disallow resulting element ref if in expression!
      // Necessary to check it in the compiler as it might work with other semantics on DB!
      // (we could downgrade it to a warning if name is equal to unique source element name)
      // TODO: Some helping text mentioning an alias name would be useful
    }
    return;

    function resolveJoinOn( join ) {
      if (join && join.args) {  // JOIN
        for (const j of join.args)
          resolveJoinOn( j );
        if (join.on)
          resolveExpr( join.on, 'expr', query, query._combined );
          // TODO: check restrictions according to join "query"
      }
    }

    // Note the strange name resolution (dynamic part) for ORDER BY: the same
    // as for select items if it is an expression, but first look at select
    // item alias (i.e. like `$projection.NAME` if it is a path.  If it is an
    // ORDER BY of an UNION, do not allow any dynamic path in an expression,
    // and only allow the elements of the leading query if it is a path.
    //
    // This seem to be similar, but different in SQLite 3.22.0: ORDER BY seems
    // to bind stronger than UNION (see <SQLite>/src/parse.y), and the name
    // resolution seems to use select item aliases from all SELECTs of the
    // UNION (see <SQLite>/test/tkt2822.test).
    function resolveBy( array, mode, pathDict, q ) {
      for (const value of array ) {
        if (value)
          resolveExpr( value, mode, q || query, value.path && pathDict );
      }
    }
  }

  function resolveTarget( art, obj ) {
    if (art !== obj && obj.on && obj.$inferred !== 'REDIRECTED') {
      message( 'assoc-in-array', [ obj.on.location, art ], {},
               // TODO: also check parameter parent, two messages?
               'An association can\'t be used for arrays or parameters' );
      setArtifactLink( obj.target, undefined );
      return;
    }
    const target = resolvePath( obj.target, 'target', art );

    if (obj._pathHead && obj.type && !obj.type.$inferred && art._main && art._main.query) {
      // New association inside expand/inline: The on-condition can't be properly checked,
      // so abort early. See #8797
      error( 'query-unexpected-assoc', [ obj.name.location, art ], {},
             'Unexpected new association in expand/inline' );
      return; // avoid subsequent errors
    }

    if (obj.on) {
      if (!art._main || !art._parent.elements && !art._parent.items && !art._parent.targetAspect) {
        // TODO: test of .items a bit unclear - we should somehow restrict the
        // use of unmanaged assocs in MANY, at least with $self
        // TODO: $self usage in anonymous aspects to be corrected in Core Compiler
        const isComposition = obj.type && obj.type.path && obj.type.path[0] &&
                              obj.type.path[0].id === 'cds.Composition';
        message( 'assoc-as-type', [ obj.on.location, art ],
                 { '#': isComposition ? 'comp' : 'std' }, {
                   std: 'An unmanaged association can\'t be defined as type',
                   comp: 'An unmanaged composition can\'t be defined as type',
                 });
        // TODO: also warning if inside structure
      }
      else if (obj.$inferred !== 'REDIRECTED') {
        // TODO: extra with $inferred (to avoid messages)?
        // TODO: in the ON condition of an explicitly provided model entity
        // which is going to be implicitly redirected, we can never navigate
        // along associations, even not to the foreign keys (at least if they
        // are renamed) - introduce extra 'expected' which inspects REDIRECTED
        resolveExpr( obj.on, art.kind === 'mixin' ? 'mixin-on' : 'on', art );
      }
      else {
        const elements = Object.create( art._parent.elements );
        elements[art.name.id] = obj;
        resolveExpr( obj.on, art.kind === 'mixin' ? 'mixin-on' : 'on', art, elements );
      }
    }
    else if (art.kind === 'mixin') {
      error( 'assoc-in-mixin', [ obj.target.location, art ], {},
             'Managed associations are not allowed for MIXIN elements' );
      return; // avoid subsequent errors
    }
    else if (obj.type && !obj.type.$inferred && art._parent && art._parent.kind === 'select') {
      // New association in views, i.e. parent is a query.
      error( 'query-expected-on-condition', [ obj.target.location, art ], {},
             'Expected on-condition for published association' );
      return; // avoid subsequent errors
    }
    else if (target && !obj.foreignKeys && target.kind === 'entity') {
      if (obj.$inferred === 'REDIRECTED') {
        addImplicitForeignKeys( art, obj, target );
      }
      else if (obj.type && obj.type._artifact && obj.type._artifact.internal) {
        // cds.Association, ...
        addImplicitForeignKeys( art, obj, target );
      }
    }

    if (target && !target.$inferred) {
      if (!obj.type || obj.type.$inferred || obj.target.$inferred) { // REDIRECTED
        resolveRedirected( art, target );
      }
    }
  }

  function addImplicitForeignKeys( art, obj, target ) {
    obj.foreignKeys = Object.create(null);
    forEachInOrder( target, 'elements', ( elem, name ) => {
      if (elem.key && elem.key.val) {
        const { location } = art.target;
        const key = {
          name: { location, id: elem.name.id, $inferred: 'keys' }, // more by setMemberParent()
          kind: 'key',
          targetElement: { path: [ { id: elem.name.id, location } ], location },
          location,
          $inferred: 'keys',
        };
        setMemberParent( key, name, art );
        dictAdd( obj.foreignKeys, name, key );
        setArtifactLink( key.targetElement, elem );
        setArtifactLink( key.targetElement.path[0], elem );
        setLink( key, '_effectiveType', effectiveType(elem) );
        dependsOn(key, elem, location);
        dependsOnSilent(art, key);
      }
    });
    obj.foreignKeys[$inferred] = 'keys';
  }

  function addForeignKeyNavigations( art ) {
    art.$keysNavigation = Object.create(null);
    forEachGeneric( art, 'foreignKeys', ( key ) => {
      if (!key.targetElement || !key.targetElement.path)
        return;
      let dict = art.$keysNavigation;
      const last = key.targetElement.path[key.targetElement.path.length - 1];
      for (const item of key.targetElement.path) {
        let nav = dict[item.id];
        if (!nav) {
          nav = {};
          dict[item.id] = nav;
          if (item === last)
            setArtifactLink( nav, key );
          else
            nav.$keysNavigation = Object.create(null);
        }
        else if (item === last || nav._artifact) {
          error( 'duplicate-key-ref', [ item.location, key ], {},
                 'The same target reference has already been used in a key definition' );
          return;
        }
        dict = nav.$keysNavigation;
      }
    } );
  }

  // TODO: add this somehow to tweak-assocs.js ?
  function resolveRedirected( elem, target ) {
    setLink( elem, '_redirected', null ); // null = do not touch path steps after assoc
    const assoc = directType( elem );
    const origType = assoc && effectiveType( assoc );
    if (!origType || !origType.target) {
      const path = (elem.value && elem.value.path);
      const loc = (path && path[path.length - 1] || elem.value || elem).location;
      error( 'redirected-no-assoc', [ loc, elem ], {},
             'Only an association can be redirected' );
      return;
    }
    // console.log(message( null, elem.location, elem, {target,art:assoc}, 'Info','RE')
    //             .toString(), elem.value)
    const nav = elem._main && elem._main.query && elem.value && pathNavigation( elem.value );
    if (nav && nav.item !== elem.value.path[elem.value.path.length - 1]) {
      if (!elem.on && origType.on) {
        error( 'rewrite-not-supported', [ elem.target.location, elem ], {},
               // TODO: Better text ?
               'The ON condition is not rewritten here - provide an explicit ON condition' );
        return;
      }
    }
    const origTarget = origType.target._artifact;
    if (!origTarget || !target)
      return;

    const chain = [];
    if (target === origTarget) {
      if (!elem.target.$inferred && !elem.on && !elem.foreignKeys) {
        // Only a managed redirection gets this info message.  Because otherwise
        // we'd have to check whether on-condition/foreignKeys are the same.
        info( 'redirected-to-same', [ elem.target.location, elem ], { art: target },
              'The redirected target is the original $(ART)' );
      }
      setLink( elem, '_redirected', chain ); // store the chain
      return;
    }
    if (elem.foreignKeys || elem.on)
      return;          // TODO: or should we still bring an msg if nothing in common?
    // now check whether target and origTarget are "related"
    while (target.query) {
      const from = target.query.args ? {} : target.query.from;
      if (!from)
        return;                 // parse error - TODO: or UNION?
      if (!from.path) {
        warning( 'redirected-to-complex', [ elem.target.location, elem ],
                 { art: target, '#': target === elem.target._artifact ? 'target' : 'std' },
                 {
                   std: 'Redirection involves the complex view $(ART)',
                   target: 'The redirected target $(ART) is a complex view',
                 });
        break;
      }
      target = from._artifact;
      if (!target)
        return;
      chain.push( from );
      if (target === origTarget) {
        chain.reverse();
        setLink( elem, '_redirected', chain );
        return;
      }
    }
    let redirected = null;
    let news = [ { chain: chain.reverse(), sources: [ target ] } ];
    const dict = Object.create(null);
    while (news.length) {
      const outer = news;
      news = [];
      for (const o of outer) {
        for (const s of o.sources) {
          const art = (s.kind === '$tableAlias') ? s._origin : s;
          if (art !== origTarget) {
            if (findOrig( o.chain, s, art ) && !redirected) // adds to news []
              redirected = false;   // do not report further error
          }
          else if (!redirected) {
            redirected = (s.kind === '$tableAlias') ? [ s, ...o.chain ] : o.chain;
          }
          else {
            error( 'redirected-to-ambiguous', [ elem.target.location, elem ], { art: origTarget },
                   'The redirected target originates more than once from $(ART)' );
            return;
          }
        }
      }
    }
    if (redirected) {
      setLink( elem, '_redirected', redirected );
    }
    else if (redirected == null) {
      error( 'redirected-to-unrelated', [ elem.target.location, elem ], { art: origTarget },
             'The redirected target does not originate from $(ART)' );
    }
    return;

    // B = proj on A, C = A x B, X = { a: assoc to A on a.Q1 = ...}, Y = X.{ a: redirected to C }
    // what does a: redirected to C means?
    // -> collect all elements Qi used in ON (corr: foreign keys)
    // -> only use an tableAlias which has propagation for all elements
    // no - error if the original target can be reached twice
    // even better: disallow complex view (try as error first)

    // eslint-disable-next-line no-shadow
    function findOrig( chain, alias, art ) {
      if (!art || dict[art.name.absolute])
        // some include ref or query source cannot be found, or cyclic ref
        return true;
      dict[art.name.absolute] = true;

      if (art.includes) {
        news.push( {
          chain: [ art, ...chain ],
          sources: art.includes
            .map( r => r._artifact )
            .filter( i => i ),  // _artifact may be `null` if the include cannot be found
        } );
      }
      const query = art._leadingQuery;
      if (!query)
        return false;           // non-query entity
      if (!query.$tableAliases) // previous error in query definition
        return true;
      const sources = [];
      for (const n in query.$tableAliases) {
        const a = query.$tableAliases[n];
        if (a.path && a.kind !== '$self' && a.kind !== 'mixin')
          sources.push( a );
      }
      if (alias.kind === '$tablealias')
        news.push( { chain: [ alias, ...chain ], sources } );
      else
        news.push( { chain, sources } );
      return false;
    }
  }

  //--------------------------------------------------------------------------
  // General resolver functions
  //--------------------------------------------------------------------------

  // Resolve the type and its arguments if applicable.
  function resolveTypeExpr( art, user ) {
    const typeArt = resolveType( art.type, user );
    if (typeArt) {
      resolveTypeArgumentsUnchecked( art, typeArt, user );
      checkTypeArguments( art );
    }
  }

  /**
   * Check the type arguments on `artWithType`.
   * If the effective type is an array or structured type, an error is emitted.
   */
  function checkTypeArguments( artWithType ) {
    // Note: `_effectiveType` may point to `artWithType` itself, if the type is structured.
    //       Also: For enums, it points to the enum type, which is why this trick is needed.
    // TODO(#8942): May not be necessary if effectiveType() is adapted.  Furthermore, the enum
    //              trick may be removed if effectiveType() does not stop at enums.
    const cyclic = new Set();
    let effectiveTypeArt = effectiveType( artWithType );
    while (effectiveTypeArt && effectiveTypeArt.enum && !cyclic.has(effectiveTypeArt)) {
      cyclic.add(effectiveTypeArt);
      const underlyingEnumType = directType(effectiveTypeArt);
      if (underlyingEnumType)
        effectiveTypeArt = effectiveType(underlyingEnumType);
      else
        break;
    }

    if (!effectiveTypeArt)
      return; // e.g. illegal definition references

    const params = effectiveTypeArt.parameters &&
      effectiveTypeArt.parameters.map(p => p.name || p) || [];

    for (const param of typeParameters.list) {
      if (artWithType[param] !== undefined) {
        if (!params.includes(param)) {
          // Whether the type ref itself is a builtin or a custom type with a builtin as base.
          const type = directType(artWithType);

          let variant;
          if (type.builtin)
          // `.type` is already a builtin: use a nicer message.
            variant = 'builtin';
          else if (effectiveTypeArt.builtin)
          // base type is a builtin, i.e. a scalar
            variant = 'type';
          else
          // effectiveType is not a builtin -> array or structured
            variant = 'non-scalar';

          error('type-unexpected-argument', [ artWithType[param].location, artWithType ], {
            '#': variant, prop: param, art: artWithType.type, type: effectiveTypeArt,
          });
          break; // Avoid spam: Only emit the first error.
        }
        else if (!typeParameters.expectedLiteralsFor[param].includes(artWithType[param].literal)) {
          error('type-unexpected-argument', [ artWithType[param].location, artWithType ], {
            '#': 'incorrect-type',
            prop: param,
            code: artWithType[param].literal,
            names: typeParameters.expectedLiteralsFor[param],
          });
          break; // Avoid spam: Only emit the first error.
        }
      }
    }
  }

  function resolveExpr( expr, expected, user, extDict, expandOrInline) {
    // TODO: when we have rewritten the resolvePath functions,
    // define a traverseExpr() in ./utils.js
    // TODO: extra "expected" 'expand'/'inline' instead o param `expandOrInline`
    if (!expr || typeof expr === 'string') // parse error or keywords in {xpr:...}
      return;
    if (Array.isArray(expr)) {
      expr.forEach( e => resolveExpr( e, expected, user, extDict ) );
      return;
    }

    if (expr.type) // e.g. cast( a as Integer )
      resolveTypeExpr( expr, user );

    if (expr.path) {
      if (expr.$expected === 'exists') {
        error( 'expr-unexpected-exists', [ expr.location, user ], {},
               'An EXISTS predicate is not expected here' );
        // We complain about the EXISTS before, as EXISTS subquery is also not
        // supported (avoid that word if you do not want to get tickets when it
        // will be supported), TODO: location of EXISTS
        expr.$expected = 'approved-exists'; // only complain once
      }
      if (expected instanceof Function) {
        expected( expr, user, extDict );
        return;
      }
      resolvePath( expr, expected, user, extDict );

      const last = !expandOrInline && expr.path[expr.path.length - 1];
      for (const step of expr.path) {
        if (step && (step.args || step.where || step.cardinality) &&
            step._artifact && !Array.isArray( step._artifact ) )
          resolveParamsAndWhere( step, expected, user, extDict, step === last );
      }
    }
    else if (expr.query) {
      const { query } = expr;
      if (query.kind || query._leadingQuery) { // UNION has _leadingQuery
        // traverseQueryPost( query, false, resolveQuery );
      }
      else {
        error( 'expr-no-subquery', [ expr.location, user ], {},
               'Subqueries are not supported here' );
      }
    }
    else if (expr.op && expr.args) {
      const args = Array.isArray(expr.args) ? expr.args : Object.values( expr.args );
      args.forEach( e => e && resolveExpr( e, e.$expected || expected, user, extDict ) );
    }
    if (expr.suffix && isDeprecatedEnabled( options )) {
      const { location } = expr.suffix[0] || expr;
      error( null, [ location, user ], { prop: 'deprecated' },
             'Window functions are not supported if $(PROP) options are set' );
    }
    if (expr.suffix)
      expr.suffix.forEach( s => s && resolveExpr( s, expected, user, extDict ) );
  }

  function resolveParamsAndWhere( step, expected, user, extDict, isLast ) {
    const alias = step._navigation && step._navigation.kind === '$tableAlias' && step._navigation;
    const type = alias || effectiveType( step._artifact );
    const art = (type && type.target) ? type.target._artifact : type;
    if (!art)
      return;
    const entity = (art.kind === 'entity') &&
      (!isLast || [ 'from', 'exists', 'approved-exists' ].includes( expected )) && art;
    if (step.args)
      resolveParams( step.args, art, entity, expected, user, extDict, step.location );
    if (entity) {
      if (step.where)
        resolveExpr( step.where, 'filter', user, environment( type ) );
    }
    else if (step.where && step.where.location || step.cardinality ) {
      const location = combinedLocation( step.where, step.cardinality );
      // XSN TODO: filter$location including […]
      message( 'expr-no-filter', [ location, user ], { '#': expected },
               {
                 std: 'A filter can only be provided when navigating along associations',
                 from: 'A filter can only be provided for the source entity or associations',
               } );
    }
  }

  function resolveParams( dict, art, entity, expected, user, extDict, stepLocation ) {
    if (!entity || !entity.params) {
      let first = dict[Object.keys(dict)[0]];
      if (Array.isArray(first))
        first = first[0];
      message( 'args-no-params',
               [ dict[$location] ||
                 dictLocation( dict, first && first.name && first.name.location || stepLocation),
               user ],
               { art, '#': (entity ? 'entity' : expected ) },
               {
                 std: 'Parameters can only be provided when navigating along associations',
                 from: 'Parameters can only be provided for the source entity or associations',
                 // or extra message id for entity?
                 entity: 'Entity $(ART) has no parameters',
               } );
      return;
    }
    const exp = (expected === 'from') ? 'expr' : expected;
    if (Array.isArray(dict)) {
      message( 'args-expected-named', [ dict[0] && dict[0].location || stepLocation, user ],
               'Named parameters must be provided for the entity' );
      for (const a of dict)
        resolveExpr( a, exp, user, extDict );
      return;
    }
    // TODO: allow to specify expected for arguments in in specExpected
    for (const name in dict) {
      const param = art.params[name];
      const arg = dict[name];
      for (const a of Array.isArray(arg) ? arg : [ arg ]) {
        setArtifactLink( a.name, param );
        if (!param) {
          message( 'args-undefined-param', [ a.name.location, user ], { art, id: name },
                   'Entity $(ART) has no parameter $(ID)' );
        }
        resolveExpr( a, exp, user, extDict );
      }
    }
  }
}

// Return condensed info about reference in select item
// - tableAlias.elem       -> { navigation: navElem, item: path[1], tableAlias }
// - sourceElem (in query) -> { navigation: navElem, item: path[0], tableAlias }
// - mixinElem             -> { navigation: mixinElement, item: path[0] }
// - $projection.elem      -> also $self.item -> { item: path[1], tableAlias: $self }
// - $self                 -> { item: undefined, tableAlias: $self }
// - $parameters.P, :P     -> {}
// - $now, current_date    -> {}
// - undef, redef          -> {}
// With 'navigation': store that navigation._artifact is projected
// With 'navigation': rewrite its ON condition
// With navigation: Do KEY propagation
//
// TODO: re-think this function, copied in populate.js and tweak-assocs.js
function pathNavigation( ref ) {
  // currently, indirectly projectable elements are not included - we might
  // keep it this way!  If we want them to be included - be aware: cycles
  if (!ref._artifact)
    return {};
  let item = ref.path && ref.path[0];
  const root = item && item._navigation;
  if (!root)
    return {};
  if (root.kind === '$navElement')
    return { navigation: root, item, tableAlias: root._parent };
  if (root.kind === 'mixin')
    return { navigation: root, item };
  item = ref.path[1];
  if (root.kind === '$self')
    return { item, tableAlias: root };
  if (root.kind !== '$tableAlias' || ref.path.length < 2)
    return {};                // should not happen
  return { navigation: root.elements[item.id], item, tableAlias: root };
}

module.exports = resolve;
