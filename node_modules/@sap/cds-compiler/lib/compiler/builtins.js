// The builtin artifacts of CDS

// TODO: split this file
// - in base/: common definitions
// - in compiler/: XSN-specific
// - in ?: CSN-specific

'use strict';

const { builtinLocation } = require('../base/location');
const { setLink: setProp } = require('./utils');

const core = {
  String: { parameters: [ 'length' ], category: 'string' },
  LargeString: { category: 'string' },
  Binary: { parameters: [ 'length' ], category: 'binary' },
  LargeBinary: { category: 'binary' },
  Decimal: { parameters: [ 'precision', 'scale' ], category: 'decimal' },
  DecimalFloat: { category: 'decimal', deprecated: true },
  Integer64: { category: 'integer' },
  Integer: { category: 'integer' },
  Double: { category: 'decimal' },
  Date: { category: 'dateTime' },
  Time: { category: 'dateTime' },
  DateTime: { category: 'dateTime' },
  Timestamp: { category: 'dateTime' },
  Boolean: { category: 'boolean' },
  UUID: { category: 'string' },
  Association: { internal: true, category: 'relation' },
  Composition: { internal: true, category: 'relation' },
};

const coreHana = {
  // ALPHANUM: { parameters: [ 'length' ] },
  SMALLINT: { category: 'integer' },
  TINYINT: { category: 'integer' },
  SMALLDECIMAL: { category: 'decimal' },
  REAL: { category: 'decimal' },
  CHAR: { parameters: [ 'length' ], category: 'string' },
  NCHAR: { parameters: [ 'length' ], category: 'string' },
  VARCHAR: { parameters: [ 'length' ], category: 'string' },
  CLOB: { category: 'string' },
  BINARY: { parameters: [ 'length' ], category: 'binary' },
  // TODO: probably remove default for ST_POINT, ST_GEOMETRY (to be done in backend);
  ST_POINT: { parameters: [ { name: 'srid', literal: 'number', val: 0 } ], category: 'geo' },
  ST_GEOMETRY: { parameters: [ { name: 'srid', literal: 'number', val: 0 } ], category: 'geo' },
};

const typeParameters = {
  expectedLiteralsFor: {
    length: [ 'number' ],
    scale: [ 'number', 'string' ],
    precision: [ 'number' ],
    srid: [ 'number' ],
  },
};
typeParameters.list = Object.keys( typeParameters.expectedLiteralsFor );

// const hana = {
//   BinaryFloat: {},
//   LocalDate: {},
//   LocalTime: {},
//   UTCDateTime: {},
//   UTCTimestamp: {},
//   WithStructuredPrivilegeCheck: { kind: 'annotation' },
//   hana: { kind: 'context' },
// };

/**
 * Functions without parentheses in CDL (common standard SQL-92 functions)
 * (do not add more - make it part of the SQL renderer to remove parentheses for
 * other funny SQL functions like CURRENT_UTCTIMESTAMP).
 */
const functionsWithoutParens = [
  'CURRENT_DATE', 'CURRENT_TIME', 'CURRENT_TIMESTAMP',
  'CURRENT_USER', 'SESSION_USER', 'SYSTEM_USER',
];

const specialFunctions = {
  ROUND: [
    null, null, {               // 3rd argument: rounding mode
      ROUND_HALF_UP: 'argFull',
      ROUND_HALF_DOWN: 'argFull',
      ROUND_HALF_EVEN: 'argFull',
      ROUND_UP: 'argFull',
      ROUND_DOWN: 'argFull',
      ROUND_CEILING: 'argFull',
      ROUND_FLOOR: 'argFull',
    },
  ],
};

/**
 * Variables that have special meaning in CDL/CSN.
 */
const magicVariables = {
  $user: {
    // id and locale are always available
    elements: { id: {}, locale: {} },
    // Allow $user.<any>
    $uncheckedElements: true,
    // Allow shortcut in CDL: `$user` becomes `$user.id` in CSN.
    $autoElement: 'id',
  },
  $at: { // CDS-specific, not part of SQL
    elements: {
      from: {}, to: {},
    },
  },
  $now: {}, // Dito
  $session: {
    // In ABAP CDS session variables are accessed in a generic way via
    // the pseudo variable $session.
    $uncheckedElements: true,
  },
};

// see lib/render/renderUtil.js for DB-specific magic vars, specified in CAP Cds via function

/** All types belong to one category. */
const typeCategories = {
  string: [],
  integer: [],
  dateTime: [],
  time: [],
  decimal: [],
  binary: [],
  boolean: [],
  relation: [],
  geo: [],
};
// Fill type categories with `cds.*` types
Object.keys(core).forEach((type) => {
  if (core[type].category)
    typeCategories[core[type].category].push(`cds.${ type }`);
});
// Fill type categories with `cds.hana.*` types
Object.keys(coreHana).forEach((type) => {
  if (coreHana[type].category)
    typeCategories[coreHana[type].category].push(`cds.hana.${ type }`);
});

/** @param {string} typeName */
function isIntegerTypeName(typeName) {
  return typeCategories.integer.includes(typeName);
}
/** @param {string} typeName */
function isDecimalTypeName(typeName) {
  return typeCategories.decimal.includes(typeName);
}
/** @param {string} typeName */
function isNumericTypeName(typeName) {
  return isIntegerTypeName(typeName) || isDecimalTypeName(typeName);
}
/** @param {string} typeName */
function isStringTypeName(typeName) {
  return typeCategories.string.includes(typeName);
}
/** @param {string} typeName */
function isDateOrTimeTypeName(typeName) {
  return typeCategories.dateTime.includes(typeName);
}
/** @param {string} typeName */
function isBooleanTypeName(typeName) {
  return typeCategories.boolean.includes(typeName);
}
/** @param {string} typeName */
function isBinaryTypeName(typeName) {
  return typeCategories.binary.includes(typeName);
}
/** @param {string} typeName */
function isGeoTypeName(typeName) {
  return typeCategories.geo.includes(typeName);
}
/**
 * Whether the given type name is a relation, i.e. an association or composition.
 *
 * @param {string} typeName
 */
function isRelationTypeName(typeName) {
  return typeCategories.relation.includes(typeName);
}

/**
 * Checks whether the given absolute path is inside a reserved namespace.
 *
 * @param {string} absolute
 * @returns {boolean}
 */
function isInReservedNamespace(absolute) {
  return absolute.startsWith( 'cds.') &&
    !absolute.match(/^cds\.foundation(\.|$)/) &&
    !absolute.match(/^cds\.outbox(\.|$)/) && // Requested by Node runtime
    !absolute.match(/^cds\.xt(\.|$)/); // Requested by Mtx
}

/**
 * Tell if a type is (directly) a builtin type
 * Note that in CSN builtins are not in the definition of the model, so we can only
 * check against their absolute names.  Builtin types are "cds.<something>", i.e. they
 * are directly in 'cds', but not for example in 'cds.foundation'.
 *
 * @param {string} type
 * @returns {boolean}
 */
function isBuiltinType(type) {
  return typeof type === 'string' && isInReservedNamespace(type);
}

/**
 * Add CDS builtins like the `cds` namespace with types like `cds.Integer` to
 * `definitions` of the XSN model as well as to `$builtins`.
 *
 * @param {XSN.Model} model XSN model without CDS builtins
 */
function initBuiltins( model ) {
  const { options } = model;
  setMagicVariables( magicVariables );
  // namespace:"cds" stores the builtins ---
  const cds = createNamespace( 'cds', 'reserved' );
  // setProp( model.definitions, 'cds', cds );
  model.definitions.cds = cds; // not setProp - oData - TODO: still needed?
  // Also add the core artifacts to model.definitions`
  model.$builtins = env( core, 'cds.', cds );
  model.$builtins.cds = cds;
  // namespace:"cds.hana" stores HANA-specific builtins ---
  const hana = createNamespace( 'cds.hana', 'reserved' );
  setProp( model.definitions, 'cds.hana', hana );
  model.$builtins.hana = hana;
  cds._subArtifacts.hana = hana;
  env( coreHana, 'cds.hana.', hana );
  model.$internal = { $frontend: '$internal' };
  return;

  function createNamespace( name, builtin ) {
    const art = {
      kind: 'namespace',
      // builtin namespaces don't have a cds file, so no location available
      name: { absolute: name, location: builtinLocation() },
      blocks: [],
      builtin,
      location: builtinLocation(),
    };
    setProp( art, '_subArtifacts', Object.create(null) );
    return art;
  }

  /**
   * Insert the builtins into the parent's `_subArtifacts` dictionary without the
   * prefix and into the model's `definitions` dictionary prefixed.
   *
   * @param {object} builtins Object containing the builtin types.
   * @param {string} prefix Type prefix, e.g. 'cds.'
   * @param {object} parent
   * @returns {object} Artifacts dictionary with the builtin artifacts without prefixes.
   */
  function env( builtins, prefix, parent ) {
    const artifacts = Object.create(null);
    for (const name of Object.keys( builtins )) {
      const absolute = prefix + name;
      const art = {
        kind: 'type', builtin: true, name: { absolute }, type: { path: [ { id: absolute } ] },
      };
      setProp( art.type, '_artifact', art );
      if (parent)
        parent._subArtifacts[name] = art;
      setProp( art, '_effectiveType', art );
      setProp( art, '_deps', [] );
      Object.assign( art, builtins[name] );
      if (!art.internal)
        artifacts[name] = art;
      setProp( model.definitions, absolute, art );
    }
    return artifacts;
  }

  function setMagicVariables( builtins ) {
    const artifacts = Object.create(null);
    for (const name in builtins) {
      const magic = builtins[name];
      // TODO: rename to $builtinFunction
      const art = { kind: 'builtin', name: { element: name, id: name } };
      artifacts[name] = art;

      if (magic.$autoElement)
        art.$autoElement = magic.$autoElement;
      if (magic.$uncheckedElements)
        art.$uncheckedElements = magic.$uncheckedElements;

      createMagicElements( art, magic.elements );
      if (options.variableReplacements)
        createMagicElements( art, options.variableReplacements[name] );
      // setProp( art, '_effectiveType', art );
    }
    model.$magicVariables = { kind: '$magicVariables', artifacts };
  }

  function createMagicElements( art, elements ) {
    if (!elements)
      return;

    const names = Object.keys(elements);
    if (names.length > 0 && !art.elements)
      art.elements = Object.create(null);

    for (const n of names) {
      const magic = {
        kind: 'builtin',
        name: { id: n, element: `${ art.name.element }.${ n }` },
      };
      // Propagate this property so that it is available for sub-elements.
      if (art.$uncheckedElements)
        magic.$uncheckedElements = art.$uncheckedElements;
      setProp( magic, '_parent', art );
      // setProp( magic, '_effectiveType', magic );
      if (elements[n] && typeof elements[n] === 'object')
        createMagicElements(magic, elements[n]);

      art.elements[n] = magic;
    }
  }
}

module.exports = {
  typeParameters,
  functionsWithoutParens,
  specialFunctions,
  initBuiltins,
  isInReservedNamespace,
  isBuiltinType,
  isIntegerTypeName,
  isDecimalTypeName,
  isNumericTypeName,
  isStringTypeName,
  isDateOrTimeTypeName,
  isBooleanTypeName,
  isBinaryTypeName,
  isGeoTypeName,
  isRelationTypeName,
};
