'use strict';
/* eslint max-statements-per-line:off */
const { setProp, isDeprecatedEnabled, isBetaEnabled } = require('../base/model');
const { forEachDefinition, forEachGeneric, forEachMemberRecursively,
  isEdmPropertyRendered, getUtils, cloneCsnNonDict, isBuiltinType } = require('../model/csnUtils');
const edmUtils = require('./edmUtils.js');
const typesExposure = require('../transform/odata/typesExposure');
const expandCSNToFinalBaseType = require('../transform/odata/toFinalBaseType');

const {
  intersect,
  validateOptions,
  foreach,
  forAll,
  isAssociationOrComposition,
  isComposition,
  isStructuredArtifact,
  isParameterizedEntity,
  resolveOnConditionAndPrepareConstraints,
  finalizeReferentialConstraints,
  isEntity,
  getSchemaPrefix,
} = require('./edmUtils.js');

/**
 *  edmPreprocessor warms up the model so that it can be converted into an EDM document and
 *  contains all late & application specific model transformations
 *  that should NOT become persistent in the published CSN model but only
 *  be presented in the resulting EDM files. These late tweaks or mods can
 *  be dependent to EDM version.
 *
 * @param {CSN.Model} csn
 * @param {object}    _options
 */
function initializeModel(csn, _options, messageFunctions, requestedServiceNames=undefined)
{
  const { info, warning, error, message, throwWithAnyError } = messageFunctions;

  let csnUtils = getUtils(csn);

  // proxies are merged into the final model after all proxy elements are collected
  const proxyCache = [];
  // iterarte only over those definitions that need to be preprocessed
  // instead of mangling through the whole model each time
  // preprocess steps removing adding to the model must co-modify this map
  const reqDefs = { definitions: Object.create(null) };


  // make sure options are complete
  let options = validateOptions(_options);

  const [ serviceRoots,
    serviceRootNames,
    fallBackSchemaName,
    whatsMyServiceRootName ] = getAnOverviewOnTheServices(csn);

  if(requestedServiceNames === undefined)
    requestedServiceNames = options.serviceNames;
  if(requestedServiceNames === undefined) {
    requestedServiceNames = serviceRootNames;
  }

  function isMyServiceRequested(n) {
    return requestedServiceNames.includes(whatsMyServiceRootName(n));
  }

  if(serviceRootNames.length === 0) {
    return [serviceRoots, Object.create(null), reqDefs, whatsMyServiceRootName, fallBackSchemaName, options];
  }

  // Structural CSN inbound QA checks
  inboundQualificationChecks();
  // not needed at the moment
  // resolveForeignKeyRefs();

  if(isBetaEnabled(options, undefined)) {
    splitDottedDefinitionsIntoSeparateServices();
  }
  else
    /*
      Replace dots with underscores for all definitions below a context
      or a service and rewrite refs and targets. MUST be done before type exposure.
    */
    renameDottedDefinitionsInsideServiceOrContext();

  /*
    Final base type expansion is required here when:
    1) The input CSN was already transformed for V4 but shall be rendered in V2 and the 
       edmx generator is called directly (bypassing OData transformation)
    2) The input CSN was already transformed for V4 and persisted (all non-enumerables are
       stripped of)
    3) call via cdsc

    At the end of the day, this module must be called only here, in the renderer and removed
    as a step in the OData transformer with the goal to have a protocol agnostic OData CSN.
  */
  if (csn.meta && csn.meta.options && csn.meta.options.odataVersion === 'v4' && options.isV2()) {
    const { toFinalBaseType }= require('../transform/transformUtilsNew').getTransformers(csn, options);
    expandCSNToFinalBaseType(csn, { toFinalBaseType }, csnUtils, serviceRootNames, options);
  }

  /*
    Enrich the CSN by de-anonymizing and exposing types that are required to make the service self contained.
    Type exposure will add additional schema contexts and group the exposed types in these contexts.
    contexts either represent another service (if the type to be exposed resides in that
    service), the namespace (including (sub-)contexts) or as last resort (if the type name
     has no prefix path) a 'root' namespace.
  */
  const schemas = typesExposure(csn, whatsMyServiceRootName, requestedServiceNames,
    fallBackSchemaName, options, csnUtils, { error });

  // Get an overview about all schemas (including the services)
  const schemaNames = [...serviceRootNames];
  schemaNames.push(...Object.keys(schemas));
  // sort schemas in reverse order to allow longest match in whatsMySchemaName function
  schemaNames.sort((a,b) => b.length-a.length);
  function whatsMySchemaName(n) {
    return schemaNames.reduce((rc, sn) => !rc && n && n.startsWith(sn + '.') ? sn : rc, undefined);
  }

  if(schemaNames.length) {
    // First attach names to all definitions (and actions/params) in the model
    // elements are done in initializeStruct
    // Set myServiceName for later reference and indication of a service member
    // First attach names to all definitions in the model and fill reqDefs
    // Link association targets and spray @odata.contained over untagged compositions
    forEachDefinition(csn, [
      attachNameProperty,
      (def, defName) => {
        const mySchemaName = whatsMySchemaName(defName);
        mySchemaName && setProp(def, '$mySchemaName', mySchemaName);
        if(isMyServiceRequested(defName))
          reqDefs.definitions[defName] = def;
      },
      linkAssociationTarget ]);
    // initialize requested services
    const skip = { skipArtifact: (_def, defName) => !isMyServiceRequested(defName) };
    forEachDefinition({ definitions: serviceRoots }, initService, skip);
    // Create data structures for containments
    forEachDefinition(reqDefs, initContainments);
    // Initialize entities with parameters (add Parameter entity)
    forEachDefinition(reqDefs, initParameterizedEntityOrView);
    // Initialize structures
    forEachDefinition(csn, initStructure);
    // Initialize associations after _parent linking
    forEachDefinition(reqDefs, initConstraints);
    // Mute V4 elements depending on constraint preparation
    if(options.isV4())
      forEachDefinition(reqDefs, ignoreProperties);
    // calculate constraints based on ignoreProperties and prepareConstraints
    forEachDefinition(reqDefs, finalizeConstraints);
    // convert exposed types into cross schema references if required
    // must be run before proxy exposure to avoid potential reference collisions
    convertExposedTypesOfOtherServicesIntoCrossReferences();
    // create association target proxies
    // Decide if an entity set needs to be constructed or not
    forEachDefinition(reqDefs, [ exposeTargetsAsProxiesOrSchemaRefs, determineEntitySet ]);
    // finalize proxy creation
    mergeProxiesIntoModel();

    if(options.isV4())
      forEachDefinition(reqDefs, initEdmNavPropBindingTargets);

    // Things that can be done in one pass
    // Create edmKeyRefPaths
    // Create NavigationPropertyBindings, requires determineEntitySet
    // Map /** doc comments */ to @CoreDescription
    forEachDefinition(reqDefs, [
      initEdmKeyRefPaths,
      initEdmNavPropBindingPaths,
      initEdmTypesAndDescription
    ]);
  }
  return [serviceRoots, schemas, reqDefs, whatsMyServiceRootName, fallBackSchemaName, options];

  //////////////////////////////////////////////////////////////////////
  //
  // Service initialization starts here
  //

  function getAnOverviewOnTheServices(csn) {
    const defs = csn.definitions || {};
    const serviceRoots = Object.create(null);
    for(const defName in defs) {
      const def = defs[defName];
      if(def && def.kind === 'service')
        serviceRoots[defName] = Object.assign(def, { name: defName });
    }

    // first of all we need to know about all 'real' user defined services
    const serviceRootNames = Object.keys(serviceRoots).sort((a,b)=>b.length-a.length);

    function whatsMyServiceRootName(n, self=true) {
      return serviceRootNames.reduce((rc, sn) => !rc && n && n.startsWith(sn + '.') || (n === sn && self) ? sn : rc, undefined);
    }

    // find a globally unambiguous schema name to collect all top level 'root' types
    // TODO: work on service basis (this requires post exposure renaming)
    let fallBackSchemaName = 'root';
    let i = 1;
    while (Object.keys(defs).some(artName => {
      const p = artName.split('.');
      return p.length === 2 && p[0] === fallBackSchemaName;
    })) {
      fallBackSchemaName = 'root' + i++;
    }

    return [
      serviceRoots,
      serviceRootNames,
      fallBackSchemaName,
      whatsMyServiceRootName ];
  }

  /*
    Replace dots in sub-service and sub-context definitions with underscores to be
    Odata ID compliant.
    Replace the definitions in csn.definitions (such that linkAssociationTarget works)
    All type refs and assoc targets must also be adjusted to refer to the new names.
  */
  function renameDottedDefinitionsInsideServiceOrContext() {

    // Find the first definition above the current definition or undefined otherwise.
    // Definition can either be a context or a service
    function getRootDef(name) {
      const scopeKinds = {'service':1, 'context':1};
      let pos = name.lastIndexOf('.');
      name = pos < 0 ? undefined : name.substring(0, pos);
      while (name && !((csn.definitions[name] && csn.definitions[name].kind) in scopeKinds)) {
        pos = name.lastIndexOf('.');
        name = pos < 0 ? undefined : name.substring(0, pos);
      }
      return name;
    }

    const dotEntityNameMap = Object.create(null);
    const dotTypeNameMap = Object.create(null);
    const kinds = {'entity':1, 'type':1, 'action':1, 'function':1};
    forEachDefinition(csn, (def, defName) => {
      if(def.kind in kinds) {
        const rootDef = getRootDef(defName);
        // if this definition has a root def and the root def is not the service/schema name
        // => service C { type D.E }, replace the prefix dots with underscores
        if(rootDef && defName !== rootDef && rootDef !== getSchemaPrefix(defName)) {
          let newDefName = rootDef + '.' + defName.replace(rootDef + '.', '').replace(/\./g, '_');
          // store renamed types in correlation maps for later renaming
          if(def.kind === 'entity')
            dotEntityNameMap[defName] = newDefName;
          if(def.kind === 'type')
            dotTypeNameMap[defName] = newDefName;
          // rename in csn.definitions
          const art = csn.definitions[newDefName];
          if(art !== undefined) {
            error(null, [ 'definitions', defName ], { name: newDefName },
            `Artifact name containing dots can't be mapped to an OData compliant name because it conflicts with existing definition $(NAME)`);
          }
          else {
            csn.definitions[newDefName] = def;
            delete csn.definitions[defName];
          }
          // dots are illegal in bound actions/functions, no actions required for them
        }
      }
    });
    // rename type refs to new type names
    forEachDefinition(csn, def => {
      forEachMemberRecursively(def, member => {
        member = member.items || member;
        if(member.type && dotTypeNameMap[member.type]) {
          member.type = dotTypeNameMap[member.type];
        }
        if(member.target && dotEntityNameMap[member.target]) {
          member.target = dotEntityNameMap[member.target];
        }
        if(member.$path && dotEntityNameMap[member.$path[1]]) {
          member.$path[1] = dotEntityNameMap[member.$path[1]]
        }
        _rewriteReferencesInActions(member);
      });
      // handle unbound action/function and params in views
      _rewriteReferencesInActions(def);
    });

    function _rewriteReferencesInActions(act) {
      act.params && Object.values(act.params).forEach(param => {
        param = param.items || param;
        if(param.type && (dotEntityNameMap[param.type] || dotTypeNameMap[param.type]))
          param.type = dotEntityNameMap[param.type] || dotTypeNameMap[param.type];
      });
      if(act.returns){
        const returnsObj = act.returns.items || act.returns;
        if (returnsObj.type && dotEntityNameMap[returnsObj.type] || dotTypeNameMap[returnsObj.type])
          returnsObj.type = dotEntityNameMap[returnsObj.type] || dotTypeNameMap[returnsObj.type];
      }
    }
  }

  /*
    Experimental: Move definitions with dots into separate (sub-)service that has the
    namespace of the definition prefix. As not all such services end up with entity sets,
    schemas should be packed after the preprocessing run in order to minimize the number
    of services.
  */
  function splitDottedDefinitionsIntoSeparateServices() {
    forEachDefinition(csn, (def, defName) => {
      if(def.kind !== 'service') {
        const myServiceRoot = whatsMyServiceRootName(defName);
        const mySchemaPrefix = getSchemaPrefix(defName);
        if(myServiceRoot && options.isV4() &&
        /*(options.toOdata.odataProxies || options.toOdata.odataXServiceRefs) && options.isStructFormat && */
        defName !== myServiceRoot && myServiceRoot !== mySchemaPrefix) {
          const service = { kind: 'service', name: mySchemaPrefix };
          serviceRoots[mySchemaPrefix] = service;
          serviceRootNames.push(mySchemaPrefix);
        }
      }
    });
    serviceRootNames.sort((a,b) => b.length-a.length);
  }

  function attachNameProperty(def, defName) {
    assignProp (def, 'name', defName);
    // Attach name to bound actions, functions and parameters
    forEachGeneric(def, 'actions', (a, n) => {
      assignProp(a, 'name', n);
      forEachGeneric(a, 'params', (p, n) => {
        assignProp(p, 'name', n);
      });
    });
    // Attach name unbound action parameters
    forEachGeneric(def, 'params', (p,n) => {
      assignProp(p, 'name', n);
    });
  }

  // initialize the service itself
  function initService(serviceRoot) {
    setSAPSpecificV2AnnotationsToEntityContainer(options, serviceRoot);
  }

  // link association target to association and add @odata.contained to compositions in V4
  function linkAssociationTarget(struct) {
    forEachMemberRecursively(struct, (element, name, prop, subpath) => {
      if(isAssociationOrComposition(element) && !element._ignore) {
        if(!element._target) {
          let target = csn.definitions[element.target];
          if(target) {
            setProp(element, '_target', target);
          // If target has parameters, xref assoc at target for redirection
            if(isParameterizedEntity(target)) {
              if(!target.$sources) {
                setProp(target, '$sources', Object.create(null));
              }
              target.$sources[struct.name + '.' + name] = element;
            }
          }
          else {
            error(null, subpath, { target: element.target }, "Target $(TARGET) can't be found in the model");
          }
        }
      }
      // in V4 tag all compositions to be containments
      if(options.odataContainment &&
         options.isV4() &&
         isComposition(element) &&
         element['@odata.contained'] === undefined) {
        element['@odata.contained'] = true;
      }
    });
  }

  // Perform checks and add attributes for "contained" sub-entities:
  // - A container is recognized by having an association/composition annotated with '@odata.contained'.
  // - All targets of such associations ("containees") are marked with a property
  //   '_containerEntity: []', having as value an array of container names (i.e. of entities
  //   that have a '@odata.contained' association pointing to the containee). Note that this
  //   may be multiple entities, possibly including the container itself.
  // - All associations in the containee pointing back to the container are marked with
  //   a boolean property '_isToContainer : true', except if the association itself
  //   has the annotation '@odata.contained' (indicating the top-down link in a hierarchy).
  // - Rewrite annotations that would be assigned to the containees entity set for the
  //   non-containment rendering. If containment rendering is active, the containee has no
  //   entity set. Instead try to rewrite the annotation in such a way that it is effective
  //   on the containment navigation property.
  function initContainments(container) {
    if(container.kind === 'entity') {
      forEachMemberRecursively(container, initContainments,
        [], true, { elementsOnly: true });
    }

    function initContainments(elt, eltName) {
      if(isAssociationOrComposition(elt) && elt['@odata.contained'] && !elt._ignore) {
        // Let the containee know its container
        // (array because the contanee may contained more then once)
        let containee = elt._target;
        if (!containee._containerEntity)
          setProp(containee, '_containerEntity', []);
        // add container only once per containee
        if (!containee._containerEntity.includes(container.name))
          containee._containerEntity.push(container.name);
        // Mark associations in the containee pointing to the container (i.e. to this entity)
        forEachMemberRecursively(containee, markToContainer,
          [], true, { elementsOnly: true });
        rewriteContainmentAnnotations(container, containee, eltName);
      }
      else {
          // try to find elements to drill down further
        while(elt && !(isBuiltinType(elt.type) || elt.elements)) {
          elt = csn.definitions[elt.type];
        }
        if(elt && elt.elements) {
          forEachMemberRecursively(elt, initContainments,
            [], true, { elementsOnly: true });
        }
      }
    }

    function markToContainer(elt) {
      if(elt._target && elt._target.name) {
        // If this is an association that points to the container (but is not by itself contained,
        // which would indicate the top role in a hierarchy) mark it with '_isToContainer'
        if(elt._target.name === container.name && !elt['odata.contained']) {
          setProp(elt, '_isToContainer', true);
        }
      }
      else {
        // try to find elements to drill down further
        while(elt && !(isBuiltinType(elt.type) || elt.elements)) {
          elt = csn.definitions[elt.type];
        }
        if(elt && elt.elements) {
          forEachMemberRecursively(elt, markToContainer,
            [], true, { elementsOnly: true });
        }
      }
    }
  }

  // Split an entity with parameters into two entity types with their entity sets,
  // one named <name>Parameter and one named <name>Type. Parameter contains Type.
  // Containment processing must take place before because it might be that this
  // artifact with parameters is already contained. In such a case the existing
  // containment chain must be propagated and reused. This requires that the
  // containment data structures must be manually added here and rewriteContainmentAnnotations()
  // must be called.
  // As a param entity is a potential proxy candidate, this split must be performed on
  // all definitions
  function initParameterizedEntityOrView(entityCsn, entityName) {

    if(!isParameterizedEntity(entityCsn))
      return;

    // Naming rules for aggregated views with parameters
    // Parameters: EntityType <ViewName>Parameters, EntitySet <ViewName>
    //             with NavigationProperty "Results" pointing to the entity set of type <ViewName>Result
    // Result:     EntityType <ViewName>Result, EntitySet <ViewName>Results

    // Naming rules for non aggregated views with parameters
    // Parameters: EntityType <ViewName>Parameters, EntitySet <ViewName>
    //             with NavigationProperty "Set" pointing to the entity set of type <ViewName>Type
    // Result:     EntityType <ViewName>Type, EntitySet <ViewName>Set
    //             Backlink Navigation Property "Parameters" to <ViewName>Parameters

    // this code can be extended for aggregated views
    const typeEntityName = entityName + 'Type';
    const typeEntitySetName = entityName + 'Set';
    const parameterToTypeAssocName = 'Set';
    const typeToParameterAssocName = 'Parameters';
    let hasBacklink = true;


    // create the Parameter Definition
    const parameterCsn = createParameterEntity(entityCsn, entityName, false);

    // create the Type Definition
    // modify the original parameter entity with backlink and new name
    if(csn.definitions[typeEntityName])
      error('odata-definition-exists', [ 'definitions', entityName ], {  '#': 'std', name: typeEntityName });
    else {
      csn.definitions[typeEntityName] = entityCsn;
      reqDefs.definitions[typeEntityName] = entityCsn;
      delete csn.definitions[entityCsn.name];
      delete reqDefs.definitions[entityCsn.name];
      entityCsn.name = typeEntityName;
    }
    setProp(entityCsn, '$entitySetName', typeEntitySetName);
    // add backlink association
    if(hasBacklink) {
      entityCsn.elements[typeToParameterAssocName] = {
        name: typeToParameterAssocName,
        target: parameterCsn.name,
        type: 'cds.Association',
        on: [ { ref: [ 'Parameters', 'Set' ] }, '=', { ref: [ '$self' ] } ]
      };
      setProp(entityCsn.elements[typeToParameterAssocName], '_selfReferences', []);
      setProp(entityCsn.elements[typeToParameterAssocName], '_target', parameterCsn);
      setProp(entityCsn.elements[typeToParameterAssocName], '$path',
        [ 'definitions', typeEntityName, 'elements', typeToParameterAssocName ] );

      // rewrite $path
      if(entityCsn.$path)
        entityCsn.$path[1] = typeEntityName;
      forEachMemberRecursively(entityCsn, (member) => {
        if(member.$path)
          member.$path[1] = typeEntityName;
      });
    }

/*
  <EntitySet Name="ZRHA_TEST_CDSSet" EntityType="ZRHA_TEST_CDS_CDS.ZRHA_TEST_CDSType" sap:creatable="false" sap:updatable="false"
             sap:deletable="false" sap:addressable="false" sap:content-version="1"/>
*/
    assignProp(entityCsn, '_SetAttributes',
      {'@sap.creatable': false, '@sap.updatable': false, '@sap.deletable': false, '@sap.addressable': false });

    // redirect inbound associations/compositions to the parameter entity
    Object.keys(entityCsn.$sources || {}).forEach(n => {
      // preserve the original target for constraint calculation
      setProp(entityCsn.$sources[n], '_originalTarget', entityCsn.$sources[n]._target);
      entityCsn.$sources[n]._target = parameterCsn;
      entityCsn.$sources[n].target = parameterCsn.name;
    });
    rewriteContainmentAnnotations(parameterCsn, entityCsn, parameterToTypeAssocName);
  }

  function createParameterEntity(entityCsn, entityName, isProxy) {
    const parameterEntityName = entityName + 'Parameters';
    const parameterToTypeAssocName = 'Set';

    // Construct the parameter entity
    const parameterCsn = {
      name: parameterEntityName,
      kind: 'entity',
      elements: Object.create(null),
      '@sap.semantics': 'parameters',
    };
    if(!isProxy)
      setProp(parameterCsn, '$entitySetName', entityName);
    if(entityCsn.$location){
      assignProp(parameterCsn, '$location', entityCsn.$location);
    }

    /*
      <EntitySet Name="ZRHA_TEST_CDS" EntityType="ZRHA_TEST_CDS_CDS.ZRHA_TEST_CDSParameters" sap:creatable="false" sap:updatable="false"
                 sap:deletable="false" sap:pageable="false" sap:content-version="1"/>
    */

    assignProp(parameterCsn, '_SetAttributes',
      {'@sap.creatable': false, '@sap.updatable': false, '@sap.deletable': false, '@sap.pageable': false });

    setProp(parameterCsn, '$isParamEntity', true);
    setProp(parameterCsn, '$mySchemaName', entityCsn.$mySchemaName);

    // propagate containment information, if containment is recursive, use parameterCsn.name as _containerEntity
    if(entityCsn._containerEntity) {
      setProp(parameterCsn, '_containerEntity', []);
      for(const c of entityCsn._containerEntity) {
        parameterCsn._containerEntity.push((c === entityCsn.name) ? parameterCsn.name : c);
      }
    }
    entityCsn._containerEntity = [ parameterCsn ];

    forEachGeneric(entityCsn, 'params', (p,n) => {
      let elt = cloneCsnNonDict(p, options);
      elt.name = n;
      delete elt.kind;
      setProp(elt, '$path', [ 'definitions', parameterEntityName, 'elements', n ]);
      elt.key = true; // params become primary key in parameter entity
      /*
        Spec meeting decision 28.02.22:
        Annotation @sap.parameter allows two values "mandatory"/"optional".
        Question was how to deal with incompatible "optional".
        Only "mandatory" is allowed because in RAP all parameters are NOT NULL
        and so they are in CAP (all view parameters become primary keys which are not null).
      */
      if(options.isV2())
        assignAnnotation(elt, '@sap.parameter', 'mandatory');
      else
        assignAnnotation(elt, '@Common.FieldControl', { '#': 'Mandatory' });
      parameterCsn.elements[n] = elt;
    });
    linkAssociationTarget(parameterCsn);
    initContainments(parameterCsn);
      // add assoc to result set, FIXME: is the cardinality correct?
    if(!isProxy) {
      parameterCsn.elements[parameterToTypeAssocName] = {
        '@odata.contained': true,
        name: parameterToTypeAssocName,
        target: entityCsn.name,
        type: 'cds.Association',
        cardinality: { src: 1, min: 0, max: '*' }
      };
      setProp(parameterCsn.elements[parameterToTypeAssocName], '_target', entityCsn);
      setProp(parameterCsn.elements[parameterToTypeAssocName], '$path',
        [ 'definitions', parameterEntityName, 'elements', parameterToTypeAssocName ] );
    }
        // rewrite $path
    setProp(parameterCsn, '$path', [ 'definitions', parameterEntityName ]);

    // proxies are registered in model separately
    if(!isProxy) {
      if(csn.definitions[parameterCsn.name])
        error('odata-definition-exists', [ 'definitions', entityName ], { '#': 'std', name: parameterCsn.name });
      else {
        csn.definitions[parameterCsn.name] = parameterCsn;
        reqDefs.definitions[parameterCsn.name] = parameterCsn;
      }
    }
    return parameterCsn;
  }

  function initElement(element, name, struct) {
    setProp(element, 'name', name)
    setProp(element, '_parent', struct);
  }

  // convert $path to path starting at main artifact
  function $path2path(p) {
    const path = [];
    /** @type {object} */
    let env = csn;
    for (let i = 0; p && env && i < p.length; i++) {
      const ps = p[i];
      env = env[ps];
      if (env && env.constructor === Object) {
        path.push(ps);
        if(env.items)
          env = env.items;
        if(env.type && !isBuiltinType(env.type) && !env.elements)
          env = csn.definitions[env.type];
      }
    }
    return path;
  }

  // Initialize a structured artifact
  function initStructure(def) {

    // Don't operate on any structured types other than type and entity
    // such as events and aspects
    if(!isStructuredArtifact(def))
      return;

    let keys = Object.create(null);
    let validFrom = [], validKey = [];

    // Iterate all struct elements
    forEachMemberRecursively(def.items || def, (element, elementName, prop, _path = [], construct) => {
      if(prop !== 'elements')
        return;

      initElement(element, elementName, construct);

      // collect temporal information
      if(element['@cds.valid.key']) {
        validKey.push(element);
      }
      if(element['@cds.valid.from']) {
        validFrom.push(element);
      }
      //forward annotations from managed association element to its foreign keys
      const elements = construct.items && construct.items.elements || construct.elements;
      forAll(elements[element['@odata.foreignKey4']], (attr, attrName) => {
        if(attrName[0] === '@') {
          element[attrName] = attr;
        }
      });
      // and eventually remove some afterwards:)
      if(options.isV2())
        setSAPSpecificV2AnnotationsToAssociation(element);

      // initialize an association
      if(isAssociationOrComposition(element)) {
        // in case this is a forward assoc, store the backlink partners here, _selfReferences.length > 1 => error
        assignProp(element, '_selfReferences', []);
        assignProp(element._target, '$proxies', []);
        // $abspath is used as partner path
        assignProp(element, '$abspath', $path2path(element.$path));
      }

      // Collect keys
      if (element.key) {
        keys[elementName] = element;
      }
      applyAppSpecificLateCsnTransformationOnElement(options, element, def, error);
    }, [], true, { elementsOnly: true });

    if(!isDeprecatedEnabled(options, 'v1KeysForTemporal')) {
      // if artifact has a cds.valid.key mention it as @Core.AlternateKey
      if(validKey.length) {
        let altKeys = [{ Key: [] }];
        validKey.forEach(vk => altKeys[0].Key.push( { Name: vk.name, Alias: vk.name } ) );
        assignAnnotation(def, '@Core.AlternateKeys', altKeys);
      }
    }
    else {
      // if artifact has a cds.valid.key make this the only primary key and
      // add all @cds.valid.from + original primary keys as alternate keys
      // @Core.AlternateKeys: [{ Key: [ { Name: 'slID', Alias: 'slID' }, { Name: 'validFrom', Alias: 'validFrom'} ] }]
      if(validKey.length) {
        let altKeys = [{ Key: [] }];
        forAll(keys, (k, kn) => {
          altKeys[0].Key.push( { Name: kn, Alias: kn } );
          delete k.key;
        });
        validFrom.forEach(e => {
          altKeys[0].Key.push( { Name: e.name, Alias: e.name } );
        });
        assignAnnotation(def, '@Core.AlternateKeys', altKeys);
        keys = Object.create(null);
        validKey.forEach(e => {
          e.key = true;
          keys[e.name] = e;
        });
      }
      else {
        validFrom.forEach(e => {
          e.key = true;
          keys[e.name] = e;
        });
      }
    }

    // prepare the structure itself
    if(isEntity(def)) {
      assignProp(def, '_SetAttributes', Object.create(null));
      assignProp(def, '$keys', keys);
      applyAppSpecificLateCsnTransformationOnStructure(options, def, error);
      setSAPSpecificV2AnnotationsToEntitySet(options, def);
    }
  }

  // Prepare the associations for the subsequent steps
  function initConstraints(def) {
    if(!isStructuredArtifact(def))
      return;

    forEachMemberRecursively(def.items || def, initConstraintsOnAssoc, [], true, { elementsOnly: true });
  }
  function initConstraintsOnAssoc(element) {
    if (isAssociationOrComposition(element) && !element._ignore && !element._constraints) {
        // setup the constraints object
      setProp(element, '_constraints', { constraints: Object.create(null), selfs: [], _origins: [], termCount: 0 });
        // and crack the ON condition
      resolveOnConditionAndPrepareConstraints(csn, element, messageFunctions);
    }
  }

  /*
    Do not render (ignore) elements as properties
    In V4:
    1) If this is a foreign key of an association to a container which *is* used
       to establish the containment via composition and $self comparison, then
       do not render this foreign key. The $self comparison can only be evaluated
       after the ON conditions have been parsed in prepareConstraints().
    2) For all other foreign keys let isEdmPropertyRendered() decide.
    3) If an element/association is annotated with @odata.containment.ignore and containment is
       active, assign @cds.api.ignore or @odata.navigable: false
    4) All of this can be revoked with options.renderForeignKeys.
  */
  function ignoreProperties(struct) {
    if(!isStructuredArtifact(struct))
      return;

    forEachMemberRecursively(struct.items || struct, (element) => {
      if(!element.target) {
        if(element['@odata.foreignKey4']) {
          let isContainerAssoc = false;
          let elements = (struct.items || struct).elements;
          let assoc = undefined;
          const paths = element['@odata.foreignKey4'].split('.')
          for(let p of paths) {
            assoc = elements[p];
            if(assoc) // could be that the @odata.foreignKey4 was propagated...
              elements = assoc.elements;
          }

          if(assoc)
            isContainerAssoc = !!(assoc._isToContainer && assoc._selfReferences.length || assoc['@odata.contained']);
            /*
            If this foreign key is NOT a container fk, let isEdmPropertyRendered() decide
            Else, if fk is container fk, omit it if it wasn't requested in structured mode
            */
          if((!isContainerAssoc && !isEdmPropertyRendered(element, options)) ||
               (isContainerAssoc && !options.renderForeignKeys))
            assignAnnotation(element, '@cds.api.ignore', true);
          // Only in containment:
          // If this element is a foreign key and if it is rendered, remove it from the key ref vector
          else if(options.odataContainment && isContainerAssoc && options.renderForeignKeys) {
            delete struct.$keys[element.name];
          }
        }
        // deprecated unmanagedUpInComponent:
        // Only in containment:
        // Ignore this (foreign key) elment if renderForeignKeys is false
        if(options.odataContainment && element['@odata.containment.ignore']) {
          if(!options.renderForeignKeys)
            assignAnnotation(element, '@cds.api.ignore', true);
          else
            // If foreign keys shall be rendered, remove it from key ref vector
            delete struct.$keys[element.name];
        }
      }
        // it's an association
      else if(element['@odata.containment.ignore'] && options.odataContainment && !options.renderForeignKeys) {
          // if this is an explicitly containment ignore tagged association,
          // ignore it if option odataContainment is true and no foreign keys should be rendered
        assignAnnotation(element, '@odata.navigable', false);
      }
    }, [], true, { elementsOnly: true });
  }

  /*
    Calculate the final referential constraints based on the assignments done in mutePropertiesForV4()
    It may be that now a number of properties are not rendered and cannot act as constraints (see isConstraintCandidate())
    in edmUtils
  */
  function finalizeConstraints(def) {
    if(!isStructuredArtifact(def))
      return;

    forEachMemberRecursively(def.items || def, finalizeConstraintsOnAssoc, [], true, { elementsOnly: true });
  }
  function finalizeConstraintsOnAssoc(element) {
    if (isAssociationOrComposition(element) && !element._ignore && element._constraints) {
      finalizeReferentialConstraints(csn, element, options, info);

      if(element._constraints._partnerCsn && element.cardinality && element.cardinality.max) {
          // if this is a partnership and this assoc has a set target cardinality, assign it as source cardinality to the partner
        if(element._constraints._partnerCsn.cardinality) {
            // if the forward association has set a src cardinality and it deviates from the backlink target cardinality raise a warning
            // in V2 only, in V4 the source cardinality is rendered implicitly at the Type property
          if(element._constraints._partnerCsn.cardinality.src) {
            let srcMult = (element._constraints._partnerCsn.cardinality.src == 1) ? '0..1' : '*';
            let newMult = (element.cardinality.max > 1) ? '*' : '0..1';
            if(options.isV2() && srcMult !== newMult) {
                // Association 'E_toF': Multiplicity of Role='E' defined to '*', conflicting with target multiplicity '0..1' from
              warning(null, null, `Source cardinality "${element._constraints._partnerCsn.cardinality.src}" of "${element._constraints._partnerCsn._parent.name}/${element._constraints._partnerCsn.name}" conflicts with target cardinality "${element.cardinality.max}" of association "${element._parent.name}/${element.name}"`);
            }
          }
          else {
              // .. but only if the original assoc hasn't set src yet
            element._constraints._partnerCsn.cardinality.src = element.cardinality.max;
          }
        }
        else {
          element._constraints._partnerCsn.cardinality = { src: element.cardinality.max };
        }
      }
    }
  }

  /*
    convert sub schemas that represent another service into a service reference object and remove all
    sub artifacts exposed by the initial type exposure
  */
  function convertExposedTypesOfOtherServicesIntoCrossReferences() {
    if(options.toOdata.odataXServiceRefs && options.isV4()) {
      serviceRootNames.forEach(srn => {
        schemaNames.forEach(fqSchemaName => {
          if(fqSchemaName.startsWith(srn + '.')) {
            const targetSchemaName = fqSchemaName.replace(srn + '.', '');
            if(serviceRootNames.includes(targetSchemaName)) {
            // remove all definitions starting with < fqSchemaName >. and add a schema reference
              Object.keys(csn.definitions).forEach(dn => {
                if(dn.startsWith(fqSchemaName)) {// this includes the fqSchemaName context
                  delete csn.definitions[dn];
                  delete reqDefs.definitions[dn];
                }
              });
              if(!schemas[fqSchemaName])
                schemaNames.push(fqSchemaName);
              schemas[fqSchemaName] = createSchemaRef(targetSchemaName);
            }
          }
        });
      });
    }
    schemaNames.sort((a,b)=>b.length-a.length);
  }

  /*
      If an association targets an artifact outside the service, expose the target entity type
      as proxy.

      A proxy represents the identity (or primary key tuple) of the target entity.

      All proxies are registered in a sub context representing the schema, in which the proxy
      is to be rendered (see csn2edm for details).

      If the target resides outside any service, the schema is either it's CDS namespace if provided
      or as 'root'.

      If the target resides in another service, either a schema named by the target service is
      created (option: odataProxies), or a reference object is created representing the target
      service (option: odataExtReferences).

      If option odataExtReferences is used, 'root' proxies are still created.

      If the association leading to the proxy candidate refers to associations either directly
      or indirectly (via structured elements), these dependent entity types are (recursively) exposed
      (or referenced) as well to keep the navigation graph in tact.
  */
  function exposeTargetsAsProxiesOrSchemaRefs(struct) {
    if(struct.kind === 'context' || struct.kind === 'service' || struct.$proxy)
      return;

    // globalSchemaPrefix is the prefix for all proxy registrations and must not change
    // the service prefix is checked without '.' because we also want to inspect those
    // definitions which are directly below the root service ($mySchemaName is the root)
    const globalSchemaPrefix = whatsMyServiceRootName(struct.$mySchemaName);
    // if this artifact is a service member check its associations
    if(globalSchemaPrefix) {
      forEachGeneric(struct.items || struct, 'elements', element => {
        if(!isAssociationOrComposition(element) || element._ignore || element['@odata.navigable'] === false)
          return;
        /*
         * Consider everything @cds.autoexpose: falsy to be a proxy candidate for now
         */
        /*
        if(element._target['@cds.autoexpose'] === false) {
          // :TODO: Also _ignore foreign keys to association?
          foreach(struct.elements,
            e =>
              e['@odata.foreignKey4'] === element.name,
            e => e._ignore = true);
          element._ignore = true;
          info(null, ['definitions', struct.name, 'elements', element.name]
            `${element.type.replace('cds.', '')} "${element.name}" excluded,
              target "${element._target.name}" is annotated '@cds.autoexpose: ${element._target['@cds.autoexpose']}'`
            );
          return;
        }
        */
        // Create a proxy if the source schema and the target schema are different
        // That includes that the target doesn't have a schema.
        // If the target is in another schema, check if both the source and the target share the same service name.
        // If they share the same service name, then it is just a cross schema navigation within the same EDM, no
        // proxy required.
        // association must be managed and not unmanaged

        // odataProxies (P) and odataXServiceRefs (X) are evalutated as follows:
        // P | X | Action
        // 0 | 0 | No out bound navigation
        // 0 | 1 | Cross service references are generated
        // 1 | 0 | Proxies for all out bound navigation targets are created
        // 1 | 1 | Cross service references and proxies are generated

        const targetSchemaName = element._target.$mySchemaName;
        if(isProxyRequired(element)) {
          if(options.isV4() &&
             (options.toOdata.odataProxies || options.toOdata.odataXServiceRefs) &&
             // must be a managed association with keys OR an unambiguous backlink
             element.keys || 
             (element.on && element._constraints.selfs.length === 1 && element._constraints.termCount === 1)
            ) {
            // reuse proxy if available
            let proxy = getProxyForTargetOf(element);
            if(!proxy) {
              if(targetSchemaName && options.toOdata.odataXServiceRefs) {
                proxy = createSchemaRefFor(targetSchemaName);
              }
              else if(options.toOdata.odataProxies) {
                proxy = createProxyFor(element, targetSchemaName);
              }
              proxy = registerProxy(proxy, element);
            }
            if(proxy) {
            // if a proxy was either already created or could be created and
            // if it's a 'real' proxy, link the _target to it and remove constraints
            // otherwise proxy is a schema reference, then do nothing
              setProp(element, '$noPartner', true);
              element._constraints.constraints = Object.create(null);
              if(proxy.kind === 'entity') {
                if(!proxy.$isParamEntity)
                  populateProxyElements(element, proxy, getForeignKeyDefinitions(element));
                element._target = proxy;
              }
              else {
                // No navigation property bindings on external references
                setProp(element, '$externalRef', true);
              }
            }
            else {
              // no proxy: no navigation
              assignAnnotation(element, '@odata.navigable', false);
              noNavPropMsg(element);
            }
          }
          // ok schema names are different, now check if external wants to link back into its service schema
          else {
            assignAnnotation(element, '@odata.navigable', false);
            noNavPropMsg(element);
            return;
          }
        }
      });
    }

    function noNavPropMsg(elt) {
      warning('odata-navigation', ['definitions', struct.name, 'elements', elt.name],
            { target: elt._target.name, service: globalSchemaPrefix });
    }

    function createSchemaRefFor(targetSchemaName) {
      let ref = csn.definitions[globalSchemaPrefix + '.' + targetSchemaName];
      if(!ref) {
        ref = createSchemaRef(targetSchemaName);
      }

      return ref;
    }

    function createProxyFor(assoc, targetSchemaName) {
      // If target is outside any service expose it in service of source entity
      // The proxySchemaName is not prepended with the service schema name to allow to share the proxy
      // if it is required in multiple services. The service schema name is prepended upon registration
      const proxySchemaName = targetSchemaName || getSchemaPrefix(assoc._target.name);

      // if the target is a parameter entity, it's easy just create the parameter stub
      const isParamProxy = isParameterizedEntity(assoc._target);

      // 1) construct the proxy definition
      // proxyDefinitionName: strip the serviceName and replace '.' with '_'
      let defName =
        `${assoc._target.name.replace(proxySchemaName + '.', '').replace(/\./g, '_')}`;
      
      // fullName: Prepend serviceName and if in same service add '_proxy'
      const proxy = isParamProxy
        ? createParameterEntity(assoc._target,  proxySchemaName + '.' + defName, true)
        : { name: proxySchemaName + '.' + defName, kind: 'entity', elements: Object.create(null) };

      // Final proxyShortName for all further processing
      const proxyShortName = defName + (isParamProxy ? 'Parameters' : '');

      setProp(proxy, '$proxy', true);
      setProp(proxy, '$mySchemaName', proxySchemaName);
      setProp(proxy, '$proxyShortName', proxyShortName);
      setProp(proxy, '$keys', Object.create(null));
      setProp(proxy, '$hasEntitySet', false);
      setProp(proxy, '$exposedTypes', Object.create(null));
      // copy all annotations of the target to the proxy
      Object.entries(assoc._target).forEach(([k, v]) => {
        if(k[0] === '@')
          proxy[k] = v;
      });

      // 2) create the elements and $keys
      if(isParamProxy) {
        // Reset param proxy elements to expose element tree
        const elements = proxy.elements;
        proxy.elements = Object.create(null);
        populateProxyElements(assoc, proxy, elements);
      }
      else
        populateProxyElements(assoc, proxy, assoc._target.$keys);
      return proxy;

    }

    // Return top level foreign key element definitions. The full top level
    // element is exposed instead of merging partial trees into the exposed type
    // def structure.
    function getForeignKeyDefinitions(e) {
      return e.keys ? e.keys.map(fk => e._target.elements[fk.ref[0]]) : [];
    }

    // copy over the primary keys of the target and trigger the type exposure
    // if the element already exists we assume it was fully exposed
    function populateProxyElements(assoc, proxy, elements) {
      forAll(elements, e => {
        if (isEdmPropertyRendered(e, options)) {
          let newElt = proxy.elements[e.name];
          if(!newElt) {
            if(csnUtils.isAssocOrComposition(e.type)) {
              if(!e.on && e.keys) {
                if(options.toOdata.odataNoTransitiveProxies)
                  newElt = convertManagedAssocIntoStruct(e);
                else
                  newElt = createProxyOrSchemaRefForManagedAssoc(e);
              }
              else {
                info(null, ['definitions', struct.name, 'elements', assoc.name],
                { name: proxy.nname, target: assoc._target.name },
                'Unmanaged associations are not supported as primary keys for proxy entity type $(NAME) of unexposed association target $(TARGET)');
              }
            }
            else {
              newElt = Object.create(null);
              Object.keys(e).forEach(prop => newElt[prop] = e[prop])
            }
            if(newElt) {
              initElement(newElt, e.name, proxy);
              proxy.elements[newElt.name] = newElt;

              if(csnUtils.isStructured(newElt)) {
                // argument proxySchemaName forces an anonymous type definition for newElt into the
                // proxy schema. If omitted, this exposure defaults to 'root', in case API flavor
                // of the day changes...
                exposeStructTypeForProxyOf(proxy, newElt, proxy.$proxyShortName + '_' + newElt.name,
                                          proxy.$mySchemaName, newElt.key, !!(newElt.key && newElt.elements));
              }
              if(newElt.key)
                proxy.$keys[newElt.name] = newElt;
            }
          }
        }

      });
      // 3) sort the exposed types so that they appear lexicographically ordered in the EDM
      proxy.$exposedTypes = Object.keys(proxy.$exposedTypes).sort().reduce((dict, tn) => {
        dict[tn] = proxy.$exposedTypes[tn];
        return dict
      }, Object.create(null));

      // If 'node' exists and has a structured type that is not exposed in 'service', (because the type is
      // anonymous or has a definition outside of 'service'), create an equivalent type in 'service', either
      // using the type's name or (if anonymous) 'artificialName', and make 'node' use that type instead.
      // Complain if there is an error.
      // isKey: Indicates top level element is key or not
      // forceToNotNull: if top level element is key, recursively set all anonymously exposed elements
      // to notNull until the first named type is exposed.
      function exposeStructTypeForProxyOf(proxy, node, artificialName,
                                          typeSchemaName=fallBackSchemaName,
                                          isKey, forceToNotNull) {

        if(node.type && isBuiltinType(node.type))
          return;

        // Always expose types referred to by a proxy, never reuse an eventually existing type
        // as the nested elements must all be not nullable
          // elements have precedence over type
        const typeDef = !node.elements && node.type ? csn.definitions[node.type] : node;

        if (typeDef) {
          let typeClone;
            // the type clone must be produced for each service as this type may
            // produce references and/or proxies into multiple services
            // (but only once per service, therefore cache it).
          if(typeDef.$proxyTypes && typeDef.$proxyTypes[globalSchemaPrefix]) {
              // if type has been exposed in a schema use this type
            typeClone = typeDef.$proxyTypes[globalSchemaPrefix];
          }
          else {
                // Set the correct name
            let typeId = artificialName; // the artificialName has no namespace, it's the element
            if(node.type) {
                // same as for proxies, use schema or namespace, 'root' is last resort
              typeSchemaName = typeDef.$mySchemaName || getSchemaPrefix(node.type);
              typeId = node.type.replace(typeSchemaName + '.', '').replace(/\./g, '_');
                // strip the service root of that type (if any)
              const myServiceRootName = whatsMyServiceRootName(typeSchemaName);
              if(myServiceRootName)
                typeSchemaName = typeSchemaName.replace(myServiceRootName + '.', '');
            }

            if(isStructuredArtifact(typeDef)) {
                // pull forceNotNull to false for named types and non-key nodes
                // only toplevel nodes (elements) can be key
              forceToNotNull = !!(forceToNotNull && isKey && node.elements && !node.type);

              typeClone = cloneStructTypeForProxy(typeSchemaName, `${typeSchemaName}.${typeId}`, typeDef);
              if(typeClone) {
                  // Recurse into elements of 'type' (if any)
                typeClone.elements && Object.entries(typeClone.elements).forEach(([elemName, elem]) => {
                    // if this is a foreign key elment, we must check whether or not the association
                    // has been exposed as proxy. If it has not been exposed, no further structured
                    // types must be exposed as 'Proxy_' types.

                    // TODO: expose types of assoc.keys and don't rely on exposed foreign keys
                  if(!elem['@odata.foreignKey4'] ||
                      (elem['@odata.foreignKey4'] && !typeClone.elements[elem['@odata.foreignKey4']].$exposed))
                    exposeStructTypeForProxyOf(proxy, elem, `${typeId}_${elemName}`,
                        typeSchemaName, isKey, forceToNotNull);
                });
                if(!typeDef.$proxyTypes)
                  typeDef.$proxyTypes = Object.create(null);
                typeDef.$proxyTypes[globalSchemaPrefix] = typeClone;
              }
            }
            else {
                // FUTURE: expose scalar type definition as well
            }
          }
          if(typeClone) {
              // register the type clone at the proxy
              // Reminder: Each proxy receives a full set of type clones, even if the types are shared
              // (no scattered type clone caching). registerProxy() checks if a clone needs to be added to
              // csn.definitions.
            proxy.$exposedTypes[typeClone.name] = typeClone;

              // set the node's new type name
            node.type = typeClone.name;
              // the key path generator must use the type clone directly, because it can't resolve
              // the type clone in the CSN (its name is the final name and not the definition name).
            setProp(node, '_type', typeClone);
              // Hack alert:
              // beta feature 'subElemRedirections' (now the default in v2) adds elements to the node by
              // default, without we must do it to get the primary key tuple calculation correct.
              // Remember: node.type is the service local type name (not prepended by the service name),
              // so it can't be resolved in definitions later on
            if(typeClone.elements)
              node.elements = typeClone.elements;
          }
        }

        function cloneStructTypeForProxy(typeSchemaName, name, typeDef) {
          // Create type with empty elements
          const type = {
            kind: 'type',
            name,
            elements: Object.create(null),
          };
          setProp(type, '$mySchemaName', typeSchemaName);
          setProp(type, '$exposedBy', 'proxyExposure');

          typeDef.elements && Object.entries(typeDef.elements).forEach( ([elemName, elem]) => {
            if(!elem.target) {
              type.elements[elemName] = Object.create(null);
              Object.keys(elem).forEach(prop => type.elements[elemName][prop] = elem[prop])
            }
            else if(elem.keys && !elem.on) {
                // a primary key can never be an unmanaged association
              type.elements[elemName] = createProxyOrSchemaRefForManagedAssoc(elem);
            }
            if(forceToNotNull)
              type.elements[elemName].notNull = true;
            setProp(type.elements[elemName], 'name', elem.name);
          });
          return type;
        }
      }

      // Convert a managed association into a structured type and
      // eliminate nested foreign key associations
      function convertManagedAssocIntoStruct(e) {
        let newElt = cloneCsnNonDict(e, options);
        newElt.elements = Object.create(null);
                // remove all unwanted garbage
        delete newElt.keys;
        delete newElt.target;
        delete newElt.type;
        // if this association has no keys or if it is a redirected parameterized entity,
        // use the primary keys of the target
        let keys = (!e._target.$isParamEntity && e.keys) ||
          Object.keys(e._target.$keys).map(k => { return { ref: [k] } });
        keys.forEach(k => {
          let art = e._target || csnUtils.getCsnDef(e.target);
          for(let ps of k.ref) {
            art = art.elements[ps];
          }
          // art is in the target side, clone it and remove key property
          let cloneArt = cloneCsnNonDict(art, options);
          setProp(cloneArt, 'name', art.name);
          if(e.key)
            cloneArt.notNull = true;
          delete cloneArt.key;
          newElt.elements[art.name] = cloneArt;
        });
        return newElt;
      }

      // create a new element and wire the proxy as new target.
      // Create a new proxy if:
      // 1) source and target schema names are different (otherwise)
      //    the proxy that is just being created targets back into
      //    its own serice
      // 2) or if no proxy for this source schema has been created yet
      function createProxyOrSchemaRefForManagedAssoc(e) {

        let proxy = e._target;
        let newElt = cloneCsnNonDict(e, options);

        if(isProxyRequired(e)) {
          proxy = getProxyForTargetOf(e);
          if(!proxy) {
            // option odataXServiceRefs has precedence over odataProxies
            if(e._target.$mySchemaName && options.toOdata.odataXServiceRefs) {
              proxy = createSchemaRefFor(e._target.$mySchemaName);
            }
            else if(options.toOdata.odataProxies) {
              proxy = createProxyFor(e, e._target.$mySchemaName);
              if(!e._target.$isParamEntity)
                populateProxyElements(e, proxy, getForeignKeyDefinitions(e));
            }
            proxy = registerProxy(proxy, e);
          }
        }
        if(proxy === undefined) {
          proxy = e._target;
          // no proxy: no navigation
          assignAnnotation(newElt, '@odata.navigable', false);
        }
        // either the proxy has exposed the type or
        // the assoc doesn't need to be exposed, so don't
        // try to drill further down in this type clone
        setProp(newElt, '$exposed', true);
        // _target must be set with (original) in case
        // a schema ref has been created
        setProp(newElt, '$noPartner', true);
        setProp(newElt, '_target', e._target);
        initConstraintsOnAssoc(e);
        finalizeConstraintsOnAssoc(e);
        setProp(newElt, '_constraints', e._constraints);
        setProp(newElt, '_selfReferences', []);
        if(proxy.kind === 'entity') {
          newElt.target = proxy.name;
          setProp(newElt, '_target', proxy);
        }
        return newElt;
      }
    }

    /*
      A proxy is required if the source and the target schemas differ.
      However, if two schemas are below the same root/top level service,
      these schemas are always exposed in the same Edm/DataServices. In
      this case no proxy is required. (This is especially true, if we
      decide to allow user defined schemas aka services with contexts)

      Example:

      service S {
        context T {
          entity A { ...; toB: association to S.B; };
        }
        entity B { ...; toA: association to S.T.A; };
      }

      In CSN the entity definitions are named 'S.T.A' and 'S.B', sharing
      the same service name 'S', which implies that they are always exposed
      in the same Edm => no proxy required.
    */
    function isProxyRequired(element) {
      const targetSchemaName = element._target.$mySchemaName;
      // longest match for service name
      return (!element._target.$proxy && globalSchemaPrefix !== targetSchemaName) ?
        ((targetSchemaName &&
          globalSchemaPrefix === whatsMyServiceRootName(targetSchemaName)) ? false : true) : false;
    }

    // read a proxy from the elements target
    function getProxyForTargetOf(element) {
      return element._target.$cachedProxy && element._target.$cachedProxy[globalSchemaPrefix];
    }

    // register the proxy at the elements target
    function registerProxy(proxy, element) {
      if(proxy === undefined)
        return undefined;

      setProp(proxy, '$globalSchemaPrefix', globalSchemaPrefix);
      setProp(proxy, '$origin', element);

      const fqProxyName = proxy.$globalSchemaPrefix + '.' + proxy.name;

      if(!element._target.$cachedProxy)
        assignProp(element._target, '$cachedProxy', Object.create(null));
      if(getProxyForTargetOf(element)) {
        info(null, ['definitions', struct.name, 'elements', element.name],
          { name: fqProxyName }, 'Proxy EDM entity type $(NAME) has already been registered');
      }
      else {
        determineEntitySet(proxy);
        proxyCache.push(proxy);
        element._target.$cachedProxy[globalSchemaPrefix] = proxy;
      }
      return proxy;
    }
  }

  function mergeProxiesIntoModel() {
    proxyCache.forEach(proxy => {
      const fqProxyName = proxy.$globalSchemaPrefix + '.' + proxy.name;
      const fqSchemaName = proxy.$globalSchemaPrefix + '.' + proxy.$mySchemaName;

      if(proxy.kind === 'entity') {
        // collect all schemas even for newly exposed types
        // (that may reside in another subcontext schema), but only once
        const schemaSet = new Set();
        // start with the schema name for the proxy
        schemaSet.add(fqSchemaName);
        // followed by all namespaces that are potentially exposed by the exposed types
        // don't forget to prepend the global namespace prefix
        // schemas are ordered in csn2edm.js for each service
        Object.keys(proxy.$exposedTypes).forEach(t =>
          schemaSet.add(proxy.$globalSchemaPrefix + '.' + getSchemaPrefix(t)));
        schemaSet.forEach(schemaName => {
          if(!schemas[schemaName]) {
            schemas[schemaName] = { kind: 'schema', name: schemaName };
            schemaNames.push(schemaName);
          }
        });
        /** @type {object} */
        const alreadyRegistered = csn.definitions[fqProxyName];
        if(!alreadyRegistered) {
          csn.definitions[fqProxyName] = proxy;
          reqDefs.definitions[fqProxyName] = proxy;
          setProp(proxy, '$path', ['definitions', fqProxyName]);
          Object.entries(proxy.$exposedTypes).forEach(([tn, v]) => {
            const fqtn = proxy.$globalSchemaPrefix + '.' + tn;
            if(csn.definitions[fqtn] === undefined) {
              csn.definitions[fqtn] = v;
              reqDefs.definitions[fqtn] = v;
              setProp(v, '$path', ['definitions', fqtn]);
            }
          });
          // default location is not always correct in case proxy has been created by a nested assoc
          // as foreign key targeting another proxy association
          let loc = ['definitions', proxy.$origin._parent.name, 'elements', proxy.$origin.name];
          if(proxy.$origin._parent.$path)
            loc = [...proxy.$origin._parent.$path, 'elements', proxy.$origin.name]
          info(null, loc,
            { name: proxy.name }, 'Created proxy EDM entity type $(NAME)');
        }
        else if(alreadyRegistered && !alreadyRegistered.$proxy &&
          alreadyRegistered.kind !== 'entity') {
          warning('odata-definition-exists', ['definitions', proxy.$origin._parent.name, 'elements', proxy.$origin.name],
            { '#': 'proxy', name: fqProxyName, kind: alreadyRegistered.kind });
        }
      }
      else {
        // it's a service reference, just add that reference proxy
        if(!schemas[fqSchemaName]) {
          schemas[fqSchemaName] = proxy;
          schemaNames.push(fqSchemaName);
          info(null, ['definitions', proxy.$origin._parent.name, 'elements', proxy.$origin.name],
            { name: proxy.name }, 'Created EDM namespace reference $(NAME)');
        }
        // don't error on duplicate schemas, if it's already present then all is good....
      }
    });
      // sort the global schemaNames array
    schemaNames.sort((a,b) => b.length-a.length);
  }

  /*
    Initialize the key ref paths into the property list
    Iterate over all keys and ignore the non-rendered elements
      * For Flat V2/V4 take all elements except associations/compositions,
        all elements are flat, no need to treat them any further
      * For Structured V4 flatten out all key elements, if the element
        is an association/composition, flatten out the foreign keys as well.
      * In Structured V4 do not render primary key 'parent' associations that
        establish the containment (_isToContainer=tue).
      * If in Structured V4, 'odataForeignKeys' is true, render all @foreignKey4,
        and do not render associations (this will include the foreign keys of
        the _isToContainer association).
  */
  function initEdmKeyRefPaths(def) {
    if(def.$keys) {
      setProp(def, '$edmKeyPaths', []);
      // for all key elements that shouldn't be ignored produce the paths
      foreach(def.$keys, k => !k._ignore && !(k._isToContainer && k._selfReferences.length), (k, kn) => {
        if(isEdmPropertyRendered(k, options) &&
         !(options.isV2() && k['@Core.MediaType'])) {
          if(options.isV4() && options.isStructFormat) {
          // This is structured OData ONLY
          // if the foreign keys are explicitly requested, ignore associations and use the flat foreign keys instead
            if(options.renderForeignKeys && !k.target)
              def.$edmKeyPaths.push([kn]);
          // else produce paths (isEdmPropertyRendered() has filtered @odata.foreignKey4 already)
            else if(!options.renderForeignKeys)
              def.$edmKeyPaths.push(...produceKeyRefPaths(k, kn));
          }
        // In v2/v4 flat, associations are never rendered
          else if(!k.target) {
            def.$edmKeyPaths.push([kn]);
          }
          // check toplevel key for spec violations
          checkKeySpecViolations(k, ['definitions', def.name, 'elements', k.name]);
        }
      });
    }
    /*
      Produce the list of paths for this element
      - If element is not rendered in EDM, return empty array.
      - If element is structured type, do structure flattening and then check for each
        leaf element if it is a managed association and flatten further recursively.
      - If element is a managed association, use the FK path as prefix and flatten out
        all foreign keys (eventually recursively). This filters the association itself
        to become an entry in the path array which is correct as OData doesn't allow
        navprops to be key ref.
      If element is of scalar type, return it as an array.
    */
    function produceKeyRefPaths(eltCsn, prefix) {
      const keyPaths = [];
      // we want to point to the element in the entity which is the first path step
      const location = def.$path.concat(['elements']).concat(prefix.split('/')[0]);
      if(!isEdmPropertyRendered(eltCsn, options)) {
        // let annos = Object.keys(eltCsn).filter(a=>a[0]==='@').join(', ');
        // warning(null, ['definitions', struct.name, 'elements', eltCsn.name ],
        //    `${struct.name}: OData V4 primary key path: "${prefix}" is unexposed by one of these annotations "${annos}"` );
        return keyPaths;
      }
      // OData requires all elements along the path to be nullable: false (that is either key or notNull)

      const finalType = csnUtils.getFinalTypeDef(eltCsn.items && eltCsn.items.type || eltCsn.type);
      const elements = eltCsn.elements || eltCsn.items && eltCsn.items.elements ||
      (finalType && (finalType.elements || finalType.items && finalType.items.elements));
      if(elements) {
        Object.entries(elements).forEach(([eltName, elt]) => {
          const newRefs = produceKeyRefPaths(elt, prefix + options.pathDelimiter + eltName);
          if(newRefs.length) {
            keyPaths.push(...newRefs);
            // check path step key for spec violations
            const pathSegment = `${prefix}/${eltName}`;
            checkKeySpecViolations(elt, location, pathSegment);
          }
        });
      }
      /* If element is a managed association (can't be anything else),
         flatten foreign keys and use foreign key path as new starting prefix
         This also implies that the association itself is never added into the
         list of primary key refs
      */
      else if(eltCsn.target && !eltCsn.on) {
        // if this association has no keys or if it is a redirected parameterized entity,
        // use the primary keys of the target
        let keys = (!eltCsn._target.$isParamEntity && eltCsn.keys) ||
          Object.keys(eltCsn._target.$keys).map(k => { return { ref: [k] } });
        let pathSegment = prefix
        keys.forEach(k => {
          let art = eltCsn._target || csnUtils.getCsnDef(eltCsn.target);
          for(let ps of k.ref) {
            art = art.elements[ps];
            pathSegment += '/' + art.name
            checkKeySpecViolations(art, location, pathSegment);
            if(art.type && !isBuiltinType(art.type)) {
              art = art._type || csnUtils.getCsnDef(art.type);
            }
          }
          keyPaths.push(...produceKeyRefPaths(art, prefix + options.pathDelimiter + k.ref.join(options.pathDelimiter)));
        });
      }
      else {
        keyPaths.push([prefix]);
      }
      return keyPaths;
    }

    function checkKeySpecViolations(elt, location, pathSegment) {
      // Nullability
      if((!elt.key && (elt.notNull === undefined || elt.notNull === false)) ||
           elt.key && (elt.notNull !== undefined && elt.notNull === false)) {
        error('odata-spec-violation-key-null', location,
          {name: pathSegment, '#': pathSegment ? 'std' : 'scalar'});
      }
      // many
      let type = elt.items || elt.type && !isBuiltinType(elt.type) && csnUtils.getFinalTypeDef(elt.type).items;
      if(type) {
        error('odata-spec-violation-key-array', location,
          {name: pathSegment, '#': pathSegment ? 'std' : 'scalar'});
      }
      // type
      if(!elt.elements) {
        if(!type)
          type = isBuiltinType(elt.type) ? elt : csn.definitions[elt.type];

        // check for legal scalar types, proxy exposed structured types are not resolvable in CSN
        // V2 allows any Edm.PrimitiveType (even Double and Binary), V4 is more specific:
        if(options.isV4() && type && !isAssociationOrComposition(type) && isBuiltinType(type.type)) {
          const edmType = edmUtils.mapCdsToEdmType(type);
          const legalEdmTypes = {
            'Edm.Boolean':1, 'Edm.Byte':1, 'Edm.Date':1, 'Edm.DateTimeOffset':1, 'Edm.Decimal':1, 'Edm.Duration':1,
            'Edm.Guid':1, 'Edm.Int16':1, 'Edm.Int32':1, 'Edm.Int64':1, 'Edm.SByte':1, 'Edm.String':1, 'Edm.TimeOfDay':1 };
          if(!(edmType in legalEdmTypes)) {
            warning('odata-spec-violation-key-type', location,
          {name: pathSegment, type: type.type, id: edmType, '#': pathSegment ? 'std' : 'scalar'});
          }
        }
      }
    }
  }

  /*
    Calculate all reachable entity set paths for a given navigation start point

    Rule: First non-containment association terminates Path, if association is
    containment enabling assoc, Target is own Struct/ plus the path down to the
    n-2nd path segment (which is the path to the n-1st implicit entity set).

    Example:
    entity Header {
      items: composition of many {
        toF: association to F;
        subitems: composition of many {
          toG: association to G;
          subitems: composition of many {
            toG: association to G;
          };
        }
      }
    }
    Must produce:
    Path="items/up_" Target="Header"/>
    Path="items/toF" Target="F"/>
    Path="items/subitems/up_" Target="Header/items"/>
    Path="items/subitems/toG" Target="G"/>
    Path="items/subitems/subitems/up_" Target="Header/items/subitems"/>
    Path="items/subitems/subitems/toG" Target="G"/>
  */
  function initEdmNavPropBindingTargets(def) {
    if(def.$hasEntitySet) {
      forEachGeneric(def.items || def, 'elements', (element) => {
        produceTargetPath([edmUtils.getBaseName(def.name)], element, def);
      });
    }

    function produceTargetPath(prefix, elt, curDef) {
      const newPrefix = [...prefix, elt.name];
      if(isEdmPropertyRendered(elt, options)) {
        // Assoc can never be a derived TypeDefinition, no need to
        // unroll derived type chains for assocs
        if(isAssociationOrComposition(elt) && !elt.$touched) {
          if(!elt._target.$edmTgtPaths)
            setProp(elt._target, '$edmTgtPaths', []);
          if(!elt._target.$hasEntitySet && !elt._isToContainer && curDef !== elt._target) {
            // follow elements in the target but avoid cycles
            setProp(elt, '$touched', true);
            elt._target.$edmTgtPaths.push(newPrefix);
            Object.values(elt._target.elements).forEach(e => produceTargetPath(newPrefix, e, elt._target));
            delete elt.$touched;
          }
        }
        else {
          // try to find elements to drill down further
          while(elt && !(isBuiltinType(elt.type) || elt.elements)) {
            elt = csn.definitions[elt.type];
          }
          elt && elt.elements && Object.values(elt.elements).forEach(e => produceTargetPath(newPrefix, e, curDef));
        }
      }
    }
  }

  function initEdmNavPropBindingPaths(def) {
    if(options.isV4() &&def.$hasEntitySet) {
      let npbs = [];
      forEachGeneric(def.items || def, 'elements', (element) => {
        npbs = npbs.concat(produceNavigationPath(element, def));
      });
      setProp(def, '$edmNPBs', npbs);
    }

    // collect all paths originating from this element that end up in an entity set
    function produceNavigationPath(elt, curDef) {
      let npbs = [];
      const prefix = elt.name;
      if(isEdmPropertyRendered(elt, options)) {
        // Assoc can never be a derived TypeDefinition, no need to
        // unroll derived type chains for assocs
        if(isAssociationOrComposition(elt) && !elt.$touched) {
          // drill into target only if
          // 1) target has no entity set and this assoc is not going to the container
          // 2) current definition and target are the same (cycle)
          if(!elt.$externalRef &&
             !elt._target.$hasEntitySet &&
             !elt._isToContainer &&
             curDef !== elt._target) {
            // follow elements in the target but avoid cycles
            setProp(elt, '$touched', true);
            Object.values(elt._target.elements).forEach(e => npbs = npbs.concat(produceNavigationPath(e, elt._target)));
            delete elt.$touched;
          }
          else if(!(options.odataContainment && options.isV4() && elt['@odata.contained'])) {
            // end point reached but must not be an external reference nor a proxy nor a composition itself
            // last assoc step must not be to-n and target a singleton
            let p = undefined;
            if (!elt.$externalRef &&
                !(edmUtils.isToMany(elt) &&
                edmUtils.isSingleton(elt._target) &&
                options.isV4())) {
              if(elt._target.$edmTgtPaths && elt._target.$edmTgtPaths.length) {
                p = elt._target.$edmTgtPaths.find(p => p[0] === edmUtils.getBaseName(def.name)) || elt._target.$edmTgtPaths[0];
              }
              else if(elt._target.$hasEntitySet) {
                const baseName = edmUtils.getBaseName(elt._target.$entitySetName || elt._target.name);
                // if own struct and target have a set they either are in the same $mySchemaName or not
                // if target is in another schema, target the full qualified entity set
                p = (elt._target.$mySchemaName === def.$mySchemaName) ?
                  [ baseName ] : [elt._target.$mySchemaName + '.EntityContainer', baseName];
              }
              if(p) {
                // if own struct and target have a set they either are in the same $mySchemaName or not
                // if target is in another schema, target the full qualified entity set
                const npb = {
                  Path: elt.name,
                  Target: p.join('/')
                };
                npbs.push( npb );
              }
            }
            // Do not prepend prefix here!
            return npbs;
          }
        }
        else {
          // try to find elements to drill down further
          while(elt && !(isBuiltinType(elt.type) || elt.elements)) {
            elt = csn.definitions[elt.type];
          }
          elt && elt.elements && Object.values(elt.elements).forEach(e => npbs = npbs.concat(produceNavigationPath(e, curDef)));
        }
      }
      npbs.forEach(p => p.Path = prefix + '/' + p.Path );
      return npbs;
    }
  }

  function determineEntitySet(def) {
    // if this is an entity or a view, determine if an entity set is required or not
    // 1) must not be a proxy and not a containee in V4
    // No annos are rendered for non-existing EntitySet targets.
    if(def.$hasEntitySet === undefined) {
      const hasEntitySet = isEntity(def) && !(options.isV4() && edmUtils.isContainee(def)) && !def.$proxy;
      setProp(def, '$hasEntitySet', hasEntitySet);
    }
  }

  function initEdmTypesAndDescription(def) {
    // 1. let all doc props become @Core.Descriptions
    // 2. mark a member that will become a collection
    // 3. assign the edm primitive type to elements, to be used in the rendering later
    assignAnnotation(def, '@Core.Description', def.doc);
    markCollection(def);
    mapCdsToEdmProp(def);
    if (def.returns)  {
      markCollection(def.returns);
      mapCdsToEdmProp(def.returns);
    }
    forEachMemberRecursively(def,member => {
      assignAnnotation(member, '@Core.Description', member.doc);
      markCollection(member);
      mapCdsToEdmProp(member);
      ComputedDefaultValue(member);
      if (member.returns) {
        markCollection(member.returns);
        mapCdsToEdmProp(member.returns);
      }
    });
    // mark members that need to be rendered as collections
    function markCollection(obj) {
      const items = obj.items || csn.definitions[obj.type] && csn.definitions[obj.type].items;
      if (items) {
        assignProp(obj, '_NotNullCollection', items.notNull !== undefined ? items.notNull : true);
        assignProp(obj, '_isCollection', true);
      }
    }
  }


  //////////////////////////////////////////////////////////////////////
  //
  // Checks section starts here
  //

// eslint-disable-next-line no-unused-vars
  function resolveForeignKeyRefs() {
    forEachDefinition(csn, (def, defName) => {
      let currPath = ['definitions', defName ];
      forEachMemberRecursively(def, (construct, _constructName, _prop, path) => {
        if(construct.target && construct.keys) {
          construct.keys.forEach((fk, i) => {
            setProp(fk, '_artifact', csnUtils.inspectRef([...path, 'keys', i]).art);
          });
        }
      }, currPath, true, { elementsOnly: true });
    });
  }


  function inboundQualificationChecks() {
    forEachDefinition(csn, [ attach$path, checkChainedArray ]);
    checkNestedContextsAndServices();
    throwWithAnyError();

    // attach $path to all
    function attach$path(def, defName) {
      setProp(def, '$path', [ 'definitions', defName ]);
      forEachMemberRecursively(def,
        (member, _memberName, _prop, path) => {
          setProp(member, '$path', path);
        }, [ 'definitions', defName ]);
    }

    function checkChainedArray(def, defName) {
      if (!isMyServiceRequested(defName))
        return;
      let currPath = ['definitions', defName];
      checkIfItemsOfItems(def, undefined, undefined, currPath);
      forEachMemberRecursively(def, checkIfItemsOfItems, currPath);

      function checkIfItemsOfItems(construct, _constructName, _prop, path) {
        const constructType = csnUtils.effectiveType(construct);
        if (constructType.items) {
          if (constructType.items.items) {
            message('chained-array-of', path);
            return;
          }

          const itemsType = csnUtils.effectiveType(constructType.items);
          if (itemsType.items)
            message('chained-array-of', path);
        }
      }
    }

    function checkNestedContextsAndServices() {
      !isBetaEnabled(options, 'nestedServices') && serviceRootNames.forEach(sn => {
        const parent = whatsMyServiceRootName(sn, false);
        if(parent && requestedServiceNames.includes(parent) && parent !== sn) {
          message( 'service-nested-service', [ 'definitions', sn ], { art: parent },
               'A service can\'t be nested within a service $(ART)' );
        }
      });

      Object.entries(csn.definitions).forEach(([fqName, art]) => {
        if(art.kind === 'context') {
          const parent = whatsMyServiceRootName(fqName);
          if(requestedServiceNames.includes(parent)) {
            message( 'service-nested-context', [ 'definitions', fqName ], { art: parent },
               'A context can\'t be nested within a service $(ART)' );
          }
        }
      });
    }
  }

  //
  // Checks Secition ends here
  //
  //////////////////////////////////////////////////////////////////////




  //////////////////////////////////////////////////////////////////////
  //
  // Helper section starts here
  //

  //
  // create Cross Schema Reference object
  //
  function createSchemaRef(targetSchemaName) {
    // prepend as many path ups '..' as there are path steps in the service ref
    let serviceRef = path4(serviceRoots[targetSchemaName]).split('/').filter(c=>c.length);
    serviceRef.splice(0, 0, ...Array(serviceRef.length).fill('..'));
    // uncomment this to make $metadata absolute
    // if(serviceRef.length===0)
    //   serviceRef.push('');
    if(serviceRef[serviceRef.length-1] !== '$metadata')
      serviceRef.push('$metadata');
    let sc = { kind: 'reference',
      name: targetSchemaName,
      ref: { Uri: serviceRef.join('/') },
      inc: { Namespace: targetSchemaName }
    };
    setProp(sc, '$mySchemaName', targetSchemaName);
    return sc;

    /**
     * Resolve a service endpoint path to mount it to as follows...
     * Use _path or def[@path] if given (and remove leading '/')
     * Otherwise, use the service definition name with stripped 'Service'
     */
    function path4 (def, _path = def['@path']) {
      if (_path)
        return _path.replace(/^\//, "");
      else
        return ( // generate one from the service's name
          /[^.]+$/.exec(def.name)[0]  //> my.very.CatalogService --> CatalogService
          .replace(/Service$/,'')     //> CatalogService --> Catalog
          .replace(/([a-z0-9])([A-Z])/g, (_,c,C) => c+'-'+C.toLowerCase())  //> ODataFooBarX9 --> odata-foo-bar-x9
          .replace(/_/g,'-')  //> foo_bar_baz --> foo-bar-baz
          .toLowerCase()      //> FOO --> foo
        )
    }
  }


  // If containment in V4 is active, annotations that would be assigned to the containees
  // entity set are not renderable anymore. In such a case try to reassign the annotations to
  // the containment navigation property.
  // Today only Capabilities.*Restrictions are known to be remapped as there exists a CDS
  // short cut annotation @readonly that gets expanded and can be safely remapped.
  function rewriteContainmentAnnotations(container, containee, assocName) {
    // rectify Restrictions to NavigationRestrictions
    if(options.isV4()) {
      let navPropEntry;
      let hasEntry = false;
      let newEntry = false;
      const anno = '@Capabilities.NavigationRestrictions.RestrictedProperties';
      let resProps = container[anno];
      // merge into existing anno, if available
      if(resProps) {
        navPropEntry = resProps.find(p => p.NavigationProperty && p.NavigationProperty['='] === assocName);
        hasEntry = !!navPropEntry;
      }
      if(!navPropEntry) {
        navPropEntry =  { NavigationProperty: { '=': assocName } };
      }

      const props = Object.entries(containee);

      const merge = (prefix) => {
        const prop = prefix.split('.')[1];
        // don't overwrite existing restrictions
        if(!navPropEntry[prop]) {
          // Filter properties with prefix and reduce them into a new dictionary
          const o = props.filter(p => p[0].startsWith(prefix+'.')).reduce((a,c) => {
            a[c[0].replace(prefix+'.', '')] = c[1];
            return a;
          }, { });
          // if dictionary has entries, add them to navPropEnty
          if(Object.keys(o).length) {
            // ReadRestrictions may have sub type ReadByKeyRestrictions { Description, LongDescription }
            // chop annotations into dictionaries
            if(prefix === '@Capabilities.ReadRestrictions' && 
               Object.keys(o).some(k => k.startsWith('ReadByKeyRestrictions.'))) {
              const no = {};
              Object.entries(o).forEach(([k,v]) => {
                const [head, ...tail] = k.split('.');
                if(head === 'ReadByKeyRestrictions' && tail.length) {
                  if(!no['ReadByKeyRestrictions'])
                    no['ReadByKeyRestrictions'] = {};
                  // Don't try to add entry into non object
                  if(typeof no['ReadByKeyRestrictions'] === 'object')
                    no['ReadByKeyRestrictions'][tail.join('.')] = v;
                }
                else {
                  no[k] = v;
                }
              });
              navPropEntry[prop] = no;
            }
            else {
              navPropEntry[prop] = o;
            }
            newEntry = true;
          }
        }
      }
      merge('@Capabilities.DeleteRestrictions');
      merge('@Capabilities.InsertRestrictions');
      merge('@Capabilities.UpdateRestrictions');
      merge('@Capabilities.ReadRestrictions');

      if(newEntry) {
        if(!hasEntry) {
          if(!resProps)
            resProps = container[anno] = [ ];
          resProps.push(navPropEntry);
        }
      }
    }
  }

  function mapCdsToEdmProp(obj) {
    if (obj.type && isBuiltinType(obj.type) && !isAssociationOrComposition(obj) && !obj.targetAspect) {
      let edmType = edmUtils.mapCdsToEdmType(obj, messageFunctions, _options.toOdata.version === 'v2', obj['@Core.MediaType']);
      assignProp(obj, '_edmType', edmType);
    } else if (obj._isCollection && (obj.items && isBuiltinType(csnUtils.getFinalTypeDef(obj.items.type)))) {
      let edmType = edmUtils.mapCdsToEdmType(obj.items, messageFunctions, _options.toOdata.version === 'v2', obj['@Core.MediaType'], obj.$path);
      assignProp(obj, '_edmType', edmType);
    }
    // This is the special case when we have array of array, but will not be supported in the future
    else if (obj._isCollection && obj.items && obj.items.type && obj.items.items && isBuiltinType(csnUtils.getFinalTypeDef(obj.items.items.type))) {
      let edmType = edmUtils.mapCdsToEdmType(obj.items.items, messageFunctions, _options.toOdata.version === 'v2', obj['@Core.MediaType']);
      assignProp(obj, '_edmType', edmType);
    }
  }

  function ComputedDefaultValue(member) {
    if (member.default && !csn['@Core.ComputedDefaultValue']) {
      let def = member.default;
      let noTailExpr = false;
      if(def.xpr) {
        let i = 0;
        // consume all unary signs
        while(def.xpr[i] === '-' || def.xpr[i] === '+') i++;
        // noTailExpr is true if there is nothing behind the next token in the stream
        noTailExpr = i < def.xpr.length-1;
        def = def.xpr[i];
      }
      // it is a computed value if it is not a simple value or an annotation
      if(!((def.val !== undefined && !noTailExpr) || def['#'])) {
        assignAnnotation(member, '@Core.ComputedDefaultValue', true);
      }
    }
  }
}




/*
 * Late application specific transformations
 *  At present there are two transformation targets: Structure and Element
 *  These transformations are available today:
 *
 *  Analytical Scenario:
 *    If a structure is annotated with @Aggregation.ApplySupported.PropertyRestrictions
 *    then a number of annotation rewrites are done to this structure and to the
 *    elements of this structure
 *    Also the key properties of all structure elements are removed and a new
 *    artificial key element 'key _ID : String' is inserted at first position of
 *    the elements dictionary
 *
 * PDM (Personal Data Management)
 *    Planned but not yet implemented annotation rewriting (pending to finalization)
 * /

/* eslint max-statements-per-line:off */

function mapAnnotationAssignment(artifact, parent, mappingDictionary)
{
  let props = intersect(Object.keys(mappingDictionary), Object.keys(artifact));
  // now start the substitution
  props.forEach(prop => {
    let [ mapping, value, remove_original ] = mappingDictionary[prop];
    if(mapping instanceof Function)
    {
      mapping(artifact, parent, prop);
    }
    else
    {
      assignAnnotation(artifact, mapping, value || artifact[prop]['='] || artifact[prop]);
    }

    if(remove_original)
      delete artifact[prop];
  });
}

function applyAppSpecificLateCsnTransformationOnElement(options, element, struct, error)
{
  if(options.isV2())
  {
    if(struct['@Aggregation.ApplySupported.PropertyRestrictions'])
    {
      mapAnnotationAssignment(element, struct, AnalyticalAnnotations());
    }
    mapAnnotationAssignment(element, struct, PDMSemantics());
  }

  // etag requires Core.OptimisticConcurrency to be set in V4 (cap/issues#2641)
  // Oliver Heinrich mentions in the issue that the Okra runtime must be set to a
  // concurrent runtime mode by the caller, if the annotation is added this late,
  // it doesn't appear in the forOData processed CSN, meaning that the
  // runtime cannot set that okra flag (alternatively the runtime has to search
  // for @[odata|cds].etag annotations...
  if(options.isV4())
  {
    if(element['@odata.etag'] == true || element['@cds.etag'] == true) {
      // don't put element name into collection as per advice from Ralf Handl, as
      // no runtime is interested in the property itself, it is sufficient to mark
      // the entity set.
      assignAnnotation(struct, '@Core.OptimisticConcurrency',
        (struct['@Core.OptimisticConcurrency'] || [])/*.push(element.name)*/);
    }
  }

  // nested functions begin
  function PDMSemantics()
  {
    /*
    let dict = Object.create(null);

    dict['@PDM.xxx1'] = [ '@sap.pdm-semantics' ];
    dict['@PDM.xxx2'] = [ '@sap.pdm-propery' ];
    dict['@PDM.xxx3'] = [ '@sap.pdm-display-sq-no' ];
    dict['@PDM.xxx4'] = [ '@sap.pdm-record-identifier' ];
    dict['@PDM.xxx5'] = [ '@sap.pdm-field-group' ];
    dict['@PDM.xxx6'] = [ '@sap.pdm-mask-find-pattern' ];
    dict['@PDM.xxx7'] = [ '@sap.pdm-mask-replacement-pattern' ];
    dict['@PDM.xxx8'] = [ '@sap.deletable' ];
    dict['@PDM.xxx8'] = [ '@sap.updatable' ];

    // respect flattened annotation $value
    Object.keys(dict).forEach(k => dict[k+'.$value'] = dict[k]);
    */
    return Object.create(null);
  }

  function AnalyticalAnnotations()
  {
    function mapCommonAttributes(element, struct, prop)
    {
      let CommonAttributes = element[prop];
      if(!Array.isArray(CommonAttributes)) {
        error(null, ['definitions', struct.name, 'elements', element.name],
          { anno: '@Common.attribute', code: JSON.stringify(CommonAttributes) },
          `Expect array value for $(ANNOTATION): $(CODE)`);
        return;
      }

      let targets = intersect(CommonAttributes, Object.keys(struct.elements));
      targets.forEach(tgt => {
        assignAnnotation(struct.elements[tgt], '@sap.attribute-for', element.name);
      });
    }

    function mapContextDefiningProperties(element, struct, prop)
    {
      let ContextDefiningProperties = element[prop];
      if(!Array.isArray(ContextDefiningProperties)) {
        error(null, ['definitions', struct.name, 'elements', element.name],
          { anno: '@Aggregation.ContextDefiningProperties', code: JSON.stringify(ContextDefiningProperties) },
          `Expect array value for $(ANNOTATION): $(CODE)`);
        return;
      }
      if(ContextDefiningProperties.length > 0)
        assignAnnotation(element, '@sap.super-ordinate', ContextDefiningProperties[ContextDefiningProperties.length-1]);
    }

    let dict = Object.create(null);
    //analytics term definition unknown, lower case
    dict['@Analytics.Measure'] = [ '@sap.aggregation-role', 'measure' ];
    dict['@Analytics.Dimension'] = [ '@sap.aggregation-role', 'dimension' ];
    dict['@Semantics.currencyCode'] = [ '@sap.semantics', 'currency-code', true ];
    dict['@Semantics.unitOfMeasure'] = [ '@sap.semantics', 'unit-of-measure', true ];

    dict['@Measures.ISOCurrency'] = [ '@sap.unit' ];
    dict['@Measures.Unit'] = [ '@sap.unit' ];

    dict['@Common.Label'] = [ '@sap.label' ];
    dict['@Common.Text'] = [ '@sap.text' ];
    dict['@Aggregation.ContextDefiningProperties'] = [ mapContextDefiningProperties ];
    dict['@Common.Attributes'] = [ mapCommonAttributes ];

    // respect flattened annotation $value
    Object.entries(dict).forEach(([k, v]) => dict[k+'.$value'] = v);
    return dict;
  }
}

function applyAppSpecificLateCsnTransformationOnStructure(options, struct, error)
{
  if(options.isV2())
  {
    if(struct['@Aggregation.ApplySupported.PropertyRestrictions'])
    {
      transformAnalyticalModel(struct);
      mapAnnotationAssignment(struct, undefined, AnalyticalAnnotations());
    }
  }

  // nested functions begin
  function transformAnalyticalModel(struct)
  {
    let keyName = 'ID__';
    if(struct == undefined || struct.elements == undefined || struct.elements[keyName] != undefined)
      return;

    // remove key prop from elements, add new key to elements
    let elements = Object.create(null);
    let key =  { name: keyName, key : true, type : 'cds.String', '@sap.sortable':false, '@sap.filterable':false, '@UI.Hidden': true };
    elements[keyName] = key;
    setProp(struct, '$keys',{ [keyName] : key } );
    forEachGeneric(struct.items || struct, 'elements', (e,n) =>
    {
      if(e.key) delete e.key;
      elements[n] = e;
    });
    struct.elements = elements;
  }

  function AnalyticalAnnotations()
  {
    function mapFilterRestrictions(struct, parent, prop)
    {
      let stringDict = Object.create(null);
      stringDict['SingleValue'] = 'single-value';
      stringDict['MultiValue'] = 'multi-value';
      stringDict['SingleRange'] = 'interval';

      let filterRestrictions = struct[prop];
      if(!Array.isArray(filterRestrictions)) {
        error(null, ['definitions', struct.name ],
          { anno: '@Capabilities.FilterRestrictions.FilterExpressionRestrictions',
            code: JSON.stringify(filterRestrictions) },
          `Expect array value for $(ANNOTATION): $(CODE)`);
        return;
      }
      filterRestrictions.forEach(v => {
        let e = struct.elements[v.Property];
        if(e)
          assignAnnotation(e, '@sap.filter-restriction', stringDict[v.AllowedExpressions]);
      });
    }

    function mapRequiredProperties(struct, parent, prop)
    {
      let requiredProperties = struct[prop];
      if(!Array.isArray(requiredProperties)) {
        error(null, ['definitions', struct.name],
          { anno: '@Capabilities.FilterRestrictions.RequiredProperties',
            code: JSON.stringify(requiredProperties) },
          `Expect array value for $(ANNOTATION): $(CODE)`);
        return;
      }

      let props = intersect(Object.keys(struct.elements), requiredProperties)
      props.forEach(p => {
        assignAnnotation(struct.elements[p], '@sap.required-in-filter', true);
      });
    }

    function mapRequiresFilter(struct, parent, prop)
    {
      let requiresFilter = struct[prop];
      if(requiresFilter)
        assignAnnotation(struct._SetAttributes, '@sap.requires-filter', requiresFilter);
    }

      // Entity Props
    let dict = Object.create(null);
    dict['@Aggregation.ApplySupported.PropertyRestrictions'] = [ '@sap.semantics', 'aggregate' ];
    dict['@Common.Label'] = [ '@sap.label' ];
    dict['@Capabilities.FilterRestrictions.RequiresFilter'] = [ mapRequiresFilter ];
    dict['@Capabilities.FilterRestrictions.RequiredProperties'] = [ mapRequiredProperties ];
    dict['@Capabilities.FilterRestrictions.FilterExpressionRestrictions'] = [ mapFilterRestrictions ];

    // respect flattened annotation $value
    Object.keys(dict).forEach(k => dict[k+'.$value'] = dict[k]);

    return dict;
  }
}

function setSAPSpecificV2AnnotationsToEntityContainer(options, carrier) {
  if(!options.isV2())
    return;
  // documented in https://wiki.scn.sap.com/wiki/display/EmTech/SAP+Annotations+for+OData+Version+2.0#SAPAnnotationsforODataVersion2.0-Elementedm:EntityContainer
  const SetAttributes = {
    // EntityContainer only
    '@sap.supported.formats' : addToSetAttr,
    '@sap.use.batch': addToSetAttr,
    '@sap.message.scope.supported': addToSetAttr,
  };

  Object.entries(carrier).forEach(([p, v]) => {
    (SetAttributes[p] || function() { /* no-op */ })(carrier, p, v);
  });

  function addToSetAttr(carrier, propName, propValue, removeFromType=true) {
    assignProp(carrier, '_SetAttributes', Object.create(null));
    assignAnnotation(carrier._SetAttributes, propName, propValue);
    if(removeFromType) {
      delete carrier[propName];
    }
  }
}

function setSAPSpecificV2AnnotationsToEntitySet(options, carrier) {
  if(!options.isV2())
    return;
  // documented in https://wiki.scn.sap.com/wiki/display/EmTech/SAP+Annotations+for+OData+Version+2.0#SAPAnnotationsforODataVersion2.0-Elementedm:EntitySet
  const SetAttributes = {
    // EntitySet, EntityType
    '@sap.label' : (s,pn, pv) => { addToSetAttr(s, pn, pv, false); },
    '@sap.semantics': checkSemantics,
    // EntitySet only
    '@sap.creatable' : addToSetAttr,
    '@sap.updatable' : addToSetAttr,
    '@sap.deletable': addToSetAttr,
    '@sap.updatable.path': addToSetAttr,
    '@sap.deletable.path': addToSetAttr,
    '@sap.searchable' : addToSetAttr,
    '@sap.pagable': addToSetAttr,
    '@sap.topable': addToSetAttr,
    '@sap.countable': addToSetAttr,
    '@sap.addressable': addToSetAttr,
    '@sap.requires.filter': addToSetAttr,
    '@sap.change.tracking': addToSetAttr,
    '@sap.maxpagesize': addToSetAttr,
    '@sap.delta.link.validity': addToSetAttr,
  };

  Object.entries(carrier).forEach(([p, v]) => {
    (SetAttributes[p] || function() { /* no-op */ })(carrier, p, v);
  });

  function addToSetAttr(carrier, propName, propValue, removeFromType=true) {
    assignProp(carrier, '_SetAttributes', Object.create(null));
    assignAnnotation(carrier._SetAttributes, propName, propValue);
    if(removeFromType) {
      delete carrier[propName];
    }
  }

  function checkSemantics(struct, propName, propValue) {
    if(propValue === 'timeseries' || propValue === 'aggregate') {
      // aggregate is forwarded to Set and must remain on Type
      addToSetAttr(struct, propName, propValue, propValue !== 'aggregate');
    }
  }
}

function setSAPSpecificV2AnnotationsToAssociation(carrier) {
  // documented in https://wiki.scn.sap.com/wiki/display/EmTech/SAP+Annotations+for+OData+Version+2.0
  const SetAttributes = {
    // Applicable to NavProp and foreign keys, add to AssociationSet
    '@sap.creatable' : (c, pn, pv) => { addToAssociationSet(c, pn, pv, false); },
    // Not applicable to NavProp, applicable to foreign keys, add to AssociationSet
    '@sap.updatable' : addToAssociationSet,
    // Not applicable to NavProp, not applicable to foreign key, add to AssociationSet
    '@sap.deletable': (c, pn, pv) => {
      addToAssociationSet(c, pn, pv);
      removeFromForeignKey(c, pn);
    },
    // applicable to NavProp, not applicable to foreign keys, not applicable to AssociationSet
    '@sap.creatable.path': removeFromForeignKey,
    '@sap.filterable': removeFromForeignKey,
  };

  Object.entries(carrier).forEach(([p, v]) => {
    (SetAttributes[p] || function() {/* no-op */})(carrier, p, v);
  });

  function addToAssociationSet(carrier, propName, propValue, removeFromType=true) {
    if(isAssociationOrComposition(carrier)) {
      assignProp(carrier, '_SetAttributes', Object.create(null));
      assignAnnotation(carrier._SetAttributes, propName, propValue);
      if(removeFromType) {
        delete carrier[propName];
      }
    }
  }

  function removeFromForeignKey(carrier, propName) {
    if(carrier['@odata.foreignKey4'] && carrier[propName] !== undefined) {
      delete carrier[propName];
    }
  }
}

// Assign but not overwrite annotation
function assignAnnotation(node, name, value) {
  if(value !== undefined &&
      name !== undefined && name[0] === '@' &&
      (node[name] === undefined ||
      node[name] && node[name] === null)) {
    node[name] = value;
  }
}

// Set non enumerable property if it doesn't exist yet
function assignProp(obj, prop, value) {
  if(obj[prop] === undefined) {
    setProp(obj, prop, value);
  }
}

module.exports = {
  initializeModel,
  assignAnnotation
}
