'use strict';

const { csnRefs, implicitAs } = require('../model/csnRefs');
const { applyTransformations, applyTransformationsOnNonDictionary } = require('../transform/db/applyTransformations');
const { isBuiltinType } = require('../compiler/builtins.js')
const { sortCsn, cloneCsnDictionary: _cloneCsnDictionary } = require('../json/to-csn');
const { ModelError } = require("../base/error");
const version = require('../../package.json').version;

// Low-level utility functions to work with compact CSN.

/**
 * Generic Callback
 *
 * @callback genericCallback
 * @param {any} art
 * @param {string} name Artifact Name
 * @param {string} prop Dictionary Property
 * @param {CSN.Path} path Location
 * @param {CSN.Artifact} [dictionary]
 */

/**
 * @callback refCallback
 * @param {any} ref
 * @param {object} node
 * @param {CSN.Path} path
 */

/**
 * @callback queryCallback
 * @param {CSN.Query} query
 * @param {CSN.Path} path
 */

/**
 * Get utility functions for a given CSN.
 * @param {CSN.Model} model (Compact) CSN model
 */
function getUtils(model, universalReady) {
  const { artifactRef, inspectRef, effectiveType, getOrigin, targetAspect, getColumn, getElement, initDefinition } = csnRefs(model, universalReady);

  return {
    getCsnDef,
    isStructured,
    getFinalType,
    getFinalTypeDef,
    isManagedAssociation,
    isAssocOrComposition,
    isAssociation,
    isComposition,
    getArtifactDatabaseNameOf,
    getNamespaceOfArtifact,
    getContextOfArtifact,
    addStringAnnotationTo,
    getServiceName,
    hasAnnotationValue,
    cloneWithTransformations,
    getFinalBaseType,
    inspectRef,
    artifactRef,
    effectiveType,
    get$combined,
    getOrigin,
    getQueryPrimarySource,
    targetAspect,
    getColumn,
    getElement,
    initDefinition
  };

  /**
   * Compute and return $combined for the given query.
   *
   * @param {CSN.Query} query
   * @returns {object}
   */
  function get$combined(query) {
    return getSources(query);
  }

  /**
   * Get the union of all elements from the from clause
   * - descend into unions, following the lead query
   * - merge all queries in case of joins
   * - follow subqueries
   *
   * @param {CSN.Query} query Query to check
   * @param {boolean} [isSubquery]
   * @returns {object} Map of sources
   */
  function getSources(query, isSubquery=false) {
    // Remark CW: better just a while along query.SET.args[0]
    if (query.SET) {
      if (query.SET.args[0].SELECT && query.SET.args[0].SELECT.elements)
        return mergeElementsIntoMap(Object.create(null), query.SET.args[0].SELECT.elements, query.SET.args[0].$location);

      return getSources(query.SET.args[0], isSubquery);
    }
    else if (query.SELECT) {
      if (query.SELECT.from.args) {
        return walkArgs(query.SELECT.from.args);
      }
      else if (query.SELECT.from.ref) {
        let art = artifactRef(query.SELECT.from);

        if(art.target)
          art = artifactRef(art.target);

        if(isSubquery && !query.SELECT.elements)
          throw new ModelError('Expected subquery to have .elements');

        return mergeElementsIntoMap(Object.create(null), isSubquery ? query.SELECT.elements : art.elements, art.$location,
          query.SELECT.from.as || query.SELECT.from.ref[query.SELECT.from.ref.length - 1],
          query.SELECT.from.ref[query.SELECT.from.ref.length - 1] || query.SELECT.from.as );
      }
      else if (query.SELECT.from.SET || query.SELECT.from.SELECT) {
        return getSources(query.SELECT.from, true);
      }
    }

    return {};
  }

  function walkArgs(args) {
    let elements = Object.create(null);
    for (const arg of args) {
      if (arg.args) {
        elements = mergeElementMaps(elements, walkArgs(arg.args));
      }
      else if (arg.ref) {
        const art = artifactRef(arg);
        elements = mergeElementsIntoMap(elements, art.elements, art.$location, arg.as || arg.ref[arg.ref.length - 1], arg.ref[arg.ref.length - 1] || arg.as);
      }
      else if (arg.SELECT || arg.SET) {
        elements = mergeElementMaps(elements, getSources(arg));
      }
    }

    return elements;
  }

  /**
   * Merge two maps of elements together
   *
   * @param {object} mapA Map a - will be returned
   * @param {object} mapB Map b - will not be returned
   * @returns {object} mapA
   */
  function mergeElementMaps(mapA, mapB) {
    for (const elementName in mapB) {
      if (!mapA[elementName])
        mapA[elementName] = [];

      mapB[elementName].forEach(e => mapA[elementName].push(e));
    }

    return mapA;
  }

  /**
   * Merge elements into an existing map
   *
   * @param {any} existingMap map to merge into - will be returned
   * @param {object} elements elements to merge into the map
   * @param {CSN.Location} $location $location of the elements - where they come from
   * @param {any} [parent] Name of the parent of the elements, alias before ref
   * @param {any} [error_parent] Parent name to use for error messages, ref before alias
   * @returns {object} existingMap
   */
  function mergeElementsIntoMap(existingMap, elements, $location, parent, error_parent) {
    for (const elementName in elements) {
      const element = elements[elementName];
      if (!existingMap[elementName])
        existingMap[elementName] = [];


      existingMap[elementName].push({
        element, name: elementName, source: $location, parent: getBaseName(parent), error_parent,
      });
    }

    return existingMap;
  }

  /**
   * Return the name part of the artifact name - no namespace etc.
   * @param {string|object} name Absolute name of the artifact
   */
  function getBaseName(name) {
    if (!name)
      return name;

    if (name.id)
      return name.id.substring( name.id.lastIndexOf('.')+1 );

    return name.substring( name.lastIndexOf('.')+1 )
  }

  /**
   * Return the left-most, primary source of the given query.
   * @param {*} query Definition's query object
   */
  function getQueryPrimarySource(query) {
    if (!query)
      return undefined;
    else if (query.SELECT) {
      return getQueryPrimarySource(query.SELECT);
    } else if (query.SET) {
      return getQueryPrimarySource(query.SET);
    } else if (query.from) {
      return getQueryPrimarySource(query.from);
    } else if (query.ref) {
      return query;
    } else if (query.args) {
      return getQueryPrimarySource(query.args[0]);
    }
    return undefined;
  }


  /**
   * Create an object to track visited objects identified by a unique string.
   * @param {string} [initialId] Initial entry (optional)
   */
  function createVisited(initialId) {
    let visited = Object.create(null);
    check(initialId);
    return { check };

    /**
     * Check if an identifier has already been visited and
     * add it to the list of visited identifiers.
     * @param {string} id unique identifier
     */
    function check(id) {
      if (!id) return;
      if (visited[id]) {
        throw new ModelError('Circular dependency');
      }
      visited[id] = true;
    }
  }

  /**
   * Get the CSN definition for an artifact name.
   * @param {string} defName Absolute name of the artifact
   */
  function getCsnDef(defName) {
    if (model.definitions[defName])
      return model.definitions[defName]
    else
      throw new ModelError(`Nonexistent definition in the model: '${defName}'`);
  }

  /**
   * Returns true if an artifact is a structured type
   * or a typedef of a structured type.
   *
   * @param {object} obj
   */
  function isStructured(obj) {
    return obj.elements ||
      (obj.type && ((getFinalTypeDef(obj.type).elements) || (obj.type.ref && getFinalBaseType(obj.type).elements)));
  }

  /**
   * Resolves typedefs to its final typedef which is returned.
   * If the artifact for typename isn't a typedef, the name itself is returned.
   *
   * @param {string} typeName Absolute type name
   * @returns {object}
   */
  function getFinalTypeDef(typeName) {
    let visited = createVisited(typeName);
    let type = model.definitions[typeName];
    if (!type) {
      return typeName;
    }
    for (let nextType = type; nextType;) {
      type = nextType;
      visited.check(type.type);
      nextType = model.definitions[nextType.type];
    }
    return type;
  }

  /**
   * Resolves typedefs to its final type (name) which is returned.
   * @param {string} typeName Absolute type name
   * @returns {string}
   */
  function getFinalType(typeName) {
    let visited = createVisited(typeName);
    let type = model.definitions[typeName];
    while (type && type.type) {
      typeName = type.type;
      visited.check(typeName);
      type = model.definitions[typeName];
    }
    return typeName;
  }

  // Return true if 'node' is a managed association element
  // TODO: what about elements having a type, which (finally) is an assoc?
  function isManagedAssociation(node) {
    return node.target !== undefined && node.on === undefined && node.keys;
  }

  /**
   * Returns if a type is an association or a composition or a typedef
   * to any of them.
   * @param {string} typeName Absolute type name
   */
  function isAssocOrComposition(typeName) {
    if (typeName === 'cds.Association' || typeName === 'cds.Composition')
      return true;
    let visited = createVisited(typeName);
    let type = model.definitions[typeName];
    while (type) {
      if (type.type === 'cds.Association' || type.type === 'cds.Composition')
        return true;
      visited.check(type.type);
      type = model.definitions[type.type];
    }
    return false;
  }

  /**
   * Returns if a type is an association or a typedef to it.
   * @param {string} typeName Absolute type name
   */
  function isAssociation(typeName) {
    if (typeName === 'cds.Association')
      return true;
    let visited = createVisited(typeName);
    let type = model.definitions[typeName];
    while (type) {
      if (type.type === 'cds.Association')
        return true;
      visited.check(type.type);
      type = model.definitions[type.type];
    }
    return false;
  }

  /**
   * Returns if a type is an composition or a typedef to it.
   * @param {string} typeName Absolute type name
   */
  function isComposition(typeName) {
    if (typeName === 'cds.Composition')
      return true;
    let visited = createVisited(typeName);
    let type = model.definitions[typeName];
    while (type) {
      if (type.type === 'cds.Composition')
        return true;
      visited.check(type.type);
      type = model.definitions[type.type];
    }
    return false;
  }

  /**
   * Return the namespace part of the artifact name.
   * @param {string} name Absolute name of artifact
   */
  function getNamespaceOfArtifact(name) {
    let lastDotIdx = name.lastIndexOf('.');
    if (lastDotIdx === -1) return undefined;
    while (model.definitions[name]) {
      if (model.definitions[name].kind === 'namespace')
        return name;
      lastDotIdx = name.lastIndexOf('.');
      if (lastDotIdx === -1) return undefined;
      name = name.substring(0, lastDotIdx);
    }
    return name;
  }

  /**
   * Return the context part of the artifact name if any.
   * @param {string} name Absolute name of artifact
   */
  function getContextOfArtifact(name) {
    let lastDotIdx = name.lastIndexOf('.');
    while (model.definitions[name]) {
      if (model.definitions[name].kind === 'context' || model.definitions[name].kind === 'service')
        return name;
      lastDotIdx = name.lastIndexOf('.');
      if (lastDotIdx === -1) return undefined;
      name = name.substring(0, lastDotIdx);
    }
    return undefined;
  }

  /**
   * Add an annotation with absolute name 'absoluteName' (including the at-sign) and string value 'theValue' to 'node'
   *
   * @param {string} absoluteName Name of the annotation, including the at-sign
   * @param {any} theValue string value of the annotation
   * @param {any} node Node to add the annotation to
   */
  function addStringAnnotationTo(absoluteName, theValue, node) {
    // Sanity check
    if (!absoluteName.startsWith('@')) {
      throw Error('Annotation name should start with "@": ' + absoluteName);
    }
    // Only overwrite if undefined or null
    if(node[absoluteName] === undefined || node[absoluteName] === null) {
      // Assemble the annotation
      node[absoluteName] = theValue;
    }
  }

  /**
   * Return the name of the service in which the artifact is contained.
   * Returns null if the artifact doesn't live in a service.
   *
   * @param {string} artifactName Absolute name of artifact
   * @returns {string|null}
   */
  function getServiceName(artifactName) {
    for(;;) {
      let idx = artifactName.lastIndexOf('.');
      if (idx === -1) return null;
      artifactName = artifactName.substring(0, idx);
      let artifact = model.definitions[artifactName];
      if (artifact && artifact.kind === 'service') {
        return artifactName;
      }
    }
  }

  /**
   * Clone 'node', transforming nodes therein recursively. Object 'transformers' is expected
   * to contain a mapping of property 'key' names to transformer functions. The node's properties
   * are walked recursively, calling each transformer function on its corresponding property
   * 'key' of 'node', replacing 'value' in 'resultNode' with the function's return value
   * (returning 'undefined' will delete the property).
   * If no transformation function is found for 'key', the first letter of 'key' is tried
   * instead (this seems to be intended for handling annotations that start with '@' ?)
   *
   * Regardless of their names, transformers are never applied to dictionary elements.
   *
   * The transformer functions are called with the following signature:
   * transformer(value, node, resultNode, key)
   *
   * @param {any} rootNode Node to transform
   * @param {any} transformers Object defining transformer functions
   * @returns {object}
   */
  function cloneWithTransformations(rootNode, transformers) {

    return transformNode(rootNode);

  // This general transformation function will be applied to each node recursively
    function transformNode(node) {
    // Return primitive values and null unchanged, but let objects and dictionaries through
    // (Note that 'node instanceof Object' would be false for dictionaries).
      if (node === null || typeof node !== 'object') {
        return node
      }
    // Simply return if node is to be ignored
      if (node == undefined || node._ignore)
        return undefined;
    // Transform arrays element-wise
      if (Array.isArray(node)) {
        return node.map(transformNode);
      }
    // Things not having 'proto' are dictionaries
      let proto = Object.getPrototypeOf(node);
    // Iterate own properties of 'node' and transform them into 'resultNode'
      let resultNode = Object.create(proto);
      for (let key of Object.keys(node)) {
      // Dictionary always use transformNode(), other objects their transformer according to key
        let transformer = (proto == undefined) ? transformNode : transformers[key] || transformers[key.charAt(0)];
      // Apply transformer, or use transformNode() if there is none
        let resultValue = (transformer || transformNode)(node[key], node, resultNode, key);
        if (resultValue !== undefined) {
          resultNode[key] = resultValue;
        }
      }
      return resultNode;
    }
  }


  /**
   * Resolve to the final type of a type, that means follow type chains, references to other types or
   * elements a.s.o
   * Works for all kinds of types, strings as well as type objects. Strings need to be absolute type names.
   * Returns the final type as string (if it has a name, which is not always the case, think of embedded structures),
   * else the type object itself is returned. If a type is structured, you can navigate into it by providing a path,
   * e.g. given the following model
   *     type bar: S.foo;
   *     type s1 {
   *       s: s2;
   *     };
   *     type s2 {
   *       u: type of S.e:t;
   *     }
   *     service S {
   *       type foo: type of S.e:i.j1;
   *       entity e {
   *         key i: { j1: Integer };
   *         t: bar;
   *         v: s1;
   *         x: blutz.s.u;
   *       };
   *       type blutz: S.e.v;
   *       view V as select from e {
   *         1+1 as i: bar,
   *       };
   *       type tt: type of V:i;
   *    }
   * the following calls will all return 'cds.Integer'
   *     getFinalBaseType('S.tt')
   *     getFinalBaseType('S.e',['i','j1'])
   *     getFinalBaseType('S.e',['t'])
   *     getFinalBaseType('S.e',['x'])
   *     getFinalBaseType('S.blutz',['s', 'u'])
   * Types are always resolved as far as possible. A type name which has no further definition is simply returned.
   * Composed types (structures, entities, views, ...) are returned as type objects, if not drilled down into
   * the elements. Path steps that have no corresponding element lead to 'undefined'. Refs to something that has
   * no type (e.g. expr in a view without explicit type) returns 'null'
   *
   * @param {string|object} type Type - either string or ref
   * @param {CSN.Path} path
   * @param {WeakMap} [resolved=new WeakMap()] WeakMap containing already resolved refs - if a ref is not cached, it will be resolved JIT
   * @param {object} [cycleCheck] Dictionary to remember already resolved types - to be cycle-safe
   * @returns
   */
  function getFinalBaseType(type, path = [], resolved = new WeakMap(), cycleCheck = undefined) {
    if (!type)
      return type;
    if (typeof(type) === 'string') {
      if (isBuiltinType(type)) // built-in type
        return type;
      if (cycleCheck) {
        let visited = path.length? type + ':' + path.join('.') : type;
        if (cycleCheck[visited])
          throw new ModelError('Circular type chain on type ' + type);
        else
          cycleCheck[visited] = true;
      }
      else {
        cycleCheck = Object.create(null);
      }
      let definedType = model.definitions[type];
      if (definedType && definedType.type)
        return getFinalBaseType(definedType.type, path, resolved, cycleCheck);
      else
        return getFinalBaseType(definedType, path, resolved, cycleCheck);
    }
    else if (typeof(type) === 'object') {
      if (type.ref) {
        // assert type.ref instanceof Array && type.ref.length >= 1
        const ref = resolved.has(type) ? resolved.get(type).art : artifactRef(type);
        return getFinalBaseType(ref, path, resolved, cycleCheck);
      }
      else if (type.elements) {
        if (path.length) {
          let [e, ...p] = path;
          return getFinalBaseType(type.elements[e], p, resolved, cycleCheck);
        }
      }
      else if (type.type)
        return (getFinalBaseType(type.type, path, resolved, cycleCheck));
      else if (type.items)
        return type;
      else
        // TODO: this happens if we don't have a type, e.g. an expression in a select list
        // in a view without explicit type. Instead of returning null we might want to return
        // the object instead?
        return null;
    }
    return type;
  }
}

/**
 * Deeply clone the given CSN model and return it.
 * In testMode (or with testSortCsn), definitions are sorted.
 * Note that annotations are only copied shallowly.
 *
 * @param {object} csn Top-level CSN.  You can pass non-dictionary values.
 * @param {CSN.Options} options CSN Options, only used for `dictionaryPrototype`, `testMode`, and `testSortCsn`
 */
function cloneCsnNonDict(csn, options) {
  return sortCsn(csn, options);
}

/**
 * Deeply clone the given CSN dictionary and return it.
 * Note that annotations are only copied shallowly.
 * This function does _not_ sort the given dictionary.
 * See cloneCsnNonDict() if you want sorted definitions.
 *
 * @param {object} csn
 * @param {CSN.Options} options Only cloneOptions.dictionaryPrototype is
 *                              used and cloneOptions are passed to sort().
 */
function cloneCsnDictionary(csn, options) {
  return _cloneCsnDictionary(csn, options);
}

/**
 * Apply function `callback` to all artifacts in dictionary
 * `model.definitions`.  See function `forEachGeneric` for details.
 * Callback will be called with artifact, artifact name, property
 * name ('definitions') and csn-path to artifact.
 *
 * @param {CSN.Model} csn
 * @param {(genericCallback|genericCallback[])} callback
 * @param {object} iterateOptions can be used to skip certain kinds from being iterated
 */
function forEachDefinition( csn, callback, iterateOptions = {} ) {
  forEachGeneric( csn, 'definitions', callback, [], iterateOptions );
}

/**
 * Apply function `callback` to all members of object `construct` (main artifact or
 * parent member).  Members are considered those in dictionaries `elements`,
 * `enum`, `actions` and `params` of `construct`, `elements` and `enums` are also
 * searched inside property `items` (array of) and `returns` (actions).
 * See function `forEachGeneric` for details.
 *
 * @param {CSN.Artifact} construct
 * @param {genericCallback|genericCallback[]} callback
 * @param {CSN.Path} [path]
 * @param {boolean} [ignoreIgnore]
 * @param {object} iterateOptions can be used to skip certain kinds from being iterated
 * @param constructCallback
 */
function forEachMember( construct, callback, path=[], ignoreIgnore=true, iterateOptions = {},
                        constructCallback = (_construct, _prop, _path) => {}) {
  // Allow processing _ignored elements if requested
  if (ignoreIgnore && construct._ignore) {
    return;
  }

  // `items` itself is a structure that can contain "elements", and more.
  if (construct.items) {
    forEachMember( construct.items, callback, [...path, 'items'], ignoreIgnore, iterateOptions, constructCallback );
  }

  // Unlike XSN, we don't make "returns" a "params" in the callback.
  // Backends rely on the fact that `forEachElement` also goes through all
  // `elements` of the return type (if structured).
  // TODO: `returns` should be handled like a parameter just like XSN (maybe with different prop name)
  if (construct.returns && !iterateOptions.elementsOnly) {
    forEachMember( construct.returns, callback, [...path, 'returns'], ignoreIgnore, iterateOptions, constructCallback );
  }

  path = [...path]; // Copy
  const propsWithMembers = (iterateOptions.elementsOnly ? ['elements'] : ['elements', 'enum', 'actions', 'params']);
  propsWithMembers.forEach((prop) => {
    forEachGeneric( construct, prop, callback, path, iterateOptions );
    if (construct[prop]) {
      if (Array.isArray(constructCallback))
        constructCallback.forEach(cb => cb(construct, prop, path));
      else
        constructCallback(construct, prop, path);
    }
  });
}

/**
 * Call `forEachMember` and then apply `forEachMember` on queries.
 *
 * @param {CSN.Artifact} construct
 * @param {genericCallback|genericCallback[]} callback
 * @param {CSN.Path} [path]
 * @param {boolean} [ignoreIgnore]
 * @param {object} iterateOptions can be used to skip certain kinds from being iterated
 * @param {constructCallback|constructCallback[]} callback
 */
function forEachMemberWithQuery( construct, callback, path=[], ignoreIgnore=true, iterateOptions = {},
  constructCallback = (_construct, _prop, _path) => {}) {
  forEachMember(construct, callback, path, ignoreIgnore, iterateOptions, constructCallback);
  if (construct.query) {
    forAllQueries(construct.query, (q, p) => {
      const s = q.SELECT;
      if(s) {
        forEachMember(s, callback, p, ignoreIgnore, iterateOptions);
      }
    }, [ ...path, 'query' ]);
  }
}

/**
 * Apply function `callback(member, memberName)` to each member in `construct`,
 * recursively (i.e. also for sub-elements of elements).
 *
 * @param {CSN.Artifact} construct
 * @param {genericCallback|genericCallback[]} callback
 * @param {CSN.Path} [path]
 * @param {boolean} [ignoreIgnore]
 * @param {object} iterateOptions can be used to skip certain kinds from being iterated
 * @param {constructCallback|constructCallback[]} callback
 */
function forEachMemberRecursively( construct, callback, path=[], ignoreIgnore=true, iterateOptions = {},
                                   constructCallback = (_construct, _prop, _path) => {}) {
  forEachMember( construct, ( member, memberName, prop, subpath, parent ) => {
    if(Array.isArray(callback))
      callback.forEach(cb => cb( member, memberName, prop, subpath, parent ));
    else
      callback( member, memberName, prop, subpath, parent );
    // Descend into nested members, too
    forEachMemberRecursively( member, callback, subpath, ignoreIgnore, iterateOptions, constructCallback);
  }, path, ignoreIgnore, iterateOptions, constructCallback);
}

/**
 * Apply function `callback(member, memberName)` to each member in `construct`,
 * recursively (i.e. also for sub-elements of elements).
 * Recursively iterate over elements of `construct` query.
 *
 * @param {CSN.Artifact} construct
 * @param {genericCallback|genericCallback[]} callback
 * @param {CSN.Path} [path]
 * @param {boolean} [ignoreIgnore]
 * @param {object} iterateOptions can be used to skip certain kinds from being iterated
 * @param {constructCallback|constructCallback[]} callback
 */
function forEachMemberRecursivelyWithQuery( construct, callback, path=[], ignoreIgnore=true, iterateOptions = {},
                                              constructCallback = (_construct, _prop, _path) => {}) {
  forEachMemberRecursively(construct, callback, path, ignoreIgnore, iterateOptions, constructCallback);
  if(construct.query) {
    forAllQueries(construct.query, (q, p) => {
      const s = q.SELECT;
      if(s) {
        forEachMemberRecursively(s, callback, p, ignoreIgnore, iterateOptions);
      }
    }, [ ...path, 'query' ]);
  }
}

/**
 * Apply function `callback` to all objects in dictionary `dict`, including all
 * duplicates (found under the same name).  Function `callback` is called with
 * the following arguments: the object, the name, and -if it is a duplicate-
 * the array index and the array containing all duplicates.
 *
 * @param {object} construct
 * @param {string} prop
 * @param {genericCallback|genericCallback[]} callback
 * @param {CSN.Path} path
 * @param {object} iterateOptions can be used to skip certain kinds from being iterated
 */
function forEachGeneric( construct, prop, callback, path = [], iterateOptions = {}) {
  const dict = construct[prop];
  for (const name in dict) {
    if (!Object.prototype.hasOwnProperty.call(dict, name))
      continue;
    const dictObj = dict[name];
    if((iterateOptions.skip && iterateOptions.skip.includes(dictObj.kind))
       || (iterateOptions.skipArtifact && typeof iterateOptions.skipArtifact === 'function'
           && iterateOptions.skipArtifact(dictObj, name)))
      continue;
    executeCallbacks( dictObj, name );
  }
  function executeCallbacks(o, name ) {
    if (Array.isArray(callback))
      callback.forEach(cb => cb( o, name, prop, path.concat([prop, name]), construct ));
    else
      callback( o, name, prop, path.concat([prop, name]), construct )
  }
}

// Like Object.assign() but copies also non enumerable properties
function assignAll(target, ...sources) {
  sources.forEach(source => {
    const descriptors = Object.getOwnPropertyNames(source).reduce((propertyDescriptors, current) => {
      propertyDescriptors[current] = Object.getOwnPropertyDescriptor(source, current);
      return propertyDescriptors;
    }, {});
    // by default, Object.assign copies enumerable Symbols too
    Object.getOwnPropertySymbols(source).forEach(sym => {
      const descriptor = Object.getOwnPropertyDescriptor(source, sym);
      if (descriptor.enumerable) {
        descriptors[sym] = descriptor;
      }
    });
    Object.defineProperties(target, descriptors);
  });
  return target;
}

/**
 * @param {CSN.Query} mainQuery
 * @param {queryCallback|queryCallback[]} queryCallback
 * @param {CSN.Path} path
 */
function forAllQueries(mainQuery, queryCallback, path = []){
  return traverseQuery(mainQuery, queryCallback, path);
  function traverseQuery( query, callback, queryPath ) {
    if (query.SELECT) {
      // The projection is turned into a normalized query - there
      // is no real SELECT, it is fake
      if(!(path.length === 3 && path[2] === 'projection'))
        queryPath.push('SELECT');
      executeCallbacks();
      query = query.SELECT;
    }
    else if (query.SET) {
      queryPath.push('SET');
      executeCallbacks();
      query = query.SET;
    }

    if (query.from)
      traverseFrom( query.from, callback, queryPath.concat(['from']) );

    for (const prop of ['args', 'xpr', 'columns', 'where', 'having']) {
      // all properties which could have sub queries (directly or indirectly)
      const expr = query[prop];
      if (expr && typeof expr === 'object') {
        if(Array.isArray(expr)){
          for(let i = 0; i < expr.length; i++){
            traverseQuery(expr[i], callback, queryPath.concat([prop, i]));
          }
        } else {
          for(const argName of Object.keys( expr )){
            traverseQuery(expr[argName], callback, queryPath.concat([prop, argName]))
          }
        }
      }
    }
    function executeCallbacks() {
      if(Array.isArray(callback))
        callback.forEach(cb => cb( query, queryPath ));
      else
        callback( query, queryPath );
    }
  }

  /**
   * @param {CSN.QueryFrom} from
   * @param {Function} callback
   * @param {CSN.Path} csnPath
   */
  function traverseFrom( from, callback, csnPath = [] ) {
    if (from.ref) // ignore
      return;
    else if (from.args){ // join
      for(let i = 0; i < from.args.length; i++){
        traverseFrom(from.args[i], callback, csnPath.concat(['args', i]));
      }
    }
    else
      traverseQuery( from, callback, csnPath ); // sub query in FROM
  }
}

/**
 * Compare a given annotation value with an expectation value and return
 *
 *          | Expected
 *          | true  | false | null  | arb val
 * Anno Val |-------|-------|-------|--------
 * true     | true  | false | false | false
 * false    | false | true  | false | false
 * null     | false | true  | true  | false
 * arb val  | false | false | false | true/false
 *
 * If the annotation value is 'null', 'true' is returned for the expectation values
 * 'null' and 'false'. Expecting 'null' for an annotation value 'false' returns
 * 'false'.
 *
 * @param {CSN.Artifact} artifact
 * @param {string} annotationName Name of the annotation (including the at-sign)
 * @param {any} expected
 * @param {boolean} caseInsensitive
 * @returns {boolean}
 */
function hasAnnotationValue(artifact, annotationName, expected = true, caseInsensitive = false) {
  if(expected === false)
    return artifact[annotationName] === expected || artifact[annotationName] === null;
  else if (typeof artifact[annotationName] === 'string' && caseInsensitive === true)
    return artifact[annotationName].toLowerCase() === expected.toLowerCase();
  else
    return artifact[annotationName] === expected;
}

/**
 * EDM specific check: Render (navigation) property if element is NOT ...
 * 1) ... annotated @cds.api.ignore
 * 2) ... annotated @odata.navigable: false
 * 2) ... annotated @odata.foreignKey4 and odataFormat: structured
 * function accepts EDM internal and external options
 *
 * @param {CSN.Element} elementCsn
 * @param {ODataOptions} options EDM specific options
 */
function isEdmPropertyRendered(elementCsn, options) {
  if(options.toOdata)
    options = options.toOdata;
  // FKs are rendered in
  // V2/V4 flat: always on
  // V4 struct: on/off
  const renderForeignKey = (options.version === 'v4' && options.odataFormat === 'structured') ? !!options.odataForeignKeys : true;
  const isNotIgnored = !elementCsn.target ? !elementCsn['@cds.api.ignore'] : true;
  const isNavigable = elementCsn.target ?
    (elementCsn['@odata.navigable'] === undefined ||
     elementCsn['@odata.navigable'] !== undefined && (elementCsn['@odata.navigable'] === null || elementCsn['@odata.navigable'] === true)) : true;
  // Foreign Keys can be ignored
  if(elementCsn['@odata.foreignKey4'])
    return isNotIgnored && renderForeignKey;
  // ordinary elements can be ignored and isNavigable is always true for them
  // assocs cannot be ignored but not navigable
  return isNotIgnored && isNavigable;
}


/**
 * Return the resulting database name for (absolute) 'artifactName', depending on the current naming
 * mode.
 *
 * - For the 'hdbcds' naming mode, this means converting '.' to '::' on
 *   the border between namespace and top-level artifact and correctly replacing some '.' with '_'.
 * - For the 'plain' naming mode, it means converting all '.' to '_' and upper-casing.
 * - For the 'quoted' naming mode, this means correctly replacing some '.' with '_'.
 *
 * If the old function signature is used - with a namespace as the third argument - the result might be wrong,
 * since the '.' -> '_' conversion for quoted/hdbcds is missing.
 *
 * @param {string} artifactName The fully qualified name of the artifact
 * @param {('plain'|'quoted'|'hdbcds')} sqlMapping The naming mode to use
 * @param {CSN.Model|string|undefined} csn
 * @returns {string} The resulting database name for (absolute) 'artifactName', depending on the current naming mode.
 */
function getArtifactDatabaseNameOf(artifactName, sqlMapping, csn) {
  if(csn && typeof csn === 'object' && csn.definitions)
    if (sqlMapping === 'quoted' || sqlMapping === 'hdbcds') {
      return getResultingName(csn, sqlMapping, artifactName);
    }
    else if (sqlMapping === 'plain') {
      return artifactName.replace(/\./g, '_').toUpperCase();
    } else {
      throw new Error('Unknown naming mode: ' + sqlMapping);
    }
  else {
    console.error(`This invocation of "getArtifactCdsPersistenceName" is deprecated, as it doesn't produce correct output with definition names containing dots - please provide a CSN as the third parameter.`);
    if (sqlMapping === 'hdbcds') {
      if (csn) {
        const namespace = String(csn);
        return `${namespace}::${artifactName.substring(namespace.length + 1)}`;
      }
      return artifactName;
    }
    else if (sqlMapping === 'plain') {
      return artifactName.replace(/\./g, '_').toUpperCase();
    }
    else if (sqlMapping === 'quoted') {
      return artifactName;
    }
    else {
      throw new Error('Unknown naming mode: ' + sqlMapping);
    }
  }
}

/**
 * Get the name that the artifact definition has been rendered as - except for plain, there we just return the name as-is.
 * Without quoting/escaping stuff.
 *
 * Example: namespace.context.entity.with.dot
 * - plain: namespace.context.entity.with.dot
 * - quoted: namespace.context.entity_with_dot
 * - hdbcds: namespace::context.entity_with_dot
 *
 * @param {CSN.Model} csn CSN model
 * @param {string} namingMode Naming mode to use
 * @param {string} artifactName Artifact name to use
 * @returns {string} The resulting name
 */
function getResultingName(csn, namingMode, artifactName) {
  if (namingMode === 'plain' || artifactName.indexOf('.') === -1)
    return artifactName;

  const namespace = getNamespace(csn, artifactName);

  // Walk from front to back until we find a non-namespace/context
  // and join everything we've seen until that point with ., the rest
  // with _ (and the namespace with :: for hdbcds naming)
  const stopIndex = namespace ? namespace.split('.').length : 0;

  const parts = artifactName.split('.');

  const realParts = getUnderscoredName(stopIndex, parts, csn);
  const name = realParts ? realParts.join('.') : artifactName;


  return (namespace && namingMode === 'hdbcds') ? `${namespace}::${name.slice(namespace.length + 1)}` : name;
}


/**
 * Get the suffix and prefix part - with '.' join for prefix, '_' for suffix.
 * We determine when to start using '_' by walking from front to back until we find
 * the first shadowing definition that is not a namespace, context or service.
 *
 * Anything following is joined by '_'.
 *
 *
 * @param {number} startIndex Index to start looking at the parts - used to skip the namespace
 * @param {string[]} parts Parts of the name, split at .
 * @param {CSN.Model} csn
 * @returns {string[]|null} Array of at most 2 strings: if both: [prefix, suffix], otherwise just one - or null
 */
function getUnderscoredName(startIndex, parts, csn) {
  for (let i = startIndex; i < parts.length; i++) {
    const namePart = parts.slice(0, i).join('.');
    const art = csn.definitions[namePart];
    if (art && !(art.kind === 'namespace' || art.kind === 'context' || art.kind === 'service')) {
      const prefix = parts.slice(0, i - 1).join('.');
      const suffix = parts.slice(i - 1).join('_');
      const result = [];
      if (prefix)
        result.push(prefix);
      if (suffix)
        result.push(suffix);

      return result;
    } else if(art && art.kind === 'service') {
      // inside services, we immediately turn . into _
      const prefix = parts.slice(0, i).join('.');
      const suffix = parts.slice(i).join('_');
      const result = [];
      if (prefix)
        result.push(prefix);
      if (suffix)
        result.push(suffix);

      return result;
    }
  }

  return null;
}


/**
 *  Return the resulting database element name for 'elemName', depending on the current
 *  naming mode.
 *  - For the 'hdbcds' naming mode, this is just 'elemName'.
 *  - For the 'plain' naming mode, it means converting all '.' to '_' and upper-casing.
 *  - For the 'quoted' naming mode, it means converting all '.' to '_'.
 *  No other naming modes are accepted!
 *
 * @param {string} elemName The name of the element
 * @param {('plain'|'quoted'|'hdbcds')} sqlMapping The naming mode to use
 * @returns {string} The resulting database element name for 'elemName', depending on the current naming mode.
 */
function getElementDatabaseNameOf(elemName, sqlMapping) {
  if (sqlMapping === 'hdbcds') {
    return elemName;
  }
  else if (sqlMapping === 'plain') {
    return elemName.replace(/\./g, '_').toUpperCase();
  }
  else if (sqlMapping === 'quoted') {
    return elemName.replace(/\./g, '_');
  }
  else {
    throw new Error('Unknown naming mode: ' + sqlMapping);
  }
}

const _dependencies = Symbol('_dependencies');
const _dependents = Symbol('_dependents');

/**
 * Calculate the hard dependencies between artifacts (as needed to ensure the correct view order).
 * Only works on A2Jed HANA CSN!
 *
 * _dependents: All artifacts that depend on this artifact (because they have a ref that points to it)
 * _dependencies: All artifacts this artifact depends on (because it has a ref to it)
 *
 * @param {object} csn A CSN to enrich in-place
 * @returns {object} CSN with _dependents/_dependencies set, "cleanup" function, _dependents/_dependencies Symbol used
 */
function setDependencies( csn ) {
  const cleanup = [];
  const { artifactRef } = csnRefs(csn);

  forEachDefinition(csn, (artifact, artifactName) => {
    if(getNormalizedQuery(artifact).query) {
      initDependencies(artifact);
      forAllQueries(getNormalizedQuery(artifact).query, (query) => {
        if(query.SELECT && query.SELECT.from) {
          if(query.SELECT.from.args) {
            handleArgs(artifact, artifactName, query.SELECT.from.args);
          } else {
            if(typeof query.SELECT.from === 'string' || query.SELECT.from.ref )
              handleDependency(artifactRef(query.SELECT.from), artifact, artifactName);
          }
        }
      },  ['definitions', artifactName, (artifact.projection ? 'projection' : 'query')])
    }
  })

  return {cleanup, csn, _dependents, _dependencies};

  function handleArgs(artifact, artifactName, args){
    for(let arg of args){
      if (arg.args) {
        handleArgs(artifact, artifactName, arg.args);
      } else if (arg.ref) {
        handleDependency(artifactRef(arg), artifact, artifactName)
      }
    }
  }

  function handleDependency(dependency, dependant, dependantName) {
    dependant[_dependencies].add(dependency);
    initDependents(dependency);
    dependency[_dependents][dependantName] = dependant;
  }

  function initDependents(obj){
    if(!obj[_dependents]) {
      obj[_dependents] = Object.create(null);
      cleanup.push(() => delete obj[_dependents]);
    }
  }

  function initDependencies(obj){
    if(!obj[_dependencies]) {
      obj[_dependencies] = new Set();
      cleanup.push(() => delete obj[_dependencies]);
    }
  }
}

/**
 * If the artifact is either abstract or assigned '@cds.persistence.skip' it
 * never reaches the Database layer.
 *
 * @param {CSN.Artifact} art
 * @returns {boolean}
 */
function isPersistedOnDatabase(art) {
  return !('entity' === art.kind && (art.abstract || hasAnnotationValue(art, '@cds.persistence.skip')));
}

/**
 * Central generated by cds-compiler string generator function without further decoration
 *  for unified tagging of generated content
 *
 * @returns {string} String containing compiler version that was used to generate content
 */
function generatedByCompilerVersion() {
  return `generated by cds-compiler version ${version}`;
}

/**
 * Return the projection to look like a query.
 *
 * @param {CSN.Artifact} art Artifact with a query or a projection
 * @returns {object} Object with a query property.
 */
function getNormalizedQuery(art) {
  if (art.projection) {
    return { query: { SELECT: art.projection } };
  }
  return art;
}

/**
 * Merge multiple 'options' objects (from right to left, i.e. rightmost wins). Structured option values are
 * merged deeply. Structured option value from the right may override corresponding bool options on the left,
 * but no other combination of struct/scalar values is allowed. Array options are not merged, i.e. their
 * content is treated like scalars.
 * Returns a new options object.
 *
 * @param {...CSN.Options} optionsObjects
 * @return {CSN.Options}
 */
function mergeOptions(...optionsObjects) {
  let result = {};
  for (const options of optionsObjects) {
    if (options)
      result = mergeTwo(result, options, 'options');
  }

  // Reverse the array to ensure that the rightmost option has priority
  const reversedOptions = [...optionsObjects].reverse(); // de-structure and create a new array, so reverse doesn't impact optionsObject
  const msgOptions = reversedOptions.find(opt => opt && Array.isArray(opt.messages));
  if (msgOptions) {
    result.messages = msgOptions.messages;
  }

  return result;

  // Recursively used for scalars, too
  function mergeTwo(left, right, name) {
    let intermediateResult;
    // Copy left as far as required
    if (Array.isArray(left)) {
      // Shallow-copy left array
      intermediateResult = left.slice();
    } else if (isObject(left)) {
      // Deep-copy left object (unless empty)
      intermediateResult = Object.keys(left).length ? mergeTwo({}, left, name) : {};
    } else {
      // Just use left scalar
      intermediateResult = left;
    }
    // Check against improper overwriting
    if (isObject(left) && !Array.isArray(left) && (Array.isArray(right) || isScalar(right))) {
      throw new ModelError(`Cannot overwrite structured option "${name}" with array or scalar value`);
    }
    if ((isScalar(left) && typeof left !== 'boolean' || Array.isArray(left)) && isObject(right) && !Array.isArray(right)) {
      throw new ModelError(`Cannot overwrite non-boolean scalar or array option "${name}" with structured value`);
    }

    // Copy or overwrite properties from right to left
    if (Array.isArray(right)) {
      // Shallow-copy right array
      intermediateResult = right.slice();
    } else if (isObject(right)) {
      // Object overwrites undefined, scalars and arrays
      if (intermediateResult === undefined || isScalar(intermediateResult) || Array.isArray(intermediateResult)) {
        intermediateResult = {};
      }
      // Deep-copy right object into result
      for (let key of Object.keys(right)) {
        intermediateResult[key] = mergeTwo(intermediateResult[key], right[key], `${name}.${key}`);
      }
    } else {
      // Right scalar wins (unless undefined)
      intermediateResult = (right !== undefined) ? right : intermediateResult;
    }
    return intermediateResult;
  }

  // Return true if 'o' is a non-null object or array
  function isObject(o) {
    return typeof o === 'object' && o !== null
  }

  // Return true if 'o' is a non-undefined scalar
  function isScalar(o) {
    return o !== undefined && !isObject(o);
  }
}

/**
* If the artifact with the name given is part of a context (or multiple), return the top-most context.
* Else, return the artifact itself. Namespaces are not of concern here.
*
* @param {string} artifactName Name of the artifact
* @param {CSN.Model} csn
* @returns {string} Name of the root
*/
function getRootArtifactName(artifactName, csn) {
  const parts = artifactName.split('.');

  if (parts.length === 1)
    return artifactName;

  let seen = getNamespace(csn, artifactName) || '';
  const startIndex = (seen === '') ? 0 : seen.split('.').length;
  for (let i = startIndex; i < parts.length; i++) {
    if (seen === '')
      seen = parts[i];
    else
        seen = `${seen}.${parts[i]}`;

    const art = csn.definitions[seen];
      // Our artifact seems to be contained in this context
    if (art && (art.kind === 'context' || art.kind === 'service'))
      return seen;
  }
    // Our artifact is a root artifact itself
  return seen;
}

// Return the last part of 'name'.
// Examples:
//   'foo.bar.wiz' => 'wiz'
//   'foo' => 'foo';
//   'foo::bar' => 'bar'
function getLastPartOf(name) {
  return name.substring(name.search(/[^.:]+$/));
}

// Return the last part of reference array 'ref'
// Examples:
//   ['foo.bar', 'wiz'] => 'wiz'
//   ['foo.bar.wiz'] => 'wiz'
//   ['foo'] => 'foo';
//   ['foo::bar'] => 'bar'
function getLastPartOfRef(ref) {
  let lastPathStep = ref[ref.length - 1];
  return getLastPartOf(lastPathStep.id || lastPathStep);
}

// Return the name of the parent artifact of the artifact 'name' or
// '' if there is no parent.
function getParentNameOf(name) {
  return name.substring(0, name.lastIndexOf('.'));
}

// Return an array of parent names of 'name' (recursing into grand-parents)
// Examples:
//   'foo.bar.wiz' => [ 'foo.bar', 'foo' ]
//   'foo' => []
//   'foo::bar.wiz' => 'foo::bar'
//   'foo::bar' => []
function getParentNamesOf(name) {
  let remainder = name.slice(0, -getLastPartOf(name).length);
  if (remainder.endsWith('.')) {
    let parentName = remainder.slice(0, -1);
    return [parentName, ...getParentNamesOf(parentName)];
  } else {
    return [];
  }
}


/**
 * Copy all annotations from 'fromNode' to 'toNode'.
 *
 * Overwrite existing ones only if 'overwrite' is true.
 *
 * @param {object} fromNode
 * @param {object} toNode
 * @param {boolean} [overwrite]
 */
function copyAnnotations(fromNode, toNode, overwrite = false) {
  // Ignore if no toNode (in case of errors)
  if (!toNode)
    return;

  const annotations = Object.keys(fromNode).filter(key => key.startsWith('@'));

  for (const anno of annotations) {
    if (toNode[anno] === undefined || overwrite) {
      toNode[anno] = fromNode[anno];
    }
  }
}


/**
 * Same as `copyAnnotations()` but also copies the
 * annotation-like property `doc`.
 *
 * Overwrite existing ones only if 'overwrite' is true.
 *
 * @param {object} fromNode
 * @param {object} toNode
 * @param {boolean} [overwrite]
 */
function copyAnnotationsAndDoc(fromNode, toNode, overwrite = false) {
  // Ignore if no toNode (in case of errors)
  if (!toNode)
    return;

  const annotations = Object.keys(fromNode)
    .filter(key => key.startsWith('@') || key === 'doc');

  for (const anno of annotations) {
    if (toNode[anno] === undefined || overwrite) {
      toNode[anno] = fromNode[anno];
    }
  }
}

/**
 * Applies annotations from `csn.extensions` to definitions, i.e. top-level artifacts.
 * Does _not_ apply element/param/action/... annotations.
 * `config.filter` can be used to only copy annotations for those definitions,
 * for which the filter returns true.
 *
 * @param {CSN.Model} csn
 * @param {{overwrite?: boolean, filter?: (name: string) => boolean}} config
 */
function applyDefinitionAnnotationsFromExtensions(csn, config) {
  if (!csn.extensions)
    return;

  const filter = config.filter || ((_name) => true);
  for (const ext of csn.extensions) {
    const name = ext.annotate || ext.extend;
    if (name && csn.definitions[name] && filter(name)) {
      copyAnnotationsAndDoc(ext, csn.definitions[name], config.overwrite);
    }
  }
}

function isAspect(node) {
  return node && node.kind === 'aspect';
}

// For each property named 'path' in 'node' (recursively), call callback(path, node)
function forEachPath(node, callback) {
  if (node === null || typeof node !== 'object') {
    // Primitive node
    return;
  }
  for (let name in node) {
    if (!Object.hasOwnProperty.call( node, name ))
      continue;
    // If path found within a non-dictionary, call callback
    if (name === 'path' && Object.getPrototypeOf(node)) {
      callback(node.path, node);
    }
    // Descend recursively
    forEachPath(node[name], callback);
  }
}


/**
 * Return true if the artifact has a valid, truthy persistence.exists/skip annotation
 *
 * @param {CSN.Artifact} artifact
 * @returns {boolean}
 */
function hasValidSkipOrExists(artifact) {
  return artifact.kind === 'entity' &&
         (hasAnnotationValue(artifact, '@cds.persistence.exists', true) || hasAnnotationValue(artifact, '@cds.persistence.skip', true))

}

/**
 * Get the namespace part of the artifact name - not the whole prefix, just the part caused by namespaces.
 *
 * @param {CSN.Model} csn CSN model
 * @param {string} artifactName artifact name to get the namespace for
 * @returns {string | null} The namespace name
 */
function getNamespace(csn, artifactName) {
  const parts = artifactName.split('.');
  let seen = parts[0];
  const art = csn.definitions[seen];

  // First step is not a namespace (we faked those in the CSN)
  // No subsequent step can be a namespace then
  if (art && art.kind !== 'namespace')
    return null;


  for (let i = 1; i < parts.length; i++) {
    // This was definitely a namespace so far
    const previousArtifactName = seen;
    seen = `${seen}.${parts[i]}`;
    // This might not be - if it isn't, return the result.
    const currentArtifact = csn.definitions[seen];
    if (currentArtifact && currentArtifact.kind !== 'namespace')
      return previousArtifactName;
  }
  // We came till here - so the full artifactName is a namespace
  return artifactName;
}

/**
 * Sorts the definition dictionary in tests mode.
 *
 * @param {CSN.Model} csn
 * @param {CSN.Options} options
 */
function sortCsnDefinitionsForTests(csn, options) {
  if (!options.testMode)
    return;
  const sorted = Object.create(null);
  Object.keys(csn.definitions || {}).sort().forEach((name) => {
    sorted[name] = csn.definitions[name];
  });
  csn.definitions = sorted;
}

/**
 * Return an array of non-abstract service names contained in CSN
 *
 * @param {CSN.Model} csn
 * @returns {string[]}
 */
function getServiceNames(csn) {
  let result = [];
  forEachDefinition(csn, (artifact, artifactName) => {
    if (artifact.kind === 'service' && !artifact.abstract) {
      result.push(artifactName);
    }
  });
  return result;
}

/**
 * Check whether the artifact is @cds.persistence.skip
 *
 * @param {CSN.Artifact} artifact
 * @returns {Boolean}
 */
function isSkipped(artifact) {
  return hasAnnotationValue(artifact, '@cds.persistence.skip', true)
}

/**
 * Walk path in the CSN and return the result.
 *
 * @param {CSN.Model} csn
 * @param {CSN.Path} path
 * @returns {object} Whatever is at the end of path
 */
function walkCsnPath(csn, path) {
  /** @type {object} */
  let obj = csn;
  for(const segment of path){
    obj = obj[segment];
  }

  return obj;
}

/**
 * If provided, get the replacement string for the given magic variable ref.
 * No validation is done that the ref is actually magic!
 *
 * @param {array} ref
 * @param {CSN.Options} options
 * @returns {string|null}
 */
function getVariableReplacement(ref, options) {
  if(options && options.variableReplacements) {
    let replacement = options.variableReplacements;
    for(const segment of ref) {
      replacement = replacement[segment];
      if(replacement === undefined)
        return null;
    }

    if(replacement === undefined)
      return null; // no valid replacement found
    else if(typeof replacement === 'string')
      return replacement; // valid replacement
    else
      return null; // $user.foo, but we only have configured $user.foo.bar -> error
  } else {
    return null;
  }
}

/**
 *
 * @param {object} obj
 * @param {*} other
 * @param {boolean} noExtendedProps
 * @returns {boolean} returns equality
 *
 * noExtendedProps remove '$', '_' and '@' properties from
 * the comparison. This eliminates false negatives such as
 *  mismatching $locations or @odata.foreignKey4.
 */
function isDeepEqual(obj, other, noExtendedProps) {
  let objectKeys = Object.keys(obj);
  let otherKeys = Object.keys(other);

  if(noExtendedProps) {
    objectKeys = objectKeys.filter(k => !['@', '$', '_'].includes(k[0]));
    otherKeys = otherKeys.filter(k => !['@', '$', '_'].includes(k[0]));
  }
  if (objectKeys.length !== otherKeys.length)
    return false;

  for (let key of objectKeys) {
    const areValuesObjects = (obj[key] != null && typeof obj[key] === 'object')
      && (other[key] !== null && typeof other[key] === 'object');

    if (areValuesObjects) {
      if (!isDeepEqual(obj[key], other[key], noExtendedProps))
        return false;
    } else if (obj[key] !== other[key]) {
      return false;
    }
  }
  return true;
}

module.exports = {
  getUtils,
  cloneCsn: cloneCsnNonDict, // Umbrella relies on this name
  cloneCsnNonDict,
  cloneCsnDictionary,
  isBuiltinType,
  assignAll,
  applyDefinitionAnnotationsFromExtensions,
  forEachGeneric,
  forEachDefinition,
  forEachMember,
  forEachMemberWithQuery,
  forEachMemberRecursively,
  forEachMemberRecursivelyWithQuery,
  forAllQueries,
  hasAnnotationValue,
  isEdmPropertyRendered,
  getArtifactDatabaseNameOf,
  getResultingName,
  getUnderscoredName,
  getElementDatabaseNameOf,
  applyTransformations,
  applyTransformationsOnNonDictionary,
  setDependencies,
  isPersistedOnDatabase,
  generatedByCompilerVersion,
  getNormalizedQuery,
  mergeOptions,
  getRootArtifactName,
  getLastPartOfRef,
  getParentNamesOf,
  getParentNameOf,
  getLastPartOf,
  copyAnnotations,
  copyAnnotationsAndDoc,
  isAspect,
  forEachPath,
  hasValidSkipOrExists,
  getNamespace,
  sortCsnDefinitionsForTests,
  getServiceNames,
  isSkipped,
  walkCsnPath,
  getVariableReplacement,
  implicitAs,
  isDeepEqual,
};
