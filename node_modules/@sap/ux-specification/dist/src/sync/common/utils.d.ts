import type { Definition } from 'typescript-json-schema';
import type { ExtensionLogger } from '../../apiTypes';
import type { FacetConfigs, FileData, FacetConfig, FacetSection, SchemaFilePath, anyFacetType } from './types';
import type { Manifest } from '../../specification/common';
import type { MetadataInstanceInterface } from './decoration/factory';
import type { DataFieldAbstractTypes } from '@sap-ux/vocabularies-types/vocabularies/UI';
import type { ConvertedMetadata, EntityType, PropertyPath } from '@sap-ux/vocabularies-types';
import { FioriElementsVersion, PageType, PageTypeV4 } from '../../specification/common';
import { SchemaType } from '../../specification/schemaAccess';
import type { PropertyAnnotations } from '@sap-ux/vocabularies-types/vocabularies/Edm_Types';
export declare enum TemplateType {
    ListReportObjectPageV2 = "ListReportObjectPageV2",
    ListReportObjectPageV4 = "ListReportObjectPageV4",
    OverviewPageV2 = "OverviewPageV2",
    AnalyticalListPageV2 = "AnalyticalListPageV2",
    AnalyticalListPageV4 = "AnalyticalListPageV4"
}
export declare const DEFINITION_LINK_PREFIX = "#/definitions/";
/**
 * Function returns annotation path for schema based on received params.
 * @param entityTypeName - Entity type name.
 * @param term - Annotation term.
 * @param qualifier - Annotation qualifier.
 * @returns Annotation path based on received params
 */
export declare const createAnnotationPath: (entityTypeName: string, term: string, qualifier?: string) => string;
/**
 * Parses, merges, and converts a list of annotation files with aid of tools from annotation-vocabularies-tools
 * @param annotationFiles - The list of all annotation files, in JSON format
 * @returns the complete service information
 */
export declare function parseAndMergeAndConvert(annotationFiles: FileData[], logger: ExtensionLogger): ConvertedMetadata;
export declare const getAnnotationPropertyValue: (annotationProperty: any) => string;
/**
 * Checks for Common.Label and overwrites the label from it if present
 * @param {PropertyAnnotations} annotations - property annotations
 * @param {EntityType} entityType - entity type
 * @param {string} label - label, to be actualized
 */
export declare function evaluateCommonLabel(annotations: PropertyAnnotations, entityType: EntityType, label: string): string;
/**
 * Determines the label for a property path
 * @param {PropertyPath} propertyPath - property path
 * @param {EntityType} entityType - entity type
 * @returns label, derived from Common.Label or from property value
 */
export declare function getLabelForPropertyPath(propertyPath: PropertyPath, entityType: EntityType): string;
/**
 * Determines the label for a LineItem record
 * @param {DataFieldAbstractType} field - Line item record
 * @param {EntityType} entityType - entity type
 * @returns label, derived from Common.Label or from property value
 */
export declare function getLabelForDataField(field: DataFieldAbstractTypes, entityType: EntityType): string;
/**
 * Determines the description of a data field, e.g. for the column header
 * @param dataFieldAbstract - the given record of the line item annotation
 * @param entityType - the entity type as part of the AVT ConvertedMetadata
 */
export declare function getDataFieldDescription(dataFieldAbstract: DataFieldAbstractTypes, entityType: EntityType): string;
/**
 * Prepare string for reference use in schema
 * @param refInput string to be character checked and replaced
 * @returns string with replaced characters
 */
export declare function prepareRef(refInput: string): string;
/**
 * Return the page type for a given V2 page in manifest
 * @param name - page component name
 */
export declare function getPageTypeV2(name: string): PageType | undefined;
/**
 * Return the page type for a given V4 page in manifest
 * @param name - page component name
 */
export declare function getPageTypeV4(name: string): PageTypeV4 | undefined;
/**
 * Finds the alias for a given namespace in the references' section of the converted service metadata
 * @param {string} namespace - complete namespace, e.g. 'com.sap.vocabularies.UI.v1'
 * @param {ConvertedMetadata} oDataServiceAVT - combined service metadata, as returned by annotation vocabularies tools
 * @returns alias for the given namespace
 */
export declare function findAlias(namespace: string, oDataServiceAVT: ConvertedMetadata): string;
/**
 * Resolve page section(get key and label->description).
 * @param facetDefinition - the actual annotation record
 * @param keyForRelatedFacetKeys - construct key for 'keyForRelatedFacetKeys' property(used to define custom sections) - we should not add '@' symbol there.
 * @param {FioriElementsVersion} oDataVersion - OData version
 * @param {ConvertedMetadata} oDataServiceAVT - complete service information, as returned by annotation vocabularies tool
 * @param {ExtensionLogger} logger - Logger class for logging messages
 * @returns {FacetSection} - object comprising the relevant facet information
 */
export declare function getSectionFacet(facetDefinition: anyFacetType, sourceEntityType: EntityType, oDataServiceAVT: ConvertedMetadata, logger?: ExtensionLogger, oDataVersion?: FioriElementsVersion, keyForRelatedFacetKeys?: boolean): FacetSection | undefined;
/**
 * Finds the alias for a given namespace in the references' section of the converted service metadata.
 * An empty object is created if the path element does not exist yet.
 * Exception: if an empty array is the next element  of the 'path' definition, an empty array is created instead of an empty object.
 * @param {object} manifest - manifest that is being modified during export
 * @param {string} path - path of the property in the manifest
 * @param {string} targetAnnotation - target annotation (optional)
 * @param {string} targetAnnotationEncoded - target annotation in its encoded form, as used in manifest settings
 * @param {boolean} importScenario - indicates if the function is called for the import, else it is the export
 * @returns returns section of the manifest based on path, generates an empty object in case it does not exists
 */
export declare const getManifestSectionByPathV4: (manifest: object, path: string, targetAnnotation?: string, targetAnnotationEncoded?: string, importScenario?: boolean) => object;
export declare function getSchemaKeyOfLineItemRecord(lineItemRecord: DataFieldAbstractTypes): string;
/**
 * Retrieve header facet configurations that can be used to generate ObjectPage schemas
 * @param {QualifiedName} entityTypeName - the name of the actual entity type
 * @param {ConvertedMetadata} oDataServiceAVT - complete service information, as returned by annotation vocabularies tool
 * @param {FioriElementsVersion} oDataVersion - OData version
 * @param {ExtensionLogger} logger - Logger class for logging messages
 */
export declare function getObjectPageHeaderFacets(entityType: EntityType, oDataServiceAVT: ConvertedMetadata, oDataVersion?: FioriElementsVersion, logger?: ExtensionLogger): FacetConfigs | undefined;
/**
 * Retrieve facet configurations that can be used to generate ObjectPage schemas
 * @param {QualifiedName} entityTypeName - the name of the actual entity type
 * @param {ConvertedMetadata} oDataServiceAVT - complete service information, as returned by annotation vocabularies tool
 * @param {FioriElementsVersion} oDataVersion - OData version
 * @param {ExtensionLogger} logger - Logger class for logging messages
 */
export declare function getObjectPageFacets(entityType: EntityType, oDataServiceAVT: ConvertedMetadata, oDataVersion?: FioriElementsVersion, logger?: ExtensionLogger): FacetConfigs | undefined;
/**
 * Returns the version of Fiori elements (v2/v4) from a given manifest
 * @param manifest - the manifest.json file
 */
export declare function getVersionFromManifest(manifest: Manifest): FioriElementsVersion;
/**
 * Determines the template type of a V2 app
 * @param manifest - the manifest.json file
 * @param {ExtensionLogger} logger - Logger class for logging messages
 * @returns {TemplateType} the template type
 */
export declare function determineV2Template(manifest: Manifest, logger: ExtensionLogger): TemplateType | undefined;
/**
 * Determines the template type of a V4 app
 * @param manifest - the manifest.json file
 * @param {ExtensionLogger} logger - Logger class for logging messages
 * @returns {TemplateType} the template type
 */
export declare function determineV4Template(manifest: Manifest, logger: ExtensionLogger): TemplateType | undefined;
/**
 * Determines the template type, based on the given manifest entries of the app
 * @param manifest - the manifest.json file
 * @param {FioriElementsVersion} fioriElementsVersion - OData or FE version
 * @param {ExtensionLogger} logger - Logger class for logging messages
 * @returns {TemplateType} the template type
 */
export declare function getTemplateTypeFromManifest(manifest: Manifest, fioriElementsVersion: FioriElementsVersion, logger: ExtensionLogger): TemplateType | undefined;
/**
 * Adds title and description to a section or header section in an app schema
 * @param facet - intermediate facet structure comprising annotation information
 * @param section - section in the app schema
 * @param facetKey - key of the facet
 */
export declare function addSectionTitleAndDescription(facet: FacetConfig, section: Definition, facetKey: string): void;
/**
 * Adds target title or description to a section or header section in an app schema
 * @param facet - intermediate facet structure comprising annotation information
 * @param section - section in the app schema
 * @param facetKey - key of the facet
 */
export declare function addTargetTitleAndSectionDescription(facet: FacetConfig, section: Definition, facetKey: string): void;
/**
 * Creates a default object for a new section or subsection, and adds the ID as title if present.
 * @param facet Facet configuration, to be analyzed
 * @returns the new section object
 */
export declare function createDefaultSection(appSchema: Definition, facet: FacetConfig, facetKey: string): Definition;
/**
 * Retrieve page section data(so far id/key and label/description).
 * @param {EntityType} entityType The actual entityType
 * @param {ConvertedMetadata} oDataServiceAVT - complete service information, as returned by annotation vocabularies tool
 * @param {ExtensionLogger} logger - Logger class for logging messages
 * @param {FioriElementsVersion} oDataVersion - OData version
 * @param {boolean} [checkUnresolvableFacets=false] - Check and avoid facets and sections without ID and Target.
 * @returns {FacetSection[]} - Array of facets or sections
 */
export declare function getObjectPageFacetSection(entityType: EntityType, oDataServiceAVT: ConvertedMetadata, logger?: ExtensionLogger, oDataVersion?: FioriElementsVersion, checkUnresolvableFacets?: boolean): FacetSection[];
/**
 * Cleans empty sub-structures from the export result for manifest
 * @param manifest - manifest.json part of the export result
 * @param path  - path in the manifest
 * @param targetAnnotation - target annotation (optional, in case of sections, subsections)
 * @param targetAnnotationEncoded - encoded version of the target annotation, as represented in the manifest
 */
export declare const deleteEmptyStructure: (manifest: object, path: string, targetAnnotation?: string, targetAnnotationEncoded?: string) => void;
/**
 * Method which returns schema file name and path depending on passed schema or page type.
 * @param {SchemaType | PageType} schemaType Schema type or Page type.
 * @param {string} [entitySet] Entity set string.
 * @return {SchemaFilePath} File path info.
 */
export declare const getSchemaFilePath: (schemaType: PageType | PageTypeV4 | SchemaType, entitySet?: string) => SchemaFilePath;
/**
 * Method which generates id of page according to passed parameters.
 * @param appVersion - Fiori Elements version - V2 or V4.
 * @param pageType - Page type.
 * @param entitySet - Entity Set.
 * @param viewId - Custom page's viewId (optional).
 * @returns {string} Generated page id
 */
export declare function generatePageId(pageType: PageType | PageTypeV4, entitySet: string, viewId?: string): string;
export declare type NextDefinition = {
    configObject?: object;
    targetDefinition?: object;
    title?: string;
};
/**
 * Recursive function to determine the next config part, next definition in the app schema and the title
 * @param appSchema - app-specific JSON schema
 * @param title - default title
 * @param currentConfigObject - current part of the configuration that gets traversed
 * @param propertyDefinition - definition of a given property in the app schema
 * @param key - actual key
 * @param {MetadataInstanceInterface} factory - factory for creating metadata instances
 * @param pageType - page type
 */
export declare function getNextTargetDefinition(appSchema: object, title: string, currentConfigObject: object, propertyDefinition: object, key: string, factory: MetadataInstanceInterface, pageType: PageType | PageTypeV4): NextDefinition;
/**
 * Custom array merge function called by deepmerge's merge function
 *
 * @param {*} target Target array
 * @param {*} source Source array
 * @param {*} options options object provided by deepmerge's merge function
 * @returns
 */
export declare const arrayCombineMerge: (target: any, source: any, options: any) => string[];
/**
 * Converts an enum into a CSV
 * @param {object} manifestSection - manifestSection where the key exists
 * @param {object} configPart - Property as mentioned in config file
 * @param {string} key - Property to be exported to manifest
 */
export declare function convertEnumToCSV(manifestSection: any, configPart: any, key: string): void;
