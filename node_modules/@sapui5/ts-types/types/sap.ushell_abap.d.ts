// For Library Version: 1.92.1

declare namespace sap {
  namespace ui {
    /**
     * Provides access to UI5 loader configuration.
     *
     * The configuration is used by {@link sap.ui.require} and {@link sap.ui.define}.
     */
    namespace loader {
      /**
       * @SINCE 1.56.0
       *
       * Sets the configuration for the UI5 loader. The configuration can be updated multiple times. Later changes
       * do not impact modules that have been loaded before.
       *
       * If no parameter is given, a partial copy of UI5 loader configuration in use is returned.
       *
       * The configuration options are aligned with the "Common Config" draft of the AMD spec (https://github.com/amdjs/amdjs-api/blob/master/CommonConfig.md).
       *
       * The following code shows an example of what a UI5 loader configuration might look like:
       * ```javascript
       *
       *
       *   sap.ui.loader.config({
       *
       *     // location from where to load all modules by default
       *     baseUrl: '../../resources/',
       *
       *     paths: {
       *       // load modules whose ID equals to or starts with 'my/module' from example.com
       *       'my/module': 'https://example.com/resources/my/module'
       *     },
       *
       *     map: {
       *       // if any module requires 'sinon', load module 'sap/ui/thirdparty/sinon-4'
       *       '*': {
       *         'sinon': 'sap/ui/thirdparty/sinon-4'
       *       },
       *       // but if a module whose ID equals to or starts with 'app' requires 'sinon'
       *       // then load a legacy version instead
       *       "app": {
       *         'sinon': 'sap/ui/legacy/sinon'
       *       }
       *     },
       *
       *     // define two bundles that consists of JS modules only
       *     bundles: {
       *       bundle1: ['module1', 'module2'],
       *       bundle2: ['moduleX', 'moduleY']
       *     },
       *
       *     // define a bundle that also contains non-JS resources
       *     bundlesUI5: {
       *       'all.js': ['Component.js', 'manifest.json',
       *                  'App.controller.js', 'App.view.xml']
       *     },
       *
       *     // activate real async loading and module definitions
       *     async: true,
       *
       *     // provide dependency and export metadata for non-UI5 modules
       *     shim: {
       *       'sap/ui/thirdparty/blanket': {
       *         amd: true,
       *         exports: 'blanket'
       *       }
       *     }
       *
       *   });
       *
       * ```
       */
      function config(
        /**
         * The provided configuration gets merged with the UI5 loader configuration in use. If `cfg` is omitted
         * or `undefined`, a copy of the current configuration gets returned, containing at least the properties
         * `amd` and `async`.
         */
        cfg?:
          | {
              /**
               * Default location to load modules from. If none of the configured `paths` prefixes matches a module ID,
               * the module will be loaded from the concatenation of the `baseUrl` and the module ID.
               *
               * If the `baseUrl` itself is a relative URL, it is evaluated relative to `document.baseURI`.
               */
              baseUrl?: string;
              /**
               * A map of resource locations keyed by a corresponding module ID prefix. When a module is to be loaded,
               * the longest key in `paths` is searched that is a prefix of the module ID. The module will be loaded from
               * the concatenation of the corresponding value in `paths` and the remainder of the module ID (after the
               * prefix). If no entry in `paths` matches, then the module will be loaded from the `baseUrl`.
               *
               * The prefixes (keys) must not contain relative segments (./ or ../), a trailing slash will be removed,
               * and only full name segment matches are considered a match (prefix 'sap/m' does not match a module ID
               * 'sap/main').
               *
               * **Note**: In contrast to the "Common Config" of the AMD spec, the paths (values in the map) are interpreted
               * relative to `document.baseURI`, not relative to `cfg.baseUrl`.
               */
              paths?: Record<string, string>;
              /**
               * A map of maps that defines how to map module IDs to other module IDs (inner maps) in the context of a
               * specific set of modules (keys of outer map).
               *
               * Each key of the outer map represents a module ID prefix that describes the context for which its value
               * (inner map) has to be used. The special key `*` describes the default context which applies for any module.
               * Only the most specific matching context will be taken into account.
               *
               * Each inner map maps a module ID or module ID prefix to another module ID or module ID prefix. Again,
               * only the most specific match is taken into account and only one mapping is evaluated (the evaluation
               * of the mappings is not done recursively).
               *
               * Matches are always complete matches, a prefix 'a/b/c' does not match the module ID 'a/b/com'.
               */
              map?: Record<string, Record<string, string>>;
              /**
               * Defines additional metadata for modules for which the normal behavior of the AMD APIs is not sufficient.
               *
               * A typical example are scripts that don't use `define` or `sap.ui.define`, but export to a global name.
               * With the `exports` property, one or more export names can be specified, and the loader can retrieve the
               * exported value after executing the corresponding module. If such a module has dependencies, they can
               * be specified in the `deps` array and are loaded and executed before executing the module.
               *
               * The `amd` flag of a shim is a ui5loader-specific extension of the standard AMD shims. If set, the ui5loader
               * hides a currently active AMD loader before executing the module and restores it afterwards. Otherwise,
               * it might miss the export of third party modules that check for an AMD loader and register with it instead
               * of exporting to a global name. A future version of the ui5loader might ignore this flag when it acts
               * as an AMD loader by itself.
               *
               * **Note:** The ui5loader does not support the `init` option described by the "Common Config" section of
               * the AMD spec.
               */
              shim?: Record<
                string,
                {
                  amd: boolean;

                  deps: string[];

                  exports: string | string[];
                }
              >;
              /**
               * A map of arrays that each define the modules contained in a bundle.
               *
               * Each key of the map represents the module ID of a bundle file. The array value represents the set of
               * JavaScript modules (their module IDs) that are contained in the bundle.
               *
               * When a module is required that has not been loaded yet, and for which a containing bundle is known, that
               * bundle will be required first. Only then the original module will be required again and usually be taken
               * from the just loaded bundle.
               *
               * A bundle will be loaded asynchronously only when the loader is in asynchronous mode and when the request
               * for the contained module originates from an asynchronous API. In all other cases, the bundle has to be
               * loaded synchronously to fulfill API contracts.
               *
               * **Note:** The loader only supports one containing bundle per module. If a module is declared to be part
               * of multiple bundles, only the last one will be taken into account.
               *
               * This configuration option is basically provided to be compatible with requireJS or SystemJS configuration.
               */
              bundles?: Record<string, string[]>;
              /**
               * A map of arrays that each define the resources contained in a bundle.
               *
               * This is similar to `bundles`, but all strings are unified resource names including a file type extension,
               * not only module IDs. This allows to represent more than just JavaScript modules.
               *
               * Each key of the map represents the resource name (in unified resource name syntax) of a bundle file.
               * The array value represents the set of resources (also in unified resource name syntax) that are contained
               * in the bundle. The array can contain JavaScript as well as other textual resource types (e.g. *.xml or
               * *.json resources).
               *
               * When a module is required that has not been loaded yet, and for which a containing bundle is known, that
               * bundle will be required first. Only then the original module will be required again and usually be taken
               * from the just loaded bundle.
               *
               * A bundle will be loaded asynchronously only when the loader is in asynchronous mode and when the request
               * for the contained module originates from an asynchronous API. In all other cases, the bundle has to be
               * loaded synchronously to fulfill API contracts.
               *
               * **Note:** The loader only supports one containing bundle per module. If a module is declared to be part
               * of multiple bundles, only the last one will be taken into account.
               *
               * **Note:** Although non-JS resources can be declared to be part of a bundle, only requests for JavaScript
               * modules will currently trigger the loading of a bundle.
               */
              bundlesUI5?: Record<string, string[]>;
              /**
               * When set to true, `sap.ui.require` loads modules asynchronously via script tags and `sap.ui.define` executes
               * asynchronously. To enable this feature, it is recommended to set the attribute `data-sap-ui-async="true"`
               * on the application bootstrap tag.
               *
               * **Note:** Switching back from async to sync is not supported and trying to do so will throw an `Error`
               */
              async?: boolean;
              /**
               * When set to true, the ui5loader will overwrite the global properties `define` and `require` with its
               * own implementations. Any previously active AMD loader will be remembered internally and can be restored
               * by setting `amd` to false again.
               *
               * **Note:** Switching to the `amd` mode, the ui5loader will set `async` to true implicitly for activating
               * asynchronous loading. Once the loading behaviour has been defined to be asynchronous, it can not be changed
               * to synchronous behaviour again, also not via setting `amd` to false.
               */
              amd?: boolean;
            }
          | undefined
      ): object | undefined;
    }
  }

  namespace ui2 {
    namespace srvc {
      /**
       * @SINCE 1.19.0
       */
      class ODataService {
        /**
         * Constructs a facade to any OData service, providing token handling for SAP NetWeaver Gateway's token-based
         * CSRF protection mechanism.
         */
        constructor(
          /**
           * OData wrapper instance this service facade delegates to
           */
          oODataWrapper: sap.ui2.srvc.ODataWrapper,
          /**
           * error handler taking an error message and, since version 1.28.6, an optional object containing the complete
           * error information as delivered by the ODataService. See fnFailure parameter of {@link sap.ui2.srvc.ODataWrapper#onError}
           * for more details.
           */
          fnDefaultFailure?: (p1: string, p2: object) => void
        );

        /**
         * @SINCE 1.7.0
         *
         * Returns the current value of the CSRF token. It is initially empty and determined automatically by `sap.ui2.srvc.ODataWrapper`
         * on successful read requests.
         * See:
         * 	#refreshCsrfToken
         * 	#setCsrfToken
         */
        getCsrfToken(): string;
        /**
         * @SINCE 1.19.0
         *
         * Opens a new queue where all requests are parked until a call to {@link #submitBatchQueue}.
         */
        openBatchQueue(): void;
        /**
         * @SINCE 1.17.0
         *
         * Refreshes the CSRF token of this OData service by reading the service document again, which is never
         * cached. Called automatically by `sap.ui2.srvc.ODataWrapper` on a write operation if the CSRF token is
         * missing or expired.
         * See:
         * 	#getCsrfToken
         * 	#setCsrfToken
         * 	sap.ui2.srvc.ODataWrapper#read
         */
        refreshCsrfToken(
          /**
           * a callback function that is executed if the request succeeds
           */
          fnSuccess: Function,
          /**
           * error handler taking an error message and, since version 1.28.6, an optional object containing the complete
           * error information as delivered by the ODataService. See fnFailure parameter of {@link sap.ui2.srvc.ODataWrapper#onError}
           * for more details.
           */
          fnFailure?: (p1: string, p2: object) => void
        ): void;
        /**
         * @SINCE 1.7.0
         *
         * Determines the new value of the CSRF token. Use this function to synchronize the CSRF token across multiple
         * instances of this facade in case their first read requests run in parallel. Retrieve the token from a
         * service in the success handler of its read request and distribute it to all other services; do so for
         * each service. Note that the last success handler of all first read requests run in parallel determines
         * the token to be used for modifications.  If debugging HTTP traffic, watch out for `x-csrf-token` headers
         * and `sap-XSRF_*` cookies.
         * See:
         * 	#getCsrfToken
         * 	#refreshCsrfToken
         */
        setCsrfToken(
          /**
           * the new value of the CSRF token, which may be `null` or `undefined`
           */
          sNewCsrfToken?: string
        ): void;
        /**
         * @SINCE 1.2.0
         *
         * Sets the default error handler for this facade.
         */
        setDefaultErrorHandler(
          /**
           * error handler taking an error message and, since version 1.28.6, an optional object containing the complete
           * error information as delivered by the ODataService. See fnFailure parameter of {@link sap.ui2.srvc.ODataWrapper#onError}
           * for more details.
           */
          fnNewDefaultFailure: (p1: string, p2: object) => void
        ): void;
        /**
         * @SINCE 1.19.0
         *
         * Submits the current batch queue opened by {@link #openBatchQueue} by sending a single "$batch" request
         * to the OData service and deletes the current batch queue immediately.
         * See:
         * 	#openBatchQueue
         * 	#isBatchQueueOpen
         */
        submitBatchQueue(
          /**
           * A callback function that is executed if the batch request is accepted by the server, no matter whether
           * individual operations fail. It will be called **after** all success or failure handlers of individual
           * operations.
           */
          fnBatchAccepted?: Function,
          /**
           * A callback function that is executed if the batch request itself fails, error handler taking an error
           * message and, since version 1.28.6, an optional object containing the complete error information as delivered
           * by the ODataService. See fnFailure parameter of {@link sap.ui2.srvc.ODataWrapper#onError} for more details.
           *
           * Defaults to the OData service facade's default error handler ({@link sap.ui2.srvc.ODataService#getDefaultErrorHandler}).
           *
           * This is called **instead** of individual failure handlers in this case!
           */
          fnBatchItselfFailed?: (p1: string, p2: object) => void
        ): void;
      }
      /**
       * @SINCE 1.19.0
       */
      class ODataWrapper {
        /**
         * Constructs a wrapper around `OData`, providing CSRF token handling, caching and generic batch support.
         * The sap-statistics header is automatically added to all requests if the URL query parameter `sap-statistics=true`
         * is set (see
         * SAP Performance Statistics). If `OData` is missing, "sap.ui.thirdparty.datajs" is required automatically.
         *  The preferred way to call the constructor is from a "sub-class" of {@link sap.ui2.srvc.ODataService}:
         *
         * ```javascript
         *
         *   function Service() {
         *     var oWrapper = new sap.ui2.srvc.ODataWrapper(oSettings, this);
         *     sap.ui2.srvc.ODataService.call(this, oWrapper, fnDefaultFailure);
         *   }
         *   var myService = new Service();
         * ```
         *  This provides public inheritance of `sap.ui2.srvc.ODataService` methods and private inheritance of `sap.ui2.srvc.ODataWrapper`
         * methods. In case you are not providing a public "sub-class" of `sap.ui2.srvc.ODataService` but only want
         * to use methods from `sap.ui2.srvc.ODataWrapper`, {@link sap.ui2.srvc.createODataWrapper} is the preferred
         * way to construct an instance.
         */
        constructor(
          /**
           * An object containing various properties:
           * ```javascript
           *
           *     {
           *       baseUrl: "/OData/OData.svc", // Mandatory base URL of the OData service
           *       supportsChangeSets: false,   // Type: boolean, Default: false
           *                                    // Whether the OData service supports change sets with **multiple**
           *                                    // operations bundled into a single logical unit of work. Otherwise
           *                                    // each modifying operation is isolated in a change set of its own.
           *       "sap-language": "EN",        // header which is set for all requests sent
           *       "sap-client": 120,           // header which is set for all requests sent
           *       "sap-statistics": true       // header which is set for all requests sent; in order to receive
           *                                    // some performance statistics
           *     }
           *   ```
           */
          oSettings: object,
          /**
           * facade to any OData service, keeping track of CSRF token and default error handler (see {@link #getODataService})
           */
          oODataService: sap.ui2.srvc.ODataService
        );

        /**
         * @SINCE 1.19.0
         *
         * Checks that the given callback functions are really functions. This check is useful to "fail fast" because
         * these callbacks are not called immediately.
         */
        check(
          /**
           * success callback
           */
          fnSuccess: Function,
          /**
           * error callback
           */
          fnFailure: Function
        ): void;
        /**
         * @SINCE 1.19.0
         *
         * Wrapper around `OData.request` which is able to automatically fetch a CSRF token if required. It uses
         * POST as a method.
         */
        create(
          /**
           * a string containing the **relative** URL w.r.t. this OData wrapper's base URL, e.g. "Products"
           */
          sRelativeUrl: string,
          /**
           * payload of the request (in intermediate format)
           */
          oPayload: object,
          /**
           * callback function that is executed if the request succeeds, taking the processed data
           */
          fnSuccess?: (p1: object) => void,
          /**
           * error handler taking an error message and, since version 1.28.6, an optional object containing the complete
           * error information as delivered by the ODataService. See fnFailure parameter of {@link sap.ui2.srvc.ODataWrapper#onError}
           * for more details. Defaults to the OData service facade's default error handler
           */
          fnFailure?: (p1: string, p2: object) => void
        ): void;
        /**
         * @SINCE 1.19.0
         *
         * Wrapper around `OData.request` which is able to automatically fetch a CSRF token if required. It uses
         * DELETE as a method.
         */
        del(
          /**
           * either a string containing the **relative** URL w.r.t. this OData wrapper's base URL, e.g. "Products(1)",
           * or the datajs representation of the entity
           */
          vEntity: string | object,
          /**
           * callback function that is executed if the request succeeds, taking no data
           */
          fnSuccess?: Function,
          /**
           * error handler taking an error message and, since version 1.28.6, an optional object containing the complete
           * error information as delivered by the ODataService. See fnFailure parameter of {@link sap.ui2.srvc.ODataWrapper#onError}
           * for more details. Defaults to the OData service facade's default error handler
           */
          fnFailure?: (p1: string, p2: object) => void
        ): void;
        /**
         * @SINCE 1.30.0
         *
         *  Configures and activates session stickiness.   Session stickiness allows the client to execute
         * OData requests to the same application server. This is achieved by copying a certain sticky session header
         * (found in the OData response from the server) to the OData request made by ODataWrapper, indicating the
         * load balancer that requests should be made against a certain application server. Once detected, the sticky
         * header is automatically shared by all instances of `sap.ui2.srvc.ODataWrapper` connected to exactly the
         * same base URL.   NOTE: The sticky session header sent from the server always overrides the last
         * sticky session header requested. This is to avoid that the feature is disabled if the load balancer returns
         * another value for the sticky session header for some reason (e.g. the application server goes offline).
         *   NOTE: In line with {@link sap.ui2.srvc.PageBuildingService}, session stickiness is only supported
         * in scopes different from PERS.   Currently, session stickiness is affected by the following limitations:
         *
         * 	 - If the client caches the response headers for certain requests, these cached headers will be used
         * 			instead of the headers sent from the server (as in if cache was disabled).
         * 	 - If initial requests to different URLs that share the same base URL are performed asynchronously (e.g.
         * 			through multiple instances of ODataWrapper), sticky session may be disabled for a part or all of these
         * 			initial requests. This is because the requests are made before the first response with a sticky session
         * 			header is obtained.
         * 	 - This mechanism only guarantees that requests are forwarded to the specified application server. For
         * 			example, if the application server in turn contacts further load balanced servers, the session may not
         * 			be maintain and load balancing may still occur.
         */
        enableStickySession(): void;
        /**
         * @SINCE 1.19.0
         *
         * Returns the wrapper's base URL.
         */
        getBaseUrl(): string;
        /**
         * @SINCE 1.19.1
         *
         * Returns this wrapper's facade to an OData service (which was passed to the constructor {@link sap.ui2.srvc.ODataWrapper}).
         */
        getODataService(): sap.ui2.srvc.ODataService;
        /**
         * @SINCE 1.34.0
         *
         * Checks whether the queue of requests is already open or not
         * See:
         * 	#openBatchQueue
         * 	#submitBatchQueue
         */
        isBatchQueueOpen(): boolean;
        /**
         * @SINCE 1.30.0
         *
         * Checks whether session stickyness is configured and enabled
         */
        isStickySessionEnabled(): boolean;
        /**
         * @SINCE 1.19.0
         *
         * Wraps the given generic OData failure handler. It processes the raw OData error response object, calls
         * the given failure handler with an error message and, since version 1.28.6, an object containing additional
         * technical details. If a Deferred object is given, it is rejected with the same arguments passed to the
         * failure handler call.
         *
         * This method logs technical information to the console if this is available at the time the error occurs.
         */
        onError(
          /**
           * the HTTP method used in the OData request, e.g. "POST"
           */
          sMethod: string,
          /**
           * the **absolute** URL the request is sent to
           */
          sRequestUrl: string,
          /**
           * the wrapped failure handler that will be called synchronously. The first parameter is a human-readable
           * error message containing technical information, including sMethod and sRequestUrl; the second parameter
           * is an **optional** object containing the complete error information returned in the `error` value contained
           * in the body of the OData error response object, plus the HTTP response status code.
           *
           * For example, the returned error object has the following structure:
           * ```javascript
           *
           *   {
           *     httpStatus: 404,
           *     // ... other keys and values from oError.response.body.error
           *   }
           *   ```
           *
           *
           * Please refer to the documentation of the specific OData service used for details about keys and values
           * returned in `oError.response.body.error`.
           *
           * **IMPORTANT:** the second parameter may be undefined if the error cannot be parsed or is not returned
           * in the OData error response.
           *
           * **NOTE:** the second parameter is returned since version 1.28.6.
           */
          fnFailure: (p1: string, p2: object) => void,
          /**
           * a `jQuery.Deferred` object that will be rejected with the same arguments fnFailure is called
           */
          oDeferred: jQuery.Deferred,
          /**
           * error object provided by datajs, should contain the response
           */
          oError: object
        ): void;
        /**
         * @SINCE 1.19.0
         *
         * Wraps the given generic OData failure handler. It processes the raw OData error response object, calls
         * the given failure handler with an error message and, since version 1.28.6, an object containing additional
         * technical details. If a Deferred object is given, it is rejected with the same arguments passed to the
         * failure handler call.
         *
         * This method logs technical information to the console if this is available at the time the error occurs.
         */
        onError(
          /**
           * the HTTP method used in the OData request, e.g. "POST"
           */
          sMethod: string,
          /**
           * the **absolute** URL the request is sent to
           */
          sRequestUrl: string,
          /**
           * the wrapped failure handler that will be called synchronously. The first parameter is a human-readable
           * error message containing technical information, including sMethod and sRequestUrl; the second parameter
           * is an **optional** object containing the complete error information returned in the `error` value contained
           * in the body of the OData error response object, plus the HTTP response status code.
           *
           * For example, the returned error object has the following structure:
           * ```javascript
           *
           *   {
           *     httpStatus: 404,
           *     // ... other keys and values from oError.response.body.error
           *   }
           *   ```
           *
           *
           * Please refer to the documentation of the specific OData service used for details about keys and values
           * returned in `oError.response.body.error`.
           *
           * **IMPORTANT:** the second parameter may be undefined if the error cannot be parsed or is not returned
           * in the OData error response.
           *
           * **NOTE:** the second parameter is returned since version 1.28.6.
           */
          fnFailure: (p1: string, p2: object) => void,
          /**
           * error object provided by datajs, should contain the response
           */
          oError: object
        ): void;
        /**
         * @SINCE 1.19.0
         *
         * Opens a new queue where all requests are parked until a call to {@link #submitBatchQueue}.
         * See:
         * 	#isBatchQueueOpen
         * 	#submitBatchQueue
         */
        openBatchQueue(): void;
        /**
         * @SINCE 1.19.0
         *
         * Wrapper around  `OData.read`
         * which supports caching.
         */
        read(
          /**
           * a string containing the **relative** URL w.r.t. this OData wrapper's base URL, e.g. "Products(1)"
           */
          sRelativeUrl: string,
          /**
           * a callback function that is executed if the request succeeds, taking the processed data
           */
          fnSuccess: (p1: object) => void,
          /**
           * error handler taking an error message and, since version 1.28.6, an optional object containing the complete
           * error information as delivered by the ODataService. See fnFailure parameter of {@link sap.ui2.srvc.ODataWrapper#onError}
           * for more details. Defaults to the OData service facade's default error handler ({@link sap.ui2.srvc.ODataService#getDefaultErrorHandler})
           */
          fnFailure?: (p1: string, p2: object) => void,
          /**
           * whether the response is cached for further calls (since 1.11.0) in `OData.read.$cache`, a `sap.ui2.srvc.Map`
           * from `sRequestUrl` to a `jQuery.Deferred` object created on demand; without this flag, the cache is neither
           * written nor read!
           */
          bCache?: boolean
        ): void;
        /**
         * @SINCE 1.19.0
         *
         * Submits the current batch queue opened by {@link #openBatchQueue} by sending a single "$batch" request
         * to the OData service and deletes the current batch queue immediately.
         * See:
         * 	#openBatchQueue
         * 	#isBatchQueueOpen
         */
        submitBatchQueue(
          /**
           * A callback function that is executed if the batch request is accepted by the server, no matter whether
           * individual operations fail. It will be called **after** all success or failure handlers of individual
           * operations.
           */
          fnBatchAccepted?: Function,
          /**
           * A callback function that is executed if the batch request itself fails, error handler taking an error
           * message and, since version 1.28.6, an optional object containing the complete error information as delivered
           * by the ODataService. See fnFailure parameter of {@link sap.ui2.srvc.ODataWrapper#onError} for more details.
           *
           * Defaults to the OData service facade's default error handler ({@link sap.ui2.srvc.ODataService#getDefaultErrorHandler}).
           *
           * This is called **instead** of individual failure handlers in this case!
           */
          fnBatchItselfFailed?: (p1: string, p2: object) => void
        ): void;
        /**
         * @SINCE 1.19.0
         *
         * Returns this wrapper's string representation.
         */
        toString(
          /**
           * flag whether to show all properties
           */
          bVerbose?: boolean
        ): string;
        /**
         * @SINCE 1.19.0
         *
         * Generic entity update method.
         */
        update(
          /**
           * the datajs representation of the entity
           */
          oEntity: object,
          /**
           * callback function that is executed if the request succeeds, taking no data
           */
          fnSuccess?: Function,
          /**
           * error handler taking an error message and, since version 1.28.6, an optional object containing the complete
           * error information as delivered by the ODataService. See fnFailure parameter of {@link sap.ui2.srvc.ODataWrapper#onError}
           * for more details. Defaults to the OData service facade's default error handler
           */
          fnFailure?: (p1: string, p2: object) => void
        ): void;
      }
    }
  }

  interface IUI5DefineDependencyNames {
    "sap/ui2/srvc/ODataService": undefined;

    "sap/ui2/srvc/ODataWrapper": undefined;

    "sap/ushell_abap/bootstrap/evo/abap-dbg": undefined;

    "sap/ushell_abap/library": undefined;
  }
}
