"use strict";
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.UniqueNameGenerator = void 0;
/**
 * Holds state on already used names and provides new names if there are naming conflicts.
 */
var UniqueNameGenerator = /** @class */ (function () {
    /**
     * Creates an instance of UniqueNameGenerator.
     * @param indexSeparator - The separator to be used when adding an index.
     * @param usedNames - Sets the already used names considered in the finding process.
     */
    function UniqueNameGenerator(indexSeparator, usedNames) {
        if (indexSeparator === void 0) { indexSeparator = '_'; }
        if (usedNames === void 0) { usedNames = []; }
        this.indexSeparator = indexSeparator;
        this.usedNames = [];
        this.addToUsedNames.apply(this, usedNames);
    }
    UniqueNameGenerator.getNameForComparison = function (name, caseSensitive) {
        return caseSensitive ? name : name.toLowerCase();
    };
    /**
     * Adds the name(s) to the already used names.
     * @param names - Names to be added
     */
    UniqueNameGenerator.prototype.addToUsedNames = function () {
        var _a;
        var names = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            names[_i] = arguments[_i];
        }
        (_a = this.usedNames).push.apply(_a, names);
    };
    /**
     * Generate a unique name by appending an index separated by the `indexSeparator` if necessary, e. g. if `MyName` is already taken `MyName_1` will be found by default.
     * If the name is already unique nothing is appended.
     * @param name - The name to get a unique name from.
     * @param caseSensitive - Whether to check the already used names in a case sensitive manner.
     * @returns A unique name.
     */
    UniqueNameGenerator.prototype.generateUniqueName = function (name, caseSensitive) {
        if (caseSensitive === void 0) { caseSensitive = true; }
        return this.generateUniqueNamesWithSuffixes(name, [], caseSensitive)[0];
    };
    /**
     * Generate a unique name by appending an index separated by the `indexSeparator` if necessary, e. g. if `MyName` is already taken `MyName_1` will be found by default.
     * The generated name is added to the used names.
     * If the name is already unique nothing is appended.
     * @param name - The name to get a unique name from.
     * @param caseSensitive - Whether to check the already used names in a case sensitive manner.
     * @returns A unique name.
     */
    UniqueNameGenerator.prototype.generateAndSaveUniqueName = function (name, caseSensitive) {
        if (caseSensitive === void 0) { caseSensitive = true; }
        var uniqueName = this.generateUniqueName(name, caseSensitive);
        this.addToUsedNames(uniqueName);
        return uniqueName;
    };
    /**
     * Generate unique names by appending an index separated by the `indexSeparator` if necessary, while respecting the given suffixes.
     * If the name is already unique nothing is appended.
     * Each given suffix is appended to the unique name in the result.
     * The resulting names are also checked for uniqueness.
     * All names in the result have the same number suffix.
     * Example: if `MyName` and `MyName_1MySuffix` is already taken, `[MyName_2, MyName_2MySuffix]` will be generated by default.
     * @param name - The name to get a unique name from
     * @param suffixes - Additional name of suffixes to be considered for the finding process, as well as the output.
     * @param caseSensitive - Whether to check the already used names in a case sensitive manner.
     * @returns A list of unique names. The length of this array is one plus the number of suffixes provided. The first entry corresponds to the given name.
     */
    UniqueNameGenerator.prototype.generateUniqueNamesWithSuffixes = function (name, suffixes, caseSensitive) {
        if (caseSensitive === void 0) { caseSensitive = true; }
        // Filter names to those that might be relevant for performance reasons
        var relevantUsedNames = this.getUsedNamesStartingWith(name, caseSensitive);
        var namesWithSuffixes = this.generateNamesWithSuffixes(name, suffixes);
        // Names do not need index
        if (!this.areNamesUsed(namesWithSuffixes, relevantUsedNames, caseSensitive)) {
            return __spreadArray([name], namesWithSuffixes, true);
        }
        // Names do need index
        var index = this.getUniqueIndex(name, relevantUsedNames, suffixes, caseSensitive);
        return this.generateNamesWithIndexAndSuffixes(name, index, suffixes);
    };
    /**
     * Generate unique names by appending an index separated by the `indexSeparator` if necessary, while respecting the given suffixes.
     * If the name is already unique nothing is appended.
     * The generated names are added to the used names.
     * Each given suffix is appended to the unique name in the result.
     * The resulting names are also checked for uniqueness.
     * All names in the result have the same number suffix.
     * Example: if `MyName` and `MyName_1MySuffix` is already taken, `[MyName_2, MyName_2MySuffix]` will be generated by default.
     * @param name - The name to get a unique name from
     * @param suffixes - Additional name of suffixes to be considered for the finding process, as well as the output.
     * @param caseSensitive - Whether to check the already used names in a case sensitive manner.
     * @returns A list of unique names. The length of this array is one plus the number of suffixes provided. The first entry corresponds to the given name.
     */
    UniqueNameGenerator.prototype.generateAndSaveUniqueNamesWithSuffixes = function (name, suffixes, caseSensitive) {
        if (caseSensitive === void 0) { caseSensitive = true; }
        var uniqueNames = this.generateUniqueNamesWithSuffixes(name, suffixes, caseSensitive);
        this.addToUsedNames.apply(this, uniqueNames);
        return uniqueNames;
    };
    UniqueNameGenerator.prototype.getUsedNamesForComparison = function (caseSensitive) {
        return this.usedNames.map(function (name) {
            return UniqueNameGenerator.getNameForComparison(name, caseSensitive);
        });
    };
    UniqueNameGenerator.prototype.areNamesUsed = function (names, usedNames, caseSensitive) {
        return names.some(function (name) {
            return usedNames
                .map(function (usedName) {
                return UniqueNameGenerator.getNameForComparison(usedName, caseSensitive);
            })
                .includes(UniqueNameGenerator.getNameForComparison(name, caseSensitive));
        });
    };
    UniqueNameGenerator.prototype.generateNamesWithIndexAndSuffixes = function (name, index, suffixes) {
        var nameWithoutIndex = this.getNameWithoutIndex(name);
        return this.generateNamesWithSuffixes("".concat(nameWithoutIndex).concat(this.indexSeparator).concat(index), suffixes);
    };
    UniqueNameGenerator.prototype.generateNamesWithSuffixes = function (name, suffixes) {
        return __spreadArray([name], suffixes.map(function (nameSuffix) { return "".concat(name).concat(nameSuffix); }), true);
    };
    UniqueNameGenerator.prototype.getUsedNamesStartingWith = function (name, caseSensitive) {
        var modifiedName = this.getNameWithoutIndex(name);
        return this.getUsedNamesForComparison(caseSensitive).filter(function (used) {
            return used.startsWith(UniqueNameGenerator.getNameForComparison(modifiedName, caseSensitive));
        });
    };
    UniqueNameGenerator.prototype.getUniqueIndex = function (name, usedNames, suffixes, caseSensitive) {
        var index = 1;
        // This algorithm has order N**2 for N identical names. With a sort you could get it down to N*log(N)
        // However with the related items in mind this is much easier and N should be small anyway.
        while (index < UniqueNameGenerator.MAXIMUM_NUMBER_OF_SUFFIX) {
            var newNames = this.generateNamesWithIndexAndSuffixes(name, index, suffixes);
            if (!this.areNamesUsed(newNames, usedNames, caseSensitive)) {
                return index;
            }
            index++;
        }
        throw new Error("Unable to find a unique name for ".concat(name, " within the range of ").concat(UniqueNameGenerator.MAXIMUM_NUMBER_OF_SUFFIX, " suffixes."));
    };
    UniqueNameGenerator.prototype.getNameWithoutIndex = function (name) {
        return name.replace(new RegExp("".concat(this.indexSeparator, "\\d+$")), '');
    };
    UniqueNameGenerator.MAXIMUM_NUMBER_OF_SUFFIX = 1000;
    return UniqueNameGenerator;
}());
exports.UniqueNameGenerator = UniqueNameGenerator;
//# sourceMappingURL=unique-name-generator.js.map