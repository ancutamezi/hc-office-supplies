"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.mergeIgnoreCase = exports.mergeLeftIgnoreCase = exports.pickNonNullish = exports.pickValueIgnoreCase = exports.pickIgnoreCase = exports.toSanitizedObject = exports.assoc = exports.exclude = exports.pick = exports.renameKeys = exports.mergeSome = exports.assocSome = exports.propertyExists = void 0;
var nullish_1 = require("./nullish");
/**
 * Checks if a chain of properties exists on the given object.
 * @param obj - The object to be checked.
 * @param properties - Chained properties.
 * @returns `true` if the property chain leads to a truthy value, `false` otherwise.
 */
function propertyExists(obj) {
    var properties = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        properties[_i - 1] = arguments[_i];
    }
    if (!properties.length) {
        return true;
    }
    if (obj && obj.hasOwnProperty(properties[0])) {
        return propertyExists.apply(void 0, __spreadArray([obj[properties[0]]], properties.slice(1), false));
    }
    return false;
}
exports.propertyExists = propertyExists;
/**
 * @deprecated This will be removed in version 2.0 of the SDK.
 * Adds the value to the object if it is neither `null` nor `undefined`.
 * Note that this is different to JS idiomatic checks for truthy/falsy values, i.e. an empty string will result in key/value pairs being added.
 * @param key - The key to associate with the given value.
 * @param value - The value to associate with the given key.
 * @param obj - The object on which to create the association.
 * @returns A copy of the input object with the new key-value pair if the value is neither `null` nor `undefined`.
 */
var assocSome = function (key, value) {
    return function (obj) {
        if (typeof value !== 'undefined' && value !== null) {
            return (0, exports.assoc)(key, value, obj);
        }
        return __assign({}, obj);
    };
};
exports.assocSome = assocSome;
/**
 * @deprecated This will be removed in version 2.0 of the SDK.
 * Merges the two objects, if second object is neither `null` nor `undefined`.
 * If a key exists on `a` and `b` the value from `b` is taken.
 * @param a - The object to merge into.
 * @param b - The object which to merge into `a`.
 * @returns A copy of the `merge(a, b)` or `a` if `b` is `undefined` or `null`.
 */
var mergeSome = function (a, b) {
    if (typeof b !== 'undefined' && b !== null) {
        return __assign(__assign({}, a), b);
    }
    return a;
};
exports.mergeSome = mergeSome;
/**
 * Takes an object and returns a new object whose keys are renamed according to the provided key mapping.
 * Any keys in the input object not present in the key mapping will be present in the output object as-is.
 * If a key in the key mapping is not present in the input object, the output object will contain the key with value "undefined".
 * @param keyMapping - An object mapping keys of the input object to keys of the output object.
 * @param obj - The input object.
 * @returns An object with renamed keys.
 */
var renameKeys = function (keyMapping, obj) {
    var unchangedEntries = Object.keys(obj)
        .filter(function (k) { return !Object.keys(keyMapping).includes(k); })
        .reduce(function (newObj, key) {
        var _a;
        return (__assign(__assign({}, newObj), (_a = {}, _a[key] = obj[key], _a)));
    }, {});
    return Object.entries(keyMapping).reduce(function (newObj, _a) {
        var _b;
        var oldKey = _a[0], newKey = _a[1];
        return (__assign(__assign({}, newObj), (_b = {}, _b[newKey] = obj[oldKey], _b)));
    }, unchangedEntries);
};
exports.renameKeys = renameKeys;
/**
 * Create a shallow copy of the given object, that contains the given keys.
 * Non existing keys in the source object are ignored.
 * @param keys - properties to be selected
 * @param obj - object from which the values are taken
 * @returns an object with the selected keys and corresponding values.
 */
var pick = function (keys, obj) {
    var result = {};
    keys.forEach(function (key) {
        var value = obj[key];
        if (Object.keys(obj).includes(key)) {
            result[key] = value;
        }
    });
    return result;
};
exports.pick = pick;
/**
 * Create a shallow copy of the given object, that does not contain the given keys.
 * Non existing keys in the source object are ignored.
 * @param keys - properties to be selected
 * @param obj - object from which the values are taken
 * @returns an object with the selected keys and corresponding values.
 */
var exclude = function (keys, obj) {
    var result = {};
    Object.keys(obj).forEach(function (key) {
        var value = obj[key];
        if (!keys.includes(key)) {
            result[key] = value;
        }
    });
    return result;
};
exports.exclude = exclude;
/**
 * Adds a key value pair to the given objects and returns a shallow copy.
 * If the key is already present it will be overwritten.
 * @param key - key to be added
 * @param value - value to be added
 * @param obj - object the key value pair is added to.
 * @returns the object with the key value pair added
 */
var assoc = function (key, value, obj) {
    var _a;
    return (__assign(__assign({}, obj), (_a = {}, _a[key] = value, _a)));
};
exports.assoc = assoc;
/**
 * Create an object based on the given key and value if neither key nor value are nullish.
 * @param key - Name of the header.
 * @param value - Value of the header.
 * @returns - An object containing the given key and value of an empty object.
 */
function toSanitizedObject(key, value) {
    var _a;
    return (0, nullish_1.isNullish)(key) || (0, nullish_1.isNullish)(value) ? {} : (_a = {}, _a[key] = value, _a);
}
exports.toSanitizedObject = toSanitizedObject;
/**
 * Create a shallow copy of the given object, that contains the given keys, independent of casing.
 * Non existing keys in the source object are ignored.
 * @param obj - Object to pick the given key from.
 * @param keys - Keys of the pair to be picked.
 * @returns - An object containing the given key-value pairs in its original case or an empty object if none of them are found.
 */
function pickIgnoreCase(obj) {
    if (obj === void 0) { obj = {}; }
    var keys = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        keys[_i - 1] = arguments[_i];
    }
    return keys.reduce(function (filteredHeaders, providedKey) {
        var _a;
        var originalKey = Object.keys(obj).find(function (objKey) { return objKey.toLowerCase() === providedKey.toLowerCase(); });
        return __assign(__assign({}, filteredHeaders), (originalKey && (_a = {}, _a[originalKey] = obj[originalKey], _a)));
    }, {});
}
exports.pickIgnoreCase = pickIgnoreCase;
/**
 * Returns the value of an object based on the given key, independent of casing.
 * @param obj - Object to be searched for the given key.
 * @param key - Key of the value to pick.
 * @returns The value of for the given key or `undefined`, if not available.
 */
function pickValueIgnoreCase(obj, key) {
    if (obj === void 0) { obj = {}; }
    return Object.values(pickIgnoreCase(obj, key))[0];
}
exports.pickValueIgnoreCase = pickValueIgnoreCase;
/**
 * Create a shallow copy of the given object, that contains all entries with non-nullish values.
 * @param obj - An object to pick from.
 * @returns - A filtered object containing only keys with non-nullish values.
 */
function pickNonNullish(obj) {
    if (obj === void 0) { obj = {}; }
    return Object.entries(obj)
        .filter(function (_a) {
        var key = _a[0], value = _a[1];
        return !(0, nullish_1.isNullish)(key) && !(0, nullish_1.isNullish)(value);
    })
        .reduce(function (filtered, _a) {
        var _b;
        var key = _a[0], value = _a[1];
        return (__assign(__assign({}, filtered), (_b = {}, _b[key] = value, _b)));
    }, {});
}
exports.pickNonNullish = pickNonNullish;
/**
 * Create an object by merging the `right` object into a shallow copy of the `left` object ignoring casing, but keeping the `right` casing. Only keys present in the `left` object will be present in the merged object.
 * @param left - Object to merge into. They keys of this object will be present in the returned object.
 * @param right - Object to merge. Only keys in `left` will be considered for merging.
 * @returns - An object containing all keys from the `left` object, where entries present in the `right` object are replaced. Note that the casing used by `right` will be used.
 */
function mergeLeftIgnoreCase(left, right) {
    if (left === void 0) { left = {}; }
    if (right === void 0) { right = {}; }
    return Object.entries(left)
        .map(function (_a) {
        var _b;
        var key = _a[0], value = _a[1];
        return pickValueIgnoreCase(right, key)
            ? pickIgnoreCase(right, key)
            : (_b = {}, _b[key] = value, _b);
    })
        .reduce(function (replaced, obj) { return (__assign(__assign({}, replaced), obj)); }, {});
}
exports.mergeLeftIgnoreCase = mergeLeftIgnoreCase;
/**
 * Create an object by merging the `right` object into a shallow copy of the `left` object ignoring casing, but keeping the right casing. Keys present both objects will be present in the merged object.
 * @param left - Object to merge.
 * @param right - Object to merge. The casing of the keys of this object takes precedence.
 * @returns - An object containing all keys from both objects, where entries present in the `right` object are replaced. Note that the casing used by `right` will be used.
 */
function mergeIgnoreCase(left, right) {
    if (left === void 0) { left = {}; }
    if (right === void 0) { right = {}; }
    return __assign(__assign({}, mergeLeftIgnoreCase(left, right)), right);
}
exports.mergeIgnoreCase = mergeIgnoreCase;
//# sourceMappingURL=object.js.map