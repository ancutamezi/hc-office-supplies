"use strict";
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.documentationBlock = void 0;
var array_1 = require("./array");
var logger_1 = require("./logger");
var string_formatter_1 = require("./string-formatter");
var logger = (0, logger_1.createLogger)('documentation-block');
/**
 * @experimental This API is experimental and might change in newer versions. Use with caution.
 * Transform strings and arguments to a string formatted as a documentation block.
 * The formatting is block like so no leading or trailing spaces.
 * New lines in the beginning and end are also removed.
 * Use in tagged templates, e. g.:
 * ```
 * documentationBlock`Docs with ${arguments} and more content;`
 * ```
 * @param strings - Strings in the tagged template. In the example above that would be ['Docs with ', ' and more content;'].
 * @param args - Arguments in the tagged template. In the example above that would be the resolved value for `arguments`;
 * @returns A string formatted as documentation block.
 */
function documentationBlock(strings) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
    }
    var firstLineTrimmed = removeLeadingEmptyLines(strings.raw[0]);
    var textIndentation = getIndentation(firstLineTrimmed);
    var argsWithIndentation = addIndentationToArguments(args, textIndentation);
    var content = (0, array_1.zip)(__spreadArray([firstLineTrimmed], strings.raw.slice(1), true), argsWithIndentation).join('');
    // If no text is given return just empty string.
    if (!content.match(/\w/)) {
        return '';
    }
    content = maskProblematicCharacters(content);
    var lines = content.split(string_formatter_1.unixEOL);
    lines = adjustIndentation(lines, textIndentation);
    content = lines.join("".concat(string_formatter_1.unixEOL, " * "));
    var result = ['/**', " * ".concat(content), ' */'].join(string_formatter_1.unixEOL);
    return result;
}
exports.documentationBlock = documentationBlock;
/*
New lines at the beginning are mainly unintentional when you make documentationBlock`
myContent
`
 */
function removeLeadingEmptyLines(firstLine) {
    var lines = firstLine.split(string_formatter_1.unixEOL);
    var indexFirstNonEmpty = lines.findIndex(function (str) { return str.match(/\w/); }) || 0;
    return lines.splice(indexFirstNonEmpty).join(string_formatter_1.unixEOL);
}
/*
 The arguments do not contain any indentation so this is added via this method.
 */
function addIndentationToArguments(args, textIndentation) {
    var argsWithIndentation = args.map(function (arg) {
        return arg.replace(/\n/g, string_formatter_1.unixEOL + ' '.repeat(textIndentation));
    });
    return argsWithIndentation;
}
/*
 Takes the first text line as reference and does indentation with respect to this line.
 */
function adjustIndentation(lines, textIndentation) {
    return lines.map(function (str) { return str.slice(textIndentation); });
}
/*
 Searches for the first line containing text and returns the number of white spaces in that line.
 */
function getIndentation(firstLine) {
    var removeStarting = firstLine === null || firstLine === void 0 ? void 0 : firstLine.replace(/^\n*/g, '');
    var countEmptySpaces = removeStarting === null || removeStarting === void 0 ? void 0 : removeStarting.search(/\S/);
    return countEmptySpaces > 0 ? countEmptySpaces : 0;
}
function maskProblematicCharacters(str) {
    if (str.includes('*/')) {
        logger.warn("The documentation block ".concat(str, "'\n      )} contained */ in the text will be masked as \\*\\/."));
    }
    return str.replace(/\*\//g, '\\*\\/');
}
//# sourceMappingURL=documentation-block.js.map