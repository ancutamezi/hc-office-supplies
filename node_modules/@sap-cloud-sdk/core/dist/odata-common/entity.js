"use strict";
/* eslint-disable max-classes-per-file */
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EntityBase = exports.isExpandedProperty = exports.isExistentProperty = exports.isSelectedProperty = exports.Entity = void 0;
var util_1 = require("@sap-cloud-sdk/util");
var entity_builder_1 = require("./entity-builder");
var properties_util_1 = require("./properties-util");
/**
 * Super class for all representations of OData entity types.
 */
var Entity = /** @class */ (function () {
    function Entity() {
        (0, properties_util_1.nonEnumerable)(this, '_oDataVersion');
        (0, properties_util_1.nonEnumerable)(this, '_customFields');
        this._customFields = {};
    }
    Entity.entityBuilder = function (entityConstructor) {
        var builder = new entity_builder_1.EntityBuilder(entityConstructor);
        entityConstructor._allFields.forEach(function (field) {
            var fieldName = "".concat((0, util_1.camelCase)(field._fieldName));
            builder[fieldName] = function (value) {
                this.entity[fieldName] = value;
                return this;
            };
        });
        return builder;
    };
    Object.defineProperty(Entity.prototype, "versionIdentifier", {
        /**
         * ETag version identifier accessor.
         * @returns The ETag version identifier of the retrieved entity, returns `undefined` if not retrieved.
         */
        get: function () {
            return this._versionIdentifier;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Returns a map that contains all entity custom fields.
     * @returns A map of all defined custom fields in the entity
     */
    Entity.prototype.getCustomFields = function () {
        return this._customFields;
    };
    /**
     * Custom field value getter.
     * @param fieldName - The name of the custom field
     * @returns The value of the corresponding custom field
     */
    Entity.prototype.getCustomField = function (fieldName) {
        return this._customFields[fieldName];
    };
    /**
     * Sets a new custom field in the entity or updates it.
     * Throws an error, if the provided custom field name is already defined by an original field in entity.
     * @param fieldName - The name of the custom field to update
     * @param value - The value of the field
     * @returns The entity itself, to facilitate method chaining
     */
    Entity.prototype.setCustomField = function (fieldName, value) {
        if (this.isConflictingCustomField(fieldName)) {
            throw new Error("The field name \"".concat(fieldName, "\" is already defined in the entity and cannot be set as custom field."));
        }
        this._customFields[fieldName] = value;
        return this;
    };
    /**
     * Validates whether a custom field exists in the entity.
     * @param fieldName - The name of the custom field to update
     * @returns A boolean value, that indicates whether a custom field is defined in entity
     */
    Entity.prototype.hasCustomField = function (fieldName) {
        return this._customFields[fieldName] !== undefined;
    };
    /**
     * Sets custom fields on an entity.
     * @param customFields - Custom fields to set on the entity.
     * @returns The entity itself, to facilitate method chaining
     */
    Entity.prototype.setCustomFields = function (customFields) {
        var _this = this;
        Object.entries(customFields).forEach(function (_a) {
            var key = _a[0], value = _a[1];
            _this.setCustomField(key, value);
        });
        return this;
    };
    /**
     * @deprecated Since v1.34.1. Use [[setCustomFields]] instead.
     * Sets all retrieved custom fields in entity.
     * @param customFields - Extracted custom fields from a retrieved entity.
     * @returns The entity itself, to facilitate method chaining.
     */
    Entity.prototype.initializeCustomFields = function (customFields) {
        return this.setCustomFields(customFields);
    };
    /**
     * Set the ETag version identifier of the retrieved entity.
     * @param etag - The returned ETag version of the entity.
     * @returns The entity itself, to facilitate method chaining.
     */
    Entity.prototype.setVersionIdentifier = function (etag) {
        if (etag && typeof etag === 'string') {
            (0, properties_util_1.nonEnumerable)(this, '_versionIdentifier');
            this._versionIdentifier = etag;
        }
        return this;
    };
    /**
     * @deprecated Since 1.12.0. Will be hidden in version 2.0.
     * Initializes or sets the remoteState of the entity.
     * This function is called on all read, create and update requests.
     * This function should be called after [[initializeCustomFields]], if custom fields are defined.
     * @param state - State to be set as remote state.
     * @returns The entity itself, to facilitate method chaining
     */
    Entity.prototype.setOrInitializeRemoteState = function (state) {
        var _this = this;
        if (!this.remoteState) {
            (0, properties_util_1.nonEnumerable)(this, 'remoteState');
        }
        state = state || this.asObject();
        this.remoteState = Object.entries(state).reduce(function (stateObject, _a) {
            var _b;
            var fieldName = _a[0], value = _a[1];
            var propertyName = _this[(0, util_1.camelCase)(fieldName)]
                ? (0, util_1.camelCase)(fieldName)
                : fieldName;
            return __assign(__assign({}, stateObject), (_b = {}, _b[propertyName] = value, _b));
        }, {});
        return this;
    };
    /**
     * Returns all updated custom field properties compared to the last known remote state.
     * @returns An object containing all updated custom properties, with their new values.
     */
    Entity.prototype.getUpdatedCustomFields = function () {
        var _this = this;
        if (!this.remoteState) {
            return this._customFields;
        }
        return Object.entries(this.getCustomFields())
            .filter(function (_a) {
            var fieldName = _a[0], value = _a[1];
            return _this.remoteState[fieldName] !== value;
        })
            .reduce(function (updatedCustomFields, _a) {
            var _b;
            var fieldName = _a[0], value = _a[1];
            return (__assign(__assign({}, updatedCustomFields), (_b = {}, _b[fieldName] = value, _b)));
        }, {});
    };
    /**
     * Returns all changed properties compared to the last known remote state.
     * The returned properties do not include custom fields.
     * Use [[getUpdatedCustomFields]], if you need custom fields.
     * @returns Entity with all properties that changed
     */
    Entity.prototype.getUpdatedProperties = function () {
        var current = this.asObject();
        return this.getUpdatedPropertyNames().reduce(function (patch, key) {
            var _a;
            return (__assign(__assign({}, patch), (_a = {}, _a[key] = current[key], _a)));
        }, {});
    };
    /**
     * Returns all changed property names compared to the last known remote state.
     * The returned properties names do not include custom fields.
     * Use [[getUpdatedCustomFields]], if you need custom fields.
     * @returns Entity with all properties that changed
     */
    Entity.prototype.getUpdatedPropertyNames = function () {
        var _this = this;
        var currentState = this.asObject();
        var names = Object.keys(currentState).filter(function (key) { return _this.propertyIsEnumerable(key) && !_this.hasCustomField(key); });
        return !this.remoteState
            ? names
            : names.filter(function (key) { return !(0, util_1.equal)(_this.remoteState[key], currentState[key]); });
    };
    /**
     * @deprecated Since v1.34.1. Use [[asObject]] instead.
     * Returns a map of all defined fields in entity to their current values.
     * @param visitedEntities - List of entities to check in case of circular dependencies.
     * @returns Entity with all defined entity fields
     */
    Entity.prototype.getCurrentMapKeys = function (visitedEntities) {
        if (visitedEntities === void 0) { visitedEntities = []; }
        return this.asObject(visitedEntities);
    };
    Entity.prototype.isVisitedEntity = function (entity, visitedEntities) {
        if (visitedEntities === void 0) { visitedEntities = []; }
        return Array.isArray(entity)
            ? entity.some(function (multiLinkChild) { return visitedEntities.includes(multiLinkChild); })
            : visitedEntities.includes(entity);
    };
    Entity.prototype.getCurrentStateForKey = function (key, visitedEntities) {
        if (visitedEntities === void 0) { visitedEntities = []; }
        if ((0, properties_util_1.isNavigationProperty)(key, this.constructor)) {
            if ((0, util_1.isNullish)(this[key])) {
                return this[key];
            }
            return Array.isArray(this[key])
                ? this[key].map(function (linkedEntity) {
                    return linkedEntity.getCurrentMapKeys(visitedEntities);
                })
                : this[key].getCurrentMapKeys(visitedEntities);
        }
        return Array.isArray(this[key]) ? __spreadArray([], this[key], true) : this[key];
    };
    /**
     * Validates whether a field name does not conflict with an original field name and thus can be defined as custom fields.
     * @param customFieldName - Field name to check
     * @returns Boolean value that describes whether a field name can be defined as custom field
     */
    Entity.prototype.isConflictingCustomField = function (customFieldName) {
        return this.constructor._allFields
            .map(function (f) { return f._fieldName; })
            .includes(customFieldName);
    };
    /**
     * Creates an object containing all defined properties, navigation properties and custom fields in the entity.
     * @param visitedEntities - List of entities to check in case of circular dependencies.
     * @returns Entity as an object with all defined entity fields
     */
    Entity.prototype.asObject = function (visitedEntities) {
        var _this = this;
        if (visitedEntities === void 0) { visitedEntities = []; }
        visitedEntities.push(this);
        return Object.keys(this)
            .filter(function (key) {
            return _this.propertyIsEnumerable(key) &&
                (!(0, properties_util_1.isNavigationProperty)(key, _this.constructor) ||
                    !_this.isVisitedEntity(_this[key], visitedEntities));
        })
            .reduce(function (accumulatedMap, key) {
            var _a;
            return (__assign(__assign({}, accumulatedMap), (_a = {}, _a[key] = _this.getCurrentStateForKey(key, visitedEntities), _a)));
        }, this.getCustomFields());
    };
    return Entity;
}());
exports.Entity = Entity;
exports.EntityBase = Entity;
/* eslint-disable valid-jsdoc */
/**
 * @hidden
 */
function isSelectedProperty(json, field) {
    return json.hasOwnProperty(field._fieldName);
}
exports.isSelectedProperty = isSelectedProperty;
/**
 * @hidden
 */
function isExistentProperty(json, link) {
    return isSelectedProperty(json, link) && json[link._fieldName] !== null;
}
exports.isExistentProperty = isExistentProperty;
/**
 * @hidden
 */
function isExpandedProperty(json, link) {
    return (isExistentProperty(json, link) &&
        !json[link._fieldName].hasOwnProperty('__deferred'));
}
exports.isExpandedProperty = isExpandedProperty;
//# sourceMappingURL=entity.js.map