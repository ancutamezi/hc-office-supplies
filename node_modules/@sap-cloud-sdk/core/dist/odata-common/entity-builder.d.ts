import type { Constructable, Entity } from './entity';
/**
 * Type to describe possible inputs for `.fromJson`.
 * This is based on the JSON type of an entity and allows all properties to be optional recursively.
 * It also allows setting unknown properties, which will be treated as custom fields.
 * @typeparam JsonT - JSON type of the entity
 */
declare type FromJsonType<JsonT> = {
    [key: string]: any;
} & {
    [P in keyof JsonT]?: JsonT[P] extends (infer U)[] ? U extends Record<string, any> ? FromJsonType<U>[] : JsonT[P] : JsonT[P] extends Record<string, any> | null | undefined ? FromJsonType<JsonT[P]> | null | undefined : JsonT[P];
};
/**
 * @hidden
 */
export declare class EntityBuilder<EntityT extends Entity, JsonT> {
    private _entityConstructor;
    protected entity: EntityT;
    constructor(_entityConstructor: Constructable<EntityT, JsonT>);
    /**
     * Sets the custom fields for the entity.
     * @param customFields - The custom fields you want to add.
     * @returns The entity builder itself for method chaining
     */
    withCustomFields(customFields: Record<string, any>): this;
    /**
     * Builds the entity.
     * @returns The entity.
     */
    build(): EntityT;
    /**
     * Builds an entity from JSON representation.
     * If you have obtained the JSON as a request payload use the [[deserializeEntity]] methods.
     * Note that fields not mappable to a field in the target entity are silently ignored.
     * @param json - Representation of the entity in JSON format.
     * @returns Entity constructed from JSON representation.
     */
    fromJson(json: FromJsonType<JsonT>): EntityT;
    private filterCustomFields;
}
export {};
//# sourceMappingURL=entity-builder.d.ts.map