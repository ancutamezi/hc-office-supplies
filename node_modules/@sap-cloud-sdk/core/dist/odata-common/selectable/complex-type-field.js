"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.getEdmType = exports.getEntityConstructor = exports.ComplexTypeField = void 0;
var edm_types_1 = require("../edm-types");
var field_1 = require("./field");
var complex_type_namespace_1 = require("./complex-type-namespace");
/**
 * Represents a complex type property of an entity or a complex type.
 *
 * `ComplexTypeField`s are used as static properties of entities and are generated from the metadata, i.e. for each property of
 * an OData entity, that has a complex type, there exists one static instance of `ComplexTypeField` (or rather one of its subclasses) in the corresponding generated class file.
 * `ComplexTypeField`s are used to represent the domain of complex or custom structures that can be used in select, filter and order by functions.
 * For example, when constructing a query on the TimeSheetEntry entity, an instance of `ComplexTypeField<TimeSheetEntry>`
 * can be supplied as argument to the select function, e.g. `TimeSheetEntry.TIME_SHEET_DATA_FIELDS`.
 * Moreover, classes implementing this abstract class will provide property fields, that can be used for filtering and ordering.
 *
 * See also: [[Selectable]]
 * @typeparam EntityT - Type of the entity the field belongs to.
 * @typeparam ComplexT - Type of complex type represented by this field.
 * @typeparam NullableT - Boolean type that represents whether the field is nullable.
 * @typeparam SelectableT - Boolean type that represents whether the field is selectable.
 */
var ComplexTypeField = /** @class */ (function (_super) {
    __extends(ComplexTypeField, _super);
    /**
     * Creates an instance of ComplexTypeField.
     * @param fieldName - Actual name of the field as used in the OData request.
     * @param fieldOf - Either the parent entity constructor of the parent complex type this field belongs to.
     * @param complexTypeOrName - The complex type of the complex type property represented by this or the name of the type of the field according to the metadata description. Using the name here is deprecated.
     * @param fieldOptions - Optional settings for this field.
     */
    function ComplexTypeField(fieldName, fieldOf, complexTypeOrName, fieldOptions) {
        var _this = _super.call(this, fieldName, getEntityConstructor(fieldOf), fieldOptions) || this;
        _this.fieldOf = fieldOf;
        if (typeof complexTypeOrName === 'string') {
            _this.complexTypeName = complexTypeOrName;
        }
        else if ((0, complex_type_namespace_1.isComplexTypeNameSpace)(complexTypeOrName)) {
            _this._complexType = complexTypeOrName;
        }
        return _this;
    }
    /**
     * Gets the path to the complex type property represented by this.
     * @returns The path to the complex type property.
     */
    ComplexTypeField.prototype.fieldPath = function () {
        return this.fieldOf instanceof ComplexTypeField
            ? "".concat(this.fieldOf.fieldPath(), "/").concat(this._fieldName)
            : this._fieldName;
    };
    return ComplexTypeField;
}(field_1.Field));
exports.ComplexTypeField = ComplexTypeField;
/**
 * Convenience method to get the entity constructor of the parent of a complex type.
 * @param fieldOf - Either an entity constructor or another complex type field.
 * @returns The constructor of the transitive parent entity;
 */
function getEntityConstructor(fieldOf) {
    return fieldOf instanceof ComplexTypeField
        ? fieldOf._entityConstructor
        : fieldOf;
}
exports.getEntityConstructor = getEntityConstructor;
/**
 * Convenience method to get the [[EdmTypeShared]] from the overloaded constructor.
 * The two scenarios are:
 * - `complexTypeNameOrEdmType` is of type `EdmTypeShared` and `edmTypeOrUndefined` is `undefined`
 * - `complexTypeNameOrEdmType` is of type `string` and `edmTypeOrUndefined` is of type `EdmTypeShared`
 * @param complexTypeNameOrEdmType - Either the name of the complex type or the EDM type.
 * @param edmTypeOrUndefined - Either the EDM type or `undefined`.
 * @returns The EDM type resolved for the two arguments.
 */
function getEdmType(complexTypeNameOrEdmType, edmTypeOrUndefined) {
    if (edmTypeOrUndefined) {
        if (typeof complexTypeNameOrEdmType === 'string' &&
            !(0, edm_types_1.isEdmType)(complexTypeNameOrEdmType) &&
            (0, edm_types_1.isEdmType)(edmTypeOrUndefined)) {
            return edmTypeOrUndefined;
        }
    }
    else if ((0, edm_types_1.isEdmType)(complexTypeNameOrEdmType)) {
        return complexTypeNameOrEdmType;
    }
    throw new Error("Failed to get EDM type based on '".concat(complexTypeNameOrEdmType, "' and '").concat(edmTypeOrUndefined, "'."));
}
exports.getEdmType = getEdmType;
//# sourceMappingURL=complex-type-field.js.map