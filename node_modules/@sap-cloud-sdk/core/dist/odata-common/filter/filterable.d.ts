import { Entity } from '../entity';
import { FieldType, OneToManyLink } from '../selectable';
import { FilterLambdaExpression, BooleanFilterFunction, Filter, FilterLink, FilterList, UnaryFilter } from '../filter';
/**
 * A union of all types that can be used for filtering.
 * @typeparam EntityT - Type of the entity to be filtered on
 */
export declare type Filterable<EntityT extends Entity, LinkedEntityT extends Entity = any> = Filter<EntityT, FieldType | FieldType[]> | FilterLink<EntityT> | FilterList<EntityT> | FilterLambdaExpression<EntityT> | UnaryFilter<EntityT> | BooleanFilterFunction<EntityT> | OneToManyLink<EntityT, LinkedEntityT>;
/**
 * Combine [[Filterable]]s with logical `and` to create a [[FilterList]].
 *
 * Example:
 * ```ts
 * Entity.requestBuilder()
 *  .getAll()
 *  .filter(and(filterExp1, filterExp2));
 * ```
 *
 * Note that the [[GetAllRequestBuilder.filter | GetAllRequestBuilderV2.filter]]  and [[GetAllRequestBuilderV4.filter]] method take a rest parameter and thereby an array of filter expressions that are then combined conjunctively. As a consequence following is equivalent to the example above:
 * ```ts
 * Entity.requestBuilder()
 *  .getAll()
 *  .filter(filterExp1, filterExp2);
 * ```
 * @typeparam EntityT - Type of the entity filter on.
 * @param expressions - Filterables to be combined with logical `and`.
 * @returns The newly created FilterList.
 */
export declare function and<EntityT extends Entity>(expressions: Filterable<EntityT>[]): FilterList<EntityT>;
export declare function and<EntityT extends Entity>(...expressions: Filterable<EntityT>[]): FilterList<EntityT>;
/**
 * Combine [[Filterable]]s with logical `or` to create a [[FilterList]].
 *
 * Example:
 * ```ts
 * Entity.requestBuilder()
 *  .getAll()
 *  .filter(or(filterExp1, filterExp2));
 * ```
 * @typeparam EntityT - Type of the entity filter on.
 * @param expressions - Filterables to be combined with logical `or`
 * @returns The newly created FilterList
 */
export declare function or<EntityT extends Entity>(expressions: Filterable<EntityT>[]): FilterList<EntityT>;
export declare function or<EntityT extends Entity>(...expressions: Filterable<EntityT>[]): FilterList<EntityT>;
export declare function toFilterableList<EntityT extends Entity, LinkedEntityT extends Entity>(filters: Filterable<EntityT, LinkedEntityT>[]): Filterable<EntityT>[];
/**
 * Negate a filter.
 * @param filter - The filter to negate.
 * @returns The negated filter.
 */
export declare function not<EntityT extends Entity>(filter: Filterable<EntityT>): UnaryFilter<EntityT>;
//# sourceMappingURL=filterable.d.ts.map