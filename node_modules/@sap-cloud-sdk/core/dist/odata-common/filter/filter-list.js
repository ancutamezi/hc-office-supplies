"use strict";
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.isFilterList = exports.FilterList = void 0;
/**
 * Data structure to combine [[Filterable]]s conjunctively and / or disjunctively. A FilterList matches when all filterables within the `andFilters` match and when at least one filterable within the `orFilters` matches. Should not be used directly.
 * @typeparam EntityT -
 */
var FilterList = /** @class */ (function () {
    /**
     * Creates an instance of FilterList.
     * @param andFilters - Filters to be combined by logical conjunction (`and`)
     * @param orFilters - Filters to be combined by logical disjunction (`or`)
     */
    function FilterList(andFilters, orFilters) {
        if (andFilters === void 0) { andFilters = []; }
        if (orFilters === void 0) { orFilters = []; }
        this.andFilters = andFilters;
        this.orFilters = orFilters;
    }
    /**
     * @deprecated Since v1.28.1. This function should not be used, since some OData Services might not support the flattened filter expression.
     * Flattens `andFilters` and `orFilters` as far as possible while staying logically equivalent.
     * @returns Flattened filter list.
     */
    FilterList.prototype.flatten = function () {
        this._flatten('andFilters');
        this._flatten('orFilters');
        return this;
    };
    FilterList.prototype.canFlatten = function (property) {
        var otherProperty = property === 'andFilters' ? 'orFilters' : 'andFilters';
        return this[property].some(function (filter) {
            return filter instanceof FilterList &&
                (!filter.isEmpty(property) || filter.isEmpty(otherProperty));
        });
    };
    FilterList.prototype.isEmpty = function (property) {
        return !this[property].length;
    };
    FilterList.prototype._flatten = function (property) {
        var otherProperty = property === 'andFilters' ? 'orFilters' : 'andFilters';
        while (this.canFlatten(property)) {
            this[property] = this[property].reduce(function (flatList, current) {
                if (current instanceof FilterList) {
                    var flattenedFilters = __spreadArray(__spreadArray([], flatList, true), current[property], true);
                    if (current[otherProperty].length) {
                        current[property] = [];
                        flattenedFilters.push(current.flatten());
                    }
                    return flattenedFilters;
                }
                return __spreadArray(__spreadArray([], flatList, true), [current], false);
            }, []);
        }
    };
    return FilterList;
}());
exports.FilterList = FilterList;
function isFilterList(filterable) {
    return (typeof filterable['field'] === 'undefined' &&
        typeof filterable['operator'] === 'undefined' &&
        typeof filterable['value'] === 'undefined' &&
        typeof filterable['flatten'] === 'function');
}
exports.isFilterList = isFilterList;
//# sourceMappingURL=filter-list.js.map