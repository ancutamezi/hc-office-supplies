"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.filterFunctionsV4 = exports.filterFunctions = exports.hasSubsequence = exports.hasSubset = exports.now = exports.minDateTime = exports.maxDateTime = exports.totalOffsetMinutes = exports.fractionalSeconds = exports.matchesPattern = exports.contains = void 0;
var filter_functions_1 = require("../odata-common/filter/filter-functions");
var filter_function_1 = require("./filter-function");
/* String Functions */
/**
 * Build a filter function to test whether a string is a substring of the other. Evaluates to boolean.
 * @param substr - The substring to test for. This can either be a string, a reference to a field or another filter function.
 * @param str - The string to test. This can either be a string, a reference to a field or another filter function.
 *
 * @returns The newly created filter function
 */
function contains(substr, str) {
    return (0, filter_function_1.filterFunction)('contains', 'boolean', substr, str);
}
exports.contains = contains;
/**
 * Build a filter function to test whether a string matches a pattern. Evaluates to boolean.
 * @param str - The string to get the index from. This can either be a string, a reference to a field or another filter function.
 * @param regex - The pattern to test against. This should be a regular expression as a string.
 * @returns The newly created filter function
 */
function matchesPattern(str, regex) {
    return (0, filter_function_1.filterFunction)('matchesPattern', 'boolean', str, regex);
}
exports.matchesPattern = matchesPattern;
/* Date Functions */
/**
 * Build a filter function to get the fractional seconds of a date. Evaluates to decimal.
 * @param date - The date to get the fractional seconds for. This can either be a date (Moment) or a reference to a field.
 * @returns The newly created filter function
 */
function fractionalSeconds(date) {
    return (0, filter_function_1.filterFunction)('fractionalseconds', 'decimal', date);
}
exports.fractionalSeconds = fractionalSeconds;
/**
 * Build a filter function to get the signed number of minutes in the time zone offset. Evaluates to int.
 * @param date - The date to get the offset minutes for. This can either be a date (Moment) or a reference to a field.
 * @returns The newly created filter function
 */
function totalOffsetMinutes(date) {
    return (0, filter_function_1.filterFunction)('totaloffsetminutes', 'decimal', date);
}
exports.totalOffsetMinutes = totalOffsetMinutes;
/**
 * Build a filter function to get the latest possible point in time. Evaluates to DateTimeOffset.
 * @returns The newly created filter function
 */
function maxDateTime() {
    return (0, filter_function_1.filterFunction)('maxdatetime', 'decimal');
}
exports.maxDateTime = maxDateTime;
/**
 * Build a filter function to get the earliest possible point in time. Evaluates to DateTimeOffset.
 * @returns The newly created filter function
 */
function minDateTime() {
    return (0, filter_function_1.filterFunction)('mindatetime', 'decimal');
}
exports.minDateTime = minDateTime;
/**
 * Build a filter function to get the current point in time. Evaluates to DateTimeOffset.
 * @returns The newly created filter function
 */
function now() {
    return (0, filter_function_1.filterFunction)('now', 'decimal');
}
exports.now = now;
/* Collection functions */
/**
 * Build a filter function to test whether a set is a subset of the other, i. e. whether the second parameter can be transformed into the first by reordering and / or removing items. Evaluates to boolean.
 * @param subset - The subset to test for. This can either be an array, a reference to a field or another filter function.
 * @param set - The set to test. This can either be an array, a reference to a field or another filter function.
 *
 * @returns The newly created filter function
 */
function hasSubset(subset, set) {
    return (0, filter_function_1.filterFunction)('hassubset', 'boolean', subset, set);
}
exports.hasSubset = hasSubset;
/**
 * Build a filter function to test whether a set is a subsequence of the other, i. e. whether the second parameter can be transformed into the first by removing items. Evaluates to boolean.
 * @param subsequence - The subsequence to test for. This can either be an array, a reference to a field or another filter function.
 * @param sequence - The sequence to test. This can either be an array, a reference to a field or another filter function.
 *
 * @returns The newly created filter function
 */
function hasSubsequence(subsequence, sequence) {
    return (0, filter_function_1.filterFunction)('hassubsequence', 'boolean', subsequence, sequence);
}
exports.hasSubsequence = hasSubsequence;
/**
 * TODO: totalseconds, time
 */
/**
 * OData v4 specific filter functions
 */
exports.filterFunctions = __assign(__assign({}, filter_functions_1.filterFunctions), { contains: contains, matchesPattern: matchesPattern, fractionalSeconds: fractionalSeconds, totalOffsetMinutes: totalOffsetMinutes, maxDateTime: maxDateTime, minDateTime: minDateTime, now: now, hasSubset: hasSubset, hasSubsequence: hasSubsequence });
exports.filterFunctionsV4 = exports.filterFunctions;
//# sourceMappingURL=filter-functions.js.map