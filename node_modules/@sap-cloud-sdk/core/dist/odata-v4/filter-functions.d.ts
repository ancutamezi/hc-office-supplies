import moment from 'moment';
import { Field, StringFilterFunction, BooleanFilterFunction, NumberFilterFunction, FilterFunctionPrimitiveParameterType, FieldType, CollectionField } from '../odata-common';
import { CollectionFilterFunction } from '../odata-common/filter/collection-filter-function';
import { Entity } from './entity';
/**
 * Build a filter function to test whether a string is a substring of the other. Evaluates to boolean.
 * @param substr - The substring to test for. This can either be a string, a reference to a field or another filter function.
 * @param str - The string to test. This can either be a string, a reference to a field or another filter function.
 *
 * @returns The newly created filter function
 */
export declare function contains<EntityT extends Entity>(substr: string | Field<EntityT, boolean, boolean> | StringFilterFunction<EntityT>, str: string | Field<EntityT, boolean, boolean> | StringFilterFunction<EntityT>): BooleanFilterFunction<EntityT>;
/**
 * Build a filter function to test whether a string matches a pattern. Evaluates to boolean.
 * @param str - The string to get the index from. This can either be a string, a reference to a field or another filter function.
 * @param regex - The pattern to test against. This should be a regular expression as a string.
 * @returns The newly created filter function
 */
export declare function matchesPattern<EntityT extends Entity>(str: string | Field<EntityT, boolean, boolean> | StringFilterFunction<EntityT>, regex: string): BooleanFilterFunction<EntityT>;
/**
 * Build a filter function to get the fractional seconds of a date. Evaluates to decimal.
 * @param date - The date to get the fractional seconds for. This can either be a date (Moment) or a reference to a field.
 * @returns The newly created filter function
 */
export declare function fractionalSeconds<EntityT extends Entity>(date: moment.Moment | Field<EntityT, boolean, boolean>): NumberFilterFunction<EntityT>;
/**
 * Build a filter function to get the signed number of minutes in the time zone offset. Evaluates to int.
 * @param date - The date to get the offset minutes for. This can either be a date (Moment) or a reference to a field.
 * @returns The newly created filter function
 */
export declare function totalOffsetMinutes<EntityT extends Entity>(date: moment.Moment | Field<EntityT, boolean, boolean>): NumberFilterFunction<EntityT>;
/**
 * Build a filter function to get the latest possible point in time. Evaluates to DateTimeOffset.
 * @returns The newly created filter function
 */
export declare function maxDateTime<EntityT extends Entity>(): NumberFilterFunction<EntityT>;
/**
 * Build a filter function to get the earliest possible point in time. Evaluates to DateTimeOffset.
 * @returns The newly created filter function
 */
export declare function minDateTime<EntityT extends Entity>(): NumberFilterFunction<EntityT>;
/**
 * Build a filter function to get the current point in time. Evaluates to DateTimeOffset.
 * @returns The newly created filter function
 */
export declare function now<EntityT extends Entity>(): NumberFilterFunction<EntityT>;
/**
 * Build a filter function to test whether a set is a subset of the other, i. e. whether the second parameter can be transformed into the first by reordering and / or removing items. Evaluates to boolean.
 * @param subset - The subset to test for. This can either be an array, a reference to a field or another filter function.
 * @param set - The set to test. This can either be an array, a reference to a field or another filter function.
 *
 * @returns The newly created filter function
 */
export declare function hasSubset<EntityT extends Entity, ParamT extends FilterFunctionPrimitiveParameterType, ReturnT extends FieldType>(subset: ParamT[] | CollectionField<EntityT, any, boolean, boolean> | CollectionFilterFunction<EntityT, ReturnT>, set: ParamT[] | CollectionField<EntityT, any, boolean, boolean> | CollectionFilterFunction<EntityT, ReturnT>): BooleanFilterFunction<EntityT>;
/**
 * Build a filter function to test whether a set is a subsequence of the other, i. e. whether the second parameter can be transformed into the first by removing items. Evaluates to boolean.
 * @param subsequence - The subsequence to test for. This can either be an array, a reference to a field or another filter function.
 * @param sequence - The sequence to test. This can either be an array, a reference to a field or another filter function.
 *
 * @returns The newly created filter function
 */
export declare function hasSubsequence<EntityT extends Entity, ParamT extends FilterFunctionPrimitiveParameterType, ReturnT extends FieldType>(subsequence: ParamT[] | Field<EntityT, boolean, boolean> | CollectionFilterFunction<EntityT, ReturnT>, sequence: ParamT[] | Field<EntityT, boolean, boolean> | CollectionFilterFunction<EntityT, ReturnT>): BooleanFilterFunction<EntityT>;
/**
 * TODO: totalseconds, time
 */
/**
 * OData v4 specific filter functions
 */
export declare const filterFunctions: {
    contains: typeof contains;
    matchesPattern: typeof matchesPattern;
    fractionalSeconds: typeof fractionalSeconds;
    totalOffsetMinutes: typeof totalOffsetMinutes;
    maxDateTime: typeof maxDateTime;
    minDateTime: typeof minDateTime;
    now: typeof now;
    hasSubset: typeof hasSubset;
    hasSubsequence: typeof hasSubsequence;
    endsWith: typeof import("../odata-common").endsWith;
    startsWith: typeof import("../odata-common").startsWith;
    length: typeof import("../odata-common").length;
    indexOf: typeof import("../odata-common").indexOf;
    substring: typeof import("../odata-common").substring;
    toLower: typeof import("../odata-common").toLower;
    toUpper: typeof import("../odata-common").toUpper;
    trim: typeof import("../odata-common").trim;
    concat: typeof import("../odata-common").concat;
    round: typeof import("../odata-common").round;
    floor: typeof import("../odata-common").floor;
    ceiling: typeof import("../odata-common").ceiling;
    day: typeof import("../odata-common").day;
    hour: typeof import("../odata-common").hour;
    minute: typeof import("../odata-common").minute;
    month: typeof import("../odata-common").month;
    second: typeof import("../odata-common").second;
    year: typeof import("../odata-common").year;
    isOf: typeof import("../odata-common").isOf;
};
export { filterFunctions as filterFunctionsV4 };
//# sourceMappingURL=filter-functions.d.ts.map