"use strict";
/* eslint-disable valid-jsdoc */
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.tsToEdmV2 = exports.edmToTsV2 = exports.momentToEdmDateTime = exports.edmDateTimeToMoment = exports.tsToEdm = exports.edmToTs = void 0;
var moment_1 = __importDefault(require("moment"));
var payload_value_converter_1 = require("../odata-common/payload-value-converter");
/**
 * @hidden
 */
function edmToTs(value, edmType) {
    if (value === null || typeof value === 'undefined') {
        return value;
    }
    if (deserializers[edmType]) {
        return deserializers[edmType](value);
    }
    return value;
}
exports.edmToTs = edmToTs;
exports.edmToTsV2 = edmToTs;
/**
 * @hidden
 */
function tsToEdm(value, edmType) {
    if (value === null) {
        return 'null';
    }
    if (serializers[edmType]) {
        return serializers[edmType](value);
    }
    return value;
}
exports.tsToEdm = tsToEdm;
exports.tsToEdmV2 = tsToEdm;
var toTime = function (value) {
    var regexResult = /PT(?<hours>\d{1,2}H)?(?<minutes>\d{1,2}M)?(?<seconds>\d{1,2}S)?/.exec(value);
    if (!regexResult) {
        throw new Error("Failed to parse the value: ".concat(value, " to time."));
    }
    var _a = (regexResult === null || regexResult === void 0 ? void 0 : regexResult.groups) || {}, hours = _a.hours, minutes = _a.minutes, seconds = _a.seconds;
    return {
        hours: hours ? parseInt(hours.replace('H', ''), 10) : 0,
        minutes: minutes ? parseInt(minutes.replace('M', ''), 10) : 0,
        seconds: seconds ? parseInt(seconds.replace('S', ''), 10) : 0
    };
};
/**
 * @hidden
 * This function can be used for both Edm.DateTime and and Edm.DateTimeOffset.
 */
function edmDateTimeToMoment(edmDateTime) {
    var _a;
    var dateTimeOffsetComponents = (_a = /^\/Date\((?<ticks>\d+)((?<sign>[+-])(?<offset>\d{4}))?\)\/$/.exec(edmDateTime)) === null || _a === void 0 ? void 0 : _a.groups;
    if (!dateTimeOffsetComponents) {
        throw new Error("Failed to parse edmDateTime: ".concat(edmDateTime, " to moment."));
    }
    var timestamp = (0, moment_1.default)(parseInt(dateTimeOffsetComponents.ticks));
    if (dateTimeOffsetComponents.sign && dateTimeOffsetComponents.offset) {
        var offsetMultiplier = dateTimeOffsetComponents.sign === '+' ? 1 : -1;
        var offsetInMinutes = parseInt(dateTimeOffsetComponents.offset);
        return timestamp.utc().utcOffset(offsetMultiplier * offsetInMinutes);
    }
    return timestamp;
}
exports.edmDateTimeToMoment = edmDateTimeToMoment;
/**
 * @hidden
 * This function can be used for both Edm.DateTime and and Edm.DateTimeOffset.
 */
function momentToEdmDateTime(momentInstance) {
    var timestamp = momentInstance.unix() * 1000;
    // For some reason isUtc() returns wrong values here, so we use the internal flag directly
    if (momentInstance['_isUTC']) {
        var offset = Math.abs(momentInstance.utcOffset());
        var operator = momentInstance.utcOffset() >= 0 ? '+' : '-';
        return "/Date(".concat(timestamp).concat(operator).concat(leftpad(offset, 4), ")/");
    }
    return "/Date(".concat(timestamp, ")/");
}
exports.momentToEdmDateTime = momentToEdmDateTime;
var fromTime = function (value) {
    return 'PT' +
        leftpad(value.hours, 2) +
        'H' +
        leftpad(value.minutes, 2) +
        'M' +
        leftpad(value.seconds, 2) +
        'S';
};
function leftpad(value, targetLength) {
    var str = value.toString();
    if (str.length >= targetLength) {
        return str;
    }
    return '0'.repeat(targetLength - str.length) + str;
}
var deserializers = __assign(__assign({}, payload_value_converter_1.deserializersCommon), { 'Edm.DateTime': edmDateTimeToMoment, 'Edm.DateTimeOffset': edmDateTimeToMoment, 'Edm.Time': toTime });
var serializers = __assign(__assign({}, payload_value_converter_1.serializersCommon), { 'Edm.DateTime': momentToEdmDateTime, 'Edm.DateTimeOffset': momentToEdmDateTime, 'Edm.Time': fromTime });
//# sourceMappingURL=payload-value-converter.js.map