"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.proxyHostAndPort = exports.addProxyConfigurationOnPrem = exports.addProxyConfiguration = void 0;
var util_1 = require("@sap-cloud-sdk/util");
var protocol_1 = require("./protocol");
var environment_accessor_1 = require("./environment-accessor");
var token_accessor_1 = require("./token-accessor");
var jwt_1 = require("./jwt");
var logger = (0, util_1.createLogger)({
    package: 'core',
    messageContext: 'connectivity-service'
});
/**
 * Given a destination and a JWT (required for subscriber destinations), this function will add a proxy configuration to a destination.
 * See also [[ProxyConfiguration]].
 *
 * This function will reject if no connectivity service is bound, no XSUAA service with plan application is bound or the client credentials grant with the XSUAA service fails.
 *
 * @Deprecated Since v1.16.0. Use [[addProxyConfigurationOnPrem]] instead.
 * @param destination - The destination to which the proxy configuration should be added.
 * @param jwt - The JWT of the current user.
 * @returns A promise resolving to the destination with the added proxy configuration.
 */
function addProxyConfiguration(destination, jwt) {
    return __awaiter(this, void 0, void 0, function () {
        var proxyConfiguration, _a, _b;
        var _c;
        return __generator(this, function (_d) {
            switch (_d.label) {
                case 0:
                    _a = [__assign({}, proxyHostAndPort())];
                    _c = {};
                    _b = [{}];
                    return [4 /*yield*/, proxyHeaders(destination.authentication, jwt)];
                case 1:
                    proxyConfiguration = __assign.apply(void 0, _a.concat([(_c.headers = __assign.apply(void 0, _b.concat([(_d.sent())])), _c)]));
                    return [2 /*return*/, __assign(__assign({}, destination), { proxyConfiguration: proxyConfiguration })];
            }
        });
    });
}
exports.addProxyConfiguration = addProxyConfiguration;
// TODO: remove string argument in v2.0
function addProxyConfigurationOnPrem(destination, jwt) {
    var jwtPair = typeof jwt === 'string' ? { encoded: jwt, decoded: (0, jwt_1.decodeJwt)(jwt) } : jwt;
    if (destination.authentication === 'PrincipalPropagation' &&
        !(0, jwt_1.isUserToken)(jwtPair)) {
        throw new Error('For principal propagation a user JWT is needed.');
    }
    return addProxyConfiguration(destination, jwtPair === null || jwtPair === void 0 ? void 0 : jwtPair.encoded);
}
exports.addProxyConfigurationOnPrem = addProxyConfigurationOnPrem;
function proxyHostAndPort() {
    var service = readConnectivityServiceBinding();
    return {
        host: service.credentials.onpremise_proxy_host,
        port: service.credentials.onpremise_proxy_http_port ||
            service.credentials.onpremise_proxy_port,
        protocol: protocol_1.Protocol.HTTP
    };
}
exports.proxyHostAndPort = proxyHostAndPort;
function readConnectivityServiceBinding() {
    var serviceBindings = environment_accessor_1.EnvironmentAccessor.getServiceList('connectivity');
    if (!serviceBindings.length) {
        throw new Error('No binding to a connectivity service found! Please make sure to bind an instance of the connectivity service to your app if you want to connect to on-premise destinations.');
    }
    return serviceBindings[0];
}
function proxyHeaders(authenticationType, jwt) {
    return __awaiter(this, void 0, void 0, function () {
        var proxyAuthHeader, sapConnectivityHeader;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, proxyAuthorizationHeader(jwt)];
                case 1:
                    proxyAuthHeader = _a.sent();
                    sapConnectivityHeader = sapConnectivityAuthenticationHeader(authenticationType, jwt);
                    return [2 /*return*/, __assign(__assign({}, proxyAuthHeader), sapConnectivityHeader)];
            }
        });
    });
}
function proxyAuthorizationHeader(userJwt) {
    return __awaiter(this, void 0, void 0, function () {
        var connServiceBinding, token, error_1;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    _a.trys.push([0, 2, , 3]);
                    connServiceBinding = readConnectivityServiceBinding();
                    return [4 /*yield*/, (0, token_accessor_1.serviceToken)(connServiceBinding, { userJwt: userJwt })];
                case 1:
                    token = _a.sent();
                    return [2 /*return*/, { 'Proxy-Authorization': "Bearer ".concat(token) }];
                case 2:
                    error_1 = _a.sent();
                    throw new util_1.ErrorWithCause('Failed to add proxy authorization header - client credentials grant failed!', error_1);
                case 3: return [2 /*return*/];
            }
        });
    });
}
function sapConnectivityAuthenticationHeader(authenticationType, jwt) {
    if (authenticationType === 'PrincipalPropagation') {
        if (jwt) {
            return {
                'SAP-Connectivity-Authentication': "Bearer ".concat(jwt)
            };
        }
        throw new Error("Unable to create \"SAP-Connectivity-Authentication\" header: no JWT found on the current request.\n     Connecting to on-premise systems via principle propagation is not possible.");
    }
    if (authenticationType === 'BasicAuthentication') {
        logger.warn('You are connecting to an On-Premise system using basic authentication. For productive usage Principal propagation is recommended.');
    }
    return {};
}
//# sourceMappingURL=connectivity-service.js.map